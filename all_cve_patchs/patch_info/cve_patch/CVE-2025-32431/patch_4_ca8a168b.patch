From ca8a168bf693f98d6b42d6c124e4f2699bd0f47d Mon Sep 17 00:00:00 2001
From: romain <rtribotte@users.noreply.github.com>
Date: Tue, 15 Apr 2025 10:29:56 +0200
Subject: [PATCH] review: clean only dotdot sequences

---
 docs/content/migration/v2.md             |  2 +-
 pkg/server/server_entrypoint_tcp.go      | 73 ++++++++++++++++++++++--
 pkg/server/server_entrypoint_tcp_test.go | 29 ++++++----
 3 files changed, 85 insertions(+), 19 deletions(-)

diff --git a/docs/content/migration/v2.md b/docs/content/migration/v2.md
index ac82027c23..86ba3f92fc 100644
--- a/docs/content/migration/v2.md
+++ b/docs/content/migration/v2.md
@@ -660,4 +660,4 @@ Please refer to the Forwarded headers [documentation](../routing/entrypoints.md#
 ## v2.11.23
 
 In `v2.11.23`, the incoming request path is now cleaned before being used to match the router rules and sent to the backends.
-Any /./ or /../ sequences are interpreted and removed from the path.
+Any `/../` sequence is interpreted and removed from the path.
diff --git a/pkg/server/server_entrypoint_tcp.go b/pkg/server/server_entrypoint_tcp.go
index 01ae62ebda..462655dd56 100644
--- a/pkg/server/server_entrypoint_tcp.go
+++ b/pkg/server/server_entrypoint_tcp.go
@@ -572,9 +572,9 @@ func createHTTPServer(ctx context.Context, ln net.Listener, configuration *stati
 	}
 
 	handler = denyFragment(handler)
-	// cleanPath is used to flatten the URL path (essentially remove /./ and /../),
+	// cleanDotDotSegments is used to clean the URL path by removing /../ sequences,
 	// to make sure the path is interpreted by the backends as it is evaluated inside rule matchers.
-	handler = cleanPath(handler)
+	handler = cleanDotDotSegments(handler)
 
 	if configuration.HTTP.EncodeQuerySemicolons {
 		handler = encodeQuerySemicolons(handler)
@@ -718,18 +718,79 @@ func denyFragment(h http.Handler) http.Handler {
 	})
 }
 
-// cleanPath is a http.Handler that cleans the URL path.
+// cleanDotDotSegments removes the ".." segments from the URL path.
 // It cleans the request URL Path and RawPath, and updates the request URI.
-func cleanPath(h http.Handler) http.Handler {
+func cleanDotDotSegments(h http.Handler) http.Handler {
 	return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
 		r2 := new(http.Request)
 		*r2 = *req
+		r2.URL = new(url.URL)
+		*r2.URL = *req.URL
+
+		escapedPath := removeDotDotSegments(r2.URL.EscapedPath())
+
+		// Set the cleaned path to the URL.
+		// This behaves like url.setPath.
+		var err error
+		r2.URL.Path, err = url.PathUnescape(escapedPath)
+		// This error is not expected to happen, but if it does, we log it and return a 500 error.
+		if err != nil {
+			log.WithoutContext().WithError(err).Error("Cleaning dotdot segments: unescape path")
+			rw.WriteHeader(http.StatusInternalServerError)
+			return
+		}
+
+		if r2.URL.Path != escapedPath {
+			r2.URL.RawPath = escapedPath
+		} else {
+			r2.URL.RawPath = ""
+		}
 
-		// JoinPath cleans the URL path and rawPath, using the escaped version if needed.
-		r2.URL = req.URL.JoinPath()
 		// Because the reverse proxy director is building query params from requestURI it needs to be updated as well.
 		r2.RequestURI = r2.URL.RequestURI()
 
 		h.ServeHTTP(rw, r2)
 	})
 }
+
+// removeDotDotSegments removes ".." segments from the given path, preserving other parts like double slashes.
+func removeDotDotSegments(path string) string {
+	if path == "" {
+		return ""
+	}
+
+	// Ensure the path starts with a slash.
+	if path[0] != '/' {
+		path = "/" + path
+	}
+
+	var stack []string
+
+	for _, seg := range strings.Split(path, "/") {
+		if seg == ".." {
+			// Remove the last valid segment if possible
+			if len(stack) > 0 {
+				stack = stack[:len(stack)-1]
+			}
+			continue
+		}
+
+		// Keep everything else (including empty strings)
+		stack = append(stack, seg)
+	}
+
+	// Reassemble the path with original slash pattern
+	cleanPath := strings.Join(stack, "/")
+
+	// Ensure the path starts with a slash.
+	if cleanPath[0] != '/' {
+		cleanPath = "/" + cleanPath
+	}
+
+	// Ensure the path ends with a slash if the original path did.
+	if path[len(path)-1] == '/' && cleanPath[len(cleanPath)-1] != '/' {
+		cleanPath = cleanPath + "/"
+	}
+
+	return cleanPath
+}
diff --git a/pkg/server/server_entrypoint_tcp_test.go b/pkg/server/server_entrypoint_tcp_test.go
index 6f52cc7dcd..f4008dc7c6 100644
--- a/pkg/server/server_entrypoint_tcp_test.go
+++ b/pkg/server/server_entrypoint_tcp_test.go
@@ -384,27 +384,32 @@ func TestKeepAliveH2c(t *testing.T) {
 	require.Contains(t, err.Error(), "use of closed network connection")
 }
 
-func TestCleanPath(t *testing.T) {
+func TestCleanDotDotSegments(t *testing.T) {
 	tests := []struct {
-		path, result string
+		path     string
+		expected string
 	}{
-		{"/../../b", "/b"},
-		{"/a/../b", "/b"},
-		{"/a/../../b", "/b"},
-		{"/a/../c/../b", "/b"},
-		{"/a/../../../c/../b", "/b"},
-		{"/a/../c/../../b", "/b"},
-		{"/a/..//c/.././b", "/b"},
+		{path: "/../../b", expected: "/b"},
+		{path: "/a/../../b", expected: "/b"},
+		{path: "/..///b///", expected: "//b///"},
+		{path: "/a/../b", expected: "/b"},
+		{path: "/a/./b", expected: "/a/./b"},
+		{path: "/a//b", expected: "/a//b"},
+		{path: "/a/../../b", expected: "/b"},
+		{path: "/a/../c/../b", expected: "/b"},
+		{path: "/a/../../../c/../b", expected: "/b"},
+		{path: "/a/../c/../../b", expected: "/b"},
+		{path: "/a/..//c/.././b", expected: "//./b"},
 	}
 
 	for _, test := range tests {
-		t.Run(test.path, func(t *testing.T) {
+		t.Run("Testing case: "+test.path, func(t *testing.T) {
 			t.Parallel()
 
 			var callCount int
-			clean := cleanPath(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			clean := cleanDotDotSegments(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 				callCount++
-				assert.Equal(t, test.result, r.URL.Path)
+				assert.Equal(t, test.expected, r.URL.Path)
 			}))
 
 			request := httptest.NewRequest(http.MethodGet, "http://foo"+test.path, http.NoBody)
