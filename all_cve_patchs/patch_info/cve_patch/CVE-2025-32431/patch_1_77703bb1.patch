From 77703bb1b7a14362ebb3af8d681e4630bf453251 Mon Sep 17 00:00:00 2001
From: romain <rtribotte@users.noreply.github.com>
Date: Fri, 11 Apr 2025 15:27:19 +0200
Subject: [PATCH] fix: clean the request path

---
 docs/content/migration/v2.md                |  5 ++
 integration/fixtures/simple_clean_path.toml | 34 +++++++++++
 integration/simple_test.go                  | 65 +++++++++++++++++++++
 pkg/server/server_entrypoint_tcp.go         | 25 ++++++++
 pkg/server/server_entrypoint_tcp_test.go    | 33 +++++++++++
 5 files changed, 162 insertions(+)
 create mode 100644 integration/fixtures/simple_clean_path.toml

diff --git a/docs/content/migration/v2.md b/docs/content/migration/v2.md
index 3e8ac35844..ac82027c23 100644
--- a/docs/content/migration/v2.md
+++ b/docs/content/migration/v2.md
@@ -656,3 +656,8 @@ Please check out the [entrypoint forwarded headers connection option configurati
 
 In `v2.11.14`, the `X-Forwarded-Prefix` header is now handled like the other `X-Forwarded-*` headers: Traefik removes it when it's sent from an untrusted source.
 Please refer to the Forwarded headers [documentation](../routing/entrypoints.md#forwarded-headers) for more details.
+
+## v2.11.23
+
+In `v2.11.23`, the incoming request path is now cleaned before being used to match the router rules and sent to the backends.
+Any /./ or /../ sequences are interpreted and removed from the path.
diff --git a/integration/fixtures/simple_clean_path.toml b/integration/fixtures/simple_clean_path.toml
new file mode 100644
index 0000000000..1d74f1aade
--- /dev/null
+++ b/integration/fixtures/simple_clean_path.toml
@@ -0,0 +1,34 @@
+[global]
+  checkNewVersion = false
+  sendAnonymousUsage = false
+
+[entryPoints]
+  [entryPoints.web]
+    address = ":8000"
+
+[api]
+  insecure = true
+
+[providers.file]
+  filename = "{{ .SelfFilename }}"
+
+# dynamic configuration
+[http.routers]
+  [http.routers.without]
+    rule = "PathPrefix(`/without`)"
+    service = "whoami"
+
+  [http.routers.with]
+    rule = "PathPrefix(`/with`)"
+    middlewares = ["test-redirectscheme"]
+    service = "whoami"
+
+[http.middlewares]
+  [http.middlewares.test-redirectscheme.redirectScheme]
+    scheme = "https"
+    permanent = true
+
+[http.services]
+  [http.services.whoami.loadBalancer]
+    [[http.services.whoami.loadBalancer.servers]]
+      url = "{{ .Server1 }}"
diff --git a/integration/simple_test.go b/integration/simple_test.go
index 8ab5e06264..f617d18a18 100644
--- a/integration/simple_test.go
+++ b/integration/simple_test.go
@@ -1385,3 +1385,68 @@ func (s *SimpleSuite) TestDenyFragment() {
 	require.NoError(s.T(), err)
 	assert.Equal(s.T(), http.StatusBadRequest, resp.StatusCode)
 }
+
+func (s *SimpleSuite) TestCleanPath() {
+	s.createComposeProject("base")
+
+	s.composeUp()
+	defer s.composeDown()
+
+	whoami1URL := "http://" + net.JoinHostPort(s.getComposeServiceIP("whoami1"), "80")
+
+	file := s.adaptFile("fixtures/simple_clean_path.toml", struct {
+		Server1 string
+	}{whoami1URL})
+
+	s.traefikCmd(withConfigFile(file))
+
+	err := try.GetRequest("http://127.0.0.1:8080/api/rawdata", 1*time.Second, try.BodyContains("PathPrefix(`/with`)"))
+	require.NoError(s.T(), err)
+
+	testCases := []struct {
+		desc     string
+		request  string
+		target   string
+		body     string
+		expected int
+	}{
+		{
+			desc:     "Explicit call to the route with a middleware",
+			request:  "GET /with HTTP/1.1\r\nHost: other.localhost\r\n\r\n",
+			target:   "127.0.0.1:8000",
+			expected: http.StatusMovedPermanently,
+		},
+		{
+			desc:     "Explicit call to the route without a middleware",
+			request:  "GET /without HTTP/1.1\r\nHost: other.localhost\r\n\r\n",
+			target:   "127.0.0.1:8000",
+			expected: http.StatusOK,
+			body:     "GET /without HTTP/1.1",
+		},
+		{
+			desc:     "Implicit call to the route with a middleware",
+			request:  "GET /without/../with HTTP/1.1\r\nHost: other.localhost\r\n\r\n",
+			target:   "127.0.0.1:8000",
+			expected: http.StatusMovedPermanently,
+		},
+	}
+
+	for _, test := range testCases {
+		conn, err := net.Dial("tcp", test.target)
+		require.NoError(s.T(), err)
+
+		_, err = conn.Write([]byte(test.request))
+		require.NoError(s.T(), err)
+
+		resp, err := http.ReadResponse(bufio.NewReader(conn), nil)
+		require.NoError(s.T(), err)
+
+		assert.Equalf(s.T(), test.expected, resp.StatusCode, "%s failed with %d instead of %d", test.desc, resp.StatusCode, test.expected)
+
+		if test.body != "" {
+			body, err := io.ReadAll(resp.Body)
+			require.NoError(s.T(), err)
+			assert.Contains(s.T(), string(body), test.body)
+		}
+	}
+}
diff --git a/pkg/server/server_entrypoint_tcp.go b/pkg/server/server_entrypoint_tcp.go
index 5d170685f6..0d4dbd8a06 100644
--- a/pkg/server/server_entrypoint_tcp.go
+++ b/pkg/server/server_entrypoint_tcp.go
@@ -10,6 +10,7 @@ import (
 	"net/http"
 	"net/url"
 	"os"
+	"path"
 	"strings"
 	"sync"
 	"syscall"
@@ -572,6 +573,10 @@ func createHTTPServer(ctx context.Context, ln net.Listener, configuration *stati
 	}
 
 	handler = denyFragment(handler)
+	// cleanPath is used to flatten the URL path (essentially remove /./ and /../),
+	// to make sure the path is interpreted by the backends as it is evaluated inside rule matchers.
+	handler = cleanPath(handler)
+
 	if configuration.HTTP.EncodeQuerySemicolons {
 		handler = encodeQuerySemicolons(handler)
 	} else {
@@ -713,3 +718,23 @@ func denyFragment(h http.Handler) http.Handler {
 		h.ServeHTTP(rw, req)
 	})
 }
+
+// cleanPath is a http.Handler that cleans the URL path.
+// It cleans the request URL path and rawPath, and updates the request URI.
+func cleanPath(h http.Handler) http.Handler {
+	return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
+		r2 := new(http.Request)
+		*r2 = *req
+		r2.URL = new(url.URL)
+		*r2.URL = *req.URL
+
+		r2.URL.Path = path.Clean(req.URL.Path)
+		if r2.URL.Path != req.URL.Path && req.URL.RawPath != "" {
+			r2.URL.RawPath = url.PathEscape(r2.URL.Path)
+		}
+		// Because the reverse proxy director is building query params from requestURI it needs to be updated as well.
+		r2.RequestURI = r2.URL.RequestURI()
+
+		h.ServeHTTP(rw, r2)
+	})
+}
diff --git a/pkg/server/server_entrypoint_tcp_test.go b/pkg/server/server_entrypoint_tcp_test.go
index f3b8865c92..cfbb388ae7 100644
--- a/pkg/server/server_entrypoint_tcp_test.go
+++ b/pkg/server/server_entrypoint_tcp_test.go
@@ -8,6 +8,7 @@ import (
 	"io"
 	"net"
 	"net/http"
+	"net/http/httptest"
 	"strings"
 	"testing"
 	"time"
@@ -382,3 +383,35 @@ func TestKeepAliveH2c(t *testing.T) {
 	// to change.
 	require.Contains(t, err.Error(), "use of closed network connection")
 }
+
+func TestCleanPath(t *testing.T) {
+	tests := []struct {
+		path, result string
+	}{
+		{"/../../b", "/b"},
+		{"/a/../b", "/b"},
+		{"/a/../../b", "/b"},
+		{"/a/../c/../b", "/b"},
+		{"/a/../../../c/../b", "/b"},
+		{"/a/../c/../../b", "/b"},
+		{"/a/..//c/.././b", "/b"},
+		{"/abc/def/../../../ghi/jkl/../../../mno", "/mno"},
+	}
+
+	for _, test := range tests {
+		t.Run(test.path, func(t *testing.T) {
+			t.Parallel()
+
+			var callCount int
+			clean := cleanPath(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+				callCount++
+				assert.Equal(t, test.result, r.URL.Path)
+			}))
+
+			request := httptest.NewRequest(http.MethodGet, "http://foo"+test.path, http.NoBody)
+			clean.ServeHTTP(httptest.NewRecorder(), request)
+
+			assert.Equal(t, 1, callCount)
+		})
+	}
+}
