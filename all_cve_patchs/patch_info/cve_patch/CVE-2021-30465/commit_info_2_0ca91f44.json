{
  "index": 2,
  "original_url": "https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f",
  "patch_url": "https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f.patch",
  "commit_info": {
    "type": "direct_commit",
    "hash": "0ca91f44f1664da834bc61115a849b56d22f595f",
    "url": "https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f",
    "owner": "opencontainers",
    "repo": "runc",
    "message": "rootfs: add mount destination validation\n\nBecause the target of a mount is inside a container (which may be a\nvolume that is shared with another container), there exists a race\ncondition where the target of the mount may change to a path containing\na symlink after we have sanitised the path -- resulting in us\ninadvertently mounting the path outside of the container.\n\nThis is not immediately useful because we are in a mount namespace with\nMS_SLAVE mount propagation applied to \"/\", so we cannot mount on top of\nhost paths in the host namespace. However, if any subsequent mountpoints\nin the configuration use a subdirectory of that host path as a source,\nthose subsequent mounts will use an attacker-controlled source path\n(resolved within the host rootfs) -- allowing the bind-mounting of \"/\"\ninto the container.\n\nWhile arguably configuration issues like this are not entirely within\nrunc's threat model, within the context of Kubernetes (and possibly\nother container managers that provide semi-arbitrary container creation\nprivileges to untrusted users) this is a legitimate issue. Since we\ncannot block mounting from the host into the container, we need to block\nthe first stage of this attack (mounting onto a path outside the\ncontainer).\n\nThe long-term plan to solve this would be to migrate to libpathrs, but\nas a stop-gap we implement libpathrs-like path verification through\nreadlink(/proc/self/fd/$n) and then do mount operations through the\nprocfd once it's been verified to be inside the container. The target\ncould move after we've checked it, but if it is inside the container\nthen we can assume that it is safe for the same reason that libpathrs\noperations would be safe.\n\nA slight wrinkle is the \"copyup\" functionality we provide for tmpfs,\nwhich is the only case where we want to do a mount on the host\nfilesystem. To facilitate this, I split out the copy-up functionality\nentirely so that the logic isn't interspersed with the regular tmpfs\nlogic. In addition, all dependencies on m.Destination being overwritten\nhave been removed since that pattern was just begging to be a source of\nmore mount-target bugs (we do still have to modify m.Destination for\ntmpfs-copyup but we only do it temporarily).\n\nFixes: CVE-2021-30465\nReported-by: Etienne Champetier <champetier.etienne@gmail.com>\nCo-authored-by: Noah Meyerhans <nmeyerha@amazon.com>\nReviewed-by: Samuel Karp <skarp@amazon.com>\nReviewed-by: Kir Kolyshkin <kolyshkin@gmail.com> (@kolyshkin)\nReviewed-by: Akihiro Suda <akihiro.suda.cz@hco.ntt.co.jp>\nSigned-off-by: Aleksa Sarai <cyphar@cyphar.com>",
    "author": "Aleksa Sarai",
    "date": "2021-04-01T19:00:31Z"
  },
  "patch_stats": {
    "files_modified": 4,
    "lines_added": 229,
    "lines_removed": 136,
    "total_changes": 365,
    "file_list": [
      "libcontainer/container_linux.go",
      "libcontainer/rootfs_linux.go",
      "libcontainer/utils/utils.go",
      "libcontainer/utils/utils_test.go"
    ],
    "file_extensions": [
      "go"
    ],
    "binary_files": 0
  }
}