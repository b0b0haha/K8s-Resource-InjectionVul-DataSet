From d0222867e69342b85c8d69bb272755c439c9bfb4 Mon Sep 17 00:00:00 2001
From: Stefan Prodan <stefan.prodan@gmail.com>
Date: Wed, 29 Sep 2021 14:14:24 +0300
Subject: [PATCH] Skip pruning for objects with a different owner

Signed-off-by: Stefan Prodan <stefan.prodan@gmail.com>
---
 controllers/kustomization_controller.go |   2 +
 controllers/kustomization_prune_test.go | 121 ++++++++++++++++++++++++
 internal/ssa/manager.go                 |   8 ++
 internal/ssa/manager_delete.go          |  19 +++-
 internal/ssa/manager_delete_test.go     |   4 +-
 5 files changed, 149 insertions(+), 5 deletions(-)

diff --git a/controllers/kustomization_controller.go b/controllers/kustomization_controller.go
index 1a2d5eea..29868174 100644
--- a/controllers/kustomization_controller.go
+++ b/controllers/kustomization_controller.go
@@ -725,6 +725,7 @@ func (r *KustomizationReconciler) prune(ctx context.Context, manager *ssa.Resour
 
 	log := logr.FromContext(ctx)
 	changeSet, err := manager.DeleteAll(ctx, objects,
+		manager.GetOwnerLabels(kustomization.Name, kustomization.Namespace),
 		map[string]string{
 			fmt.Sprintf("%s/prune", kustomizev1.GroupVersion.Group): kustomizev1.DisabledValue,
 		},
@@ -762,6 +763,7 @@ func (r *KustomizationReconciler) finalize(ctx context.Context, kustomization ku
 			})
 
 			changeSet, err := resourceManager.DeleteAll(ctx, objects,
+				resourceManager.GetOwnerLabels(kustomization.Name, kustomization.Namespace),
 				map[string]string{
 					fmt.Sprintf("%s/prune", kustomizev1.GroupVersion.Group): kustomizev1.DisabledValue,
 				},
diff --git a/controllers/kustomization_prune_test.go b/controllers/kustomization_prune_test.go
index fc45217b..d07bf337 100644
--- a/controllers/kustomization_prune_test.go
+++ b/controllers/kustomization_prune_test.go
@@ -314,3 +314,124 @@ kind: Kustomization
 		g.Expect(len(resultK.Status.Inventory.Entries)).Should(BeIdenticalTo(2))
 	})
 }
+
+func TestKustomizationReconciler_PruneSkipNotOwned(t *testing.T) {
+	g := NewWithT(t)
+	id := "gc-" + randStringRunes(5)
+	revision := "v1.0.0"
+
+	err := createNamespace(id)
+	g.Expect(err).NotTo(HaveOccurred(), "failed to create test namespace")
+
+	err = createKubeConfigSecret(id)
+	g.Expect(err).NotTo(HaveOccurred(), "failed to create kubeconfig secret")
+
+	manifests := func(name string, data string) []testserver.File {
+		return []testserver.File{
+			{
+				Name: "secret.yaml",
+				Body: fmt.Sprintf(`---
+apiVersion: v1
+kind: Secret
+metadata:
+  name: %[1]s
+stringData:
+  key: "%[2]s"
+`, name, data),
+			},
+			{
+				Name: "config.yaml",
+				Body: fmt.Sprintf(`---
+apiVersion: v1
+kind: ConfigMap
+metadata:
+  name: %[1]s
+data:
+  key: "%[2]s"
+`, name, data),
+			},
+		}
+	}
+
+	artifact, err := testServer.ArtifactFromFiles(manifests(id, id))
+	g.Expect(err).NotTo(HaveOccurred())
+
+	url := fmt.Sprintf("%s/%s", testServer.URL(), artifact)
+
+	repositoryName := types.NamespacedName{
+		Name:      fmt.Sprintf("gc-%s", randStringRunes(5)),
+		Namespace: id,
+	}
+
+	err = applyGitRepository(repositoryName, url, revision, "")
+	g.Expect(err).NotTo(HaveOccurred())
+
+	kustomizationKey := types.NamespacedName{
+		Name:      fmt.Sprintf("gc-%s", randStringRunes(5)),
+		Namespace: id,
+	}
+	kustomization := &kustomizev1.Kustomization{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      kustomizationKey.Name,
+			Namespace: kustomizationKey.Namespace,
+		},
+		Spec: kustomizev1.KustomizationSpec{
+			Interval: metav1.Duration{Duration: reconciliationInterval},
+			Path:     "./",
+			KubeConfig: &kustomizev1.KubeConfig{
+				SecretRef: meta.LocalObjectReference{
+					Name: "kubeconfig",
+				},
+			},
+			SourceRef: kustomizev1.CrossNamespaceSourceReference{
+				Name:      repositoryName.Name,
+				Namespace: repositoryName.Namespace,
+				Kind:      sourcev1.GitRepositoryKind,
+			},
+			TargetNamespace: id,
+			Prune:           true,
+			Wait:            true,
+		},
+	}
+
+	g.Expect(k8sClient.Create(context.Background(), kustomization)).To(Succeed())
+
+	resultK := &kustomizev1.Kustomization{}
+	resultSecret := &corev1.Secret{}
+	resultConfig := &corev1.ConfigMap{}
+
+	g.Eventually(func() bool {
+		_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+		return resultK.Status.LastAppliedRevision == revision
+	}, timeout, time.Second).Should(BeTrue())
+
+	t.Run("creates objects with owner labels", func(t *testing.T) {
+		g.Expect(k8sClient.Get(context.Background(), types.NamespacedName{Name: id, Namespace: id}, resultSecret)).Should(Succeed())
+		g.Expect(k8sClient.Get(context.Background(), types.NamespacedName{Name: id, Namespace: id}, resultConfig)).Should(Succeed())
+
+		name, _ := resultConfig.GetLabels()["kustomize.toolkit.fluxcd.io/name"]
+		g.Expect(name).Should(BeIdenticalTo(kustomizationKey.Name))
+
+		namespace, _ := resultConfig.GetLabels()["kustomize.toolkit.fluxcd.io/namespace"]
+		g.Expect(namespace).Should(BeIdenticalTo(kustomizationKey.Namespace))
+	})
+
+	resultConfig.Labels["kustomize.toolkit.fluxcd.io/name"] = "new-owner"
+	g.Expect(k8sClient.Update(context.Background(), resultConfig)).Should(Succeed())
+
+	t.Run("deletes owned objects", func(t *testing.T) {
+		g.Expect(k8sClient.Delete(context.Background(), kustomization)).To(Succeed())
+		g.Eventually(func() bool {
+			err = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), kustomization)
+			return apierrors.IsNotFound(err)
+		}, timeout, time.Second).Should(BeTrue())
+
+		err = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(resultSecret), resultSecret)
+		g.Expect(apierrors.IsNotFound(err)).To(BeTrue())
+	})
+
+	t.Run("preserves objects with different owner", func(t *testing.T) {
+		g.Expect(k8sClient.Get(context.Background(), client.ObjectKeyFromObject(resultConfig), resultConfig)).Should(Succeed())
+	})
+
+}
diff --git a/internal/ssa/manager.go b/internal/ssa/manager.go
index 4fde20c5..71ad6b39 100644
--- a/internal/ssa/manager.go
+++ b/internal/ssa/manager.go
@@ -64,6 +64,14 @@ func (m *ResourceManager) SetOwnerLabels(objects []*unstructured.Unstructured, n
 	}
 }
 
+// GetOwnerLabels returns a map of labels for the specified name and namespace.
+func (m *ResourceManager) GetOwnerLabels(name, namespace string) map[string]string {
+	return map[string]string{
+		m.owner.Group + "/name":      name,
+		m.owner.Group + "/namespace": namespace,
+	}
+}
+
 func (m *ResourceManager) changeSetEntry(object *unstructured.Unstructured, action Action) *ChangeSetEntry {
 	return &ChangeSetEntry{Subject: objectutil.FmtUnstructured(object), Action: string(action)}
 }
diff --git a/internal/ssa/manager_delete.go b/internal/ssa/manager_delete.go
index ff3bfb52..0b71583f 100644
--- a/internal/ssa/manager_delete.go
+++ b/internal/ssa/manager_delete.go
@@ -25,12 +25,14 @@ import (
 	"github.com/fluxcd/kustomize-controller/internal/objectutil"
 
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"k8s.io/apimachinery/pkg/labels"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 )
 
 // Delete deletes the given object (not found errors are ignored).
-func (m *ResourceManager) Delete(ctx context.Context, object *unstructured.Unstructured, skipFor map[string]string) (*ChangeSetEntry, error) {
+func (m *ResourceManager) Delete(ctx context.Context, object *unstructured.Unstructured, labelSelector map[string]string, skipFor map[string]string) (*ChangeSetEntry, error) {
 	existingObject := object.DeepCopy()
 	err := m.client.Get(ctx, client.ObjectKeyFromObject(object), existingObject)
 	if err != nil {
@@ -41,6 +43,16 @@ func (m *ResourceManager) Delete(ctx context.Context, object *unstructured.Unstr
 		return m.changeSetEntry(object, DeletedAction), nil
 	}
 
+	sel, err := metav1.LabelSelectorAsSelector(&metav1.LabelSelector{MatchLabels: labelSelector})
+	if err != nil {
+		return m.changeSetEntry(object, UnknownAction),
+			fmt.Errorf("%s label selector failed, error: %w", objectutil.FmtUnstructured(object), err)
+	}
+
+	if !sel.Matches(labels.Set(existingObject.GetLabels())) {
+		return m.changeSetEntry(object, UnchangedAction), nil
+	}
+
 	for n, s := range skipFor {
 		if existingObject.GetLabels()[n] == s || existingObject.GetAnnotations()[n] == s {
 			return m.changeSetEntry(object, UnchangedAction), nil
@@ -56,13 +68,14 @@ func (m *ResourceManager) Delete(ctx context.Context, object *unstructured.Unstr
 }
 
 // DeleteAll deletes the given set of objects (not found errors are ignored).
-func (m *ResourceManager) DeleteAll(ctx context.Context, objects []*unstructured.Unstructured, skipFor map[string]string) (*ChangeSet, error) {
+// The given objects are filtered based on the metadata present in-cluster.
+func (m *ResourceManager) DeleteAll(ctx context.Context, objects []*unstructured.Unstructured, labelSelector map[string]string, skipFor map[string]string) (*ChangeSet, error) {
 	sort.Sort(sort.Reverse(objectutil.SortableUnstructureds(objects)))
 	changeSet := NewChangeSet()
 
 	var errors string
 	for _, object := range objects {
-		cse, err := m.Delete(ctx, object, skipFor)
+		cse, err := m.Delete(ctx, object, labelSelector, skipFor)
 		if cse != nil {
 			changeSet.Add(*cse)
 		}
diff --git a/internal/ssa/manager_delete_test.go b/internal/ssa/manager_delete_test.go
index 017c4cd8..46bee9fb 100644
--- a/internal/ssa/manager_delete_test.go
+++ b/internal/ssa/manager_delete_test.go
@@ -48,7 +48,7 @@ func TestDelete(t *testing.T) {
 	}
 
 	t.Run("deletes objects in order", func(t *testing.T) {
-		changeSet, err := manager.DeleteAll(ctx, objects, nil)
+		changeSet, err := manager.DeleteAll(ctx, objects, nil, nil)
 		if err != nil {
 			t.Fatal(err)
 		}
@@ -87,7 +87,7 @@ func TestDelete(t *testing.T) {
 	})
 
 	t.Run("waits for objects termination", func(t *testing.T) {
-		_, err := manager.DeleteAll(ctx, objects, nil)
+		_, err := manager.DeleteAll(ctx, objects, nil, nil)
 		if err != nil {
 			t.Error(err)
 		}
