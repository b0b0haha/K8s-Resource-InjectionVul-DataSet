From 1e01d800c56ca21e0aaef5d8d1cfc4debb7ed228 Mon Sep 17 00:00:00 2001
From: Stefan Prodan <stefan.prodan@gmail.com>
Date: Sat, 11 Sep 2021 18:58:29 +0300
Subject: [PATCH] Implement reconciliation using server-side apply Reconciler
 behaviour: - Creates an inventory of objects to be applied (persisted
 in-cluster under `.status.inventory`). - Applies first custom resource
 definitions (CRDs) and namespaces, waits for them to register and only then
 applies the custom resources. - Validates all resources with server-side
 dry-run apply (namespaced objects must contain `metadata.namespace`,
 defaulting to the `default` namespace is no longer supported). - Reconciles
 only the resources that drifted. - Prunes the objects that were previously
 applied but are missing from the current inventory. - Emits events for only
 the resources that where created, configured or deleted.

Signed-off-by: Stefan Prodan <stefan.prodan@gmail.com>
---
 Makefile                                      |  11 +-
 controllers/kustomization_controller.go       | 415 +++++++++---------
 controllers/kustomization_decryptor.go        |   2 +-
 controllers/kustomization_decryptor_test.go   |   9 +-
 controllers/kustomization_dependson_test.go   | 148 +++++++
 controllers/kustomization_force_test.go       |  20 +-
 controllers/kustomization_gc.go               | 205 ---------
 controllers/kustomization_generator.go        | 191 +-------
 controllers/kustomization_healthcheck.go      | 145 ------
 controllers/kustomization_impersonation.go    |  25 +-
 controllers/kustomization_indexers.go         |   2 +-
 controllers/kustomization_inventory.go        | 165 +++++++
 ...gc_test.go => kustomization_prune_test.go} |  83 +---
 ...t.go => kustomization_transformer_test.go} |  11 +-
 controllers/kustomization_varsub.go           |   2 +-
 ...s_test.go => kustomization_varsub_test.go} |   8 +-
 controllers/kustomization_wait_test.go        | 164 +++++++
 controllers/suite_test.go                     |  31 +-
 controllers/utils.go                          |  92 ----
 controllers/utils_test.go                     |  86 ----
 main.go                                       |  10 +-
 21 files changed, 773 insertions(+), 1052 deletions(-)
 create mode 100644 controllers/kustomization_dependson_test.go
 delete mode 100644 controllers/kustomization_gc.go
 delete mode 100644 controllers/kustomization_healthcheck.go
 create mode 100644 controllers/kustomization_inventory.go
 rename controllers/{kustomization_gc_test.go => kustomization_prune_test.go} (67%)
 rename controllers/{kustomization_transformers_test.go => kustomization_transformer_test.go} (97%)
 rename controllers/{kustomization_vars_test.go => kustomization_varsub_test.go} (96%)
 create mode 100644 controllers/kustomization_wait_test.go
 delete mode 100644 controllers/utils.go
 delete mode 100644 controllers/utils_test.go

diff --git a/Makefile b/Makefile
index f6d5d928..9756a554 100644
--- a/Makefile
+++ b/Makefile
@@ -19,11 +19,14 @@ ENVTEST_AKUBERNETES_VERSION=latest
 install-envtest: setup-envtest
 	$(SETUP_ENVTEST) use $(ENVTEST_AKUBERNETES_VERSION) --bin-dir=$(ENVTEST_ASSETS_DIR)
 
-# Run tests
+# Run controller tests
 KUBEBUILDER_ASSETS?="$(shell $(SETUP_ENVTEST) use -i $(ENVTEST_AKUBERNETES_VERSION) --bin-dir=$(ENVTEST_ASSETS_DIR) -p path)"
 test: generate fmt vet manifests api-docs download-crd-deps install-envtest
-	KUBEBUILDER_ASSETS=$(KUBEBUILDER_ASSETS) go test ./...  -v -coverprofile cover.out
-	cd api; go test ./... -v
+	KUBEBUILDER_ASSETS=$(KUBEBUILDER_ASSETS) go test ./controllers/...  -v -coverprofile cover.out
+
+# Run internal tests
+test-internal: install-envtest
+	KUBEBUILDER_ASSETS=$(KUBEBUILDER_ASSETS) go test ./internal/...  -v -coverprofile cover.out
 
 # Build manager binary
 manager: generate fmt vet
@@ -72,7 +75,7 @@ manifests: controller-gen
 
 # Generate API reference documentation
 api-docs: gen-crd-api-reference-docs
-	$(API_REF_GEN) -api-dir=./api/v1beta1 -config=./hack/api-docs/config.json -template-dir=./hack/api-docs/template -out-file=./docs/api/kustomize.md
+	$(API_REF_GEN) -api-dir=./api/v1beta2 -config=./hack/api-docs/config.json -template-dir=./hack/api-docs/template -out-file=./docs/api/kustomize.md
 
 # Run go mod tidy
 tidy:
diff --git a/controllers/kustomization_controller.go b/controllers/kustomization_controller.go
index de74a12d..ab91be14 100644
--- a/controllers/kustomization_controller.go
+++ b/controllers/kustomization_controller.go
@@ -17,15 +17,14 @@ limitations under the License.
 package controllers
 
 import (
+	"bytes"
 	"context"
-	"errors"
 	"fmt"
 	"io/ioutil"
 	"net/http"
 	"net/url"
 	"os"
-	"os/exec"
-	"path/filepath"
+	"sort"
 	"strings"
 	"time"
 
@@ -41,6 +40,7 @@ import (
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
 	apimeta "k8s.io/apimachinery/pkg/api/meta"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/types"
 	kuberecorder "k8s.io/client-go/tools/record"
@@ -56,7 +56,9 @@ import (
 	"sigs.k8s.io/controller-runtime/pkg/source"
 	"sigs.k8s.io/kustomize/api/filesys"
 
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
+	"github.com/fluxcd/kustomize-controller/internal/objectutil"
+	"github.com/fluxcd/kustomize-controller/internal/ssa"
 )
 
 // +kubebuilder:rbac:groups=kustomize.toolkit.fluxcd.io,resources=kustomizations,verbs=get;list;watch;create;update;patch;delete
@@ -150,7 +152,7 @@ func (r *KustomizationReconciler) Reconcile(ctx context.Context, req ctrl.Reques
 
 	// Examine if the object is under deletion
 	if !kustomization.ObjectMeta.DeletionTimestamp.IsZero() {
-		return r.reconcileDelete(ctx, kustomization)
+		return r.finalize(ctx, kustomization)
 	}
 
 	// Return early if the Kustomization is suspended.
@@ -250,14 +252,15 @@ func (r *KustomizationReconciler) Reconcile(ctx context.Context, req ctrl.Reques
 	}
 
 	// broadcast the reconciliation result and requeue at the specified interval
-	log.Info(fmt.Sprintf("Reconciliation finished in %s, next run in %s",
+	msg := fmt.Sprintf("Reconciliation finished in %s, next run in %s",
 		time.Now().Sub(reconcileStart).String(),
-		kustomization.Spec.Interval.Duration.String()),
+		kustomization.Spec.Interval.Duration.String())
+	log.Info(fmt.Sprintf(msg),
 		"revision",
 		source.GetArtifact().Revision,
 	)
 	r.event(ctx, reconciledKustomization, source.GetArtifact().Revision, events.EventSeverityInfo,
-		"Update completed", map[string]string{"commit_status": "update"})
+		msg, map[string]string{"commit_status": "update"})
 	return ctrl.Result{RequeueAfter: kustomization.Spec.Interval.Duration}, nil
 }
 
@@ -270,6 +273,8 @@ func (r *KustomizationReconciler) reconcile(
 		kustomization.Status.SetLastHandledReconcileRequest(v)
 	}
 
+	log := logr.FromContext(ctx)
+
 	// create tmp dir
 	tmpDir, err := ioutil.TempDir("", kustomization.Name)
 	if err != nil {
@@ -326,8 +331,8 @@ func (r *KustomizationReconciler) reconcile(
 		), fmt.Errorf("failed to build kube client: %w", err)
 	}
 
-	// generate kustomization.yaml and calculate the manifests checksum
-	checksum, err := r.generate(ctx, kubeClient, kustomization, dirPath)
+	// generate kustomization.yaml if needed
+	err = r.generate(kustomization, dirPath)
 	if err != nil {
 		return kustomizev1.KustomizationNotReady(
 			kustomization,
@@ -337,8 +342,8 @@ func (r *KustomizationReconciler) reconcile(
 		), err
 	}
 
-	// build the kustomization and generate the GC snapshot
-	snapshot, err := r.build(ctx, kustomization, checksum, dirPath)
+	// build the kustomization
+	resources, err := r.build(ctx, kustomization, dirPath)
 	if err != nil {
 		return kustomizev1.KustomizationNotReady(
 			kustomization,
@@ -348,54 +353,166 @@ func (r *KustomizationReconciler) reconcile(
 		), err
 	}
 
-	// dry-run apply
-	err = r.validate(ctx, kustomization, impersonation, dirPath)
+	objects, err := objectutil.ReadObjects(bytes.NewReader(resources))
 	if err != nil {
 		return kustomizev1.KustomizationNotReady(
 			kustomization,
 			source.GetArtifact().Revision,
-			kustomizev1.ValidationFailedReason,
+			kustomizev1.BuildFailedReason,
 			err.Error(),
-		), stripSensitiveData(err)
+		), err
 	}
 
-	// apply
-	changeSet, err := r.applyWithRetry(ctx, kustomization, impersonation, source.GetArtifact().Revision, dirPath, 5*time.Second)
-	if err != nil {
-		return kustomizev1.KustomizationNotReady(
-			kustomization,
-			source.GetArtifact().Revision,
-			meta.ReconciliationFailedReason,
-			err.Error(),
-		), stripSensitiveData(err)
-	}
+	resourceManager := ssa.NewResourceManager(kubeClient, statusPoller, ssa.Owner{
+		Field: kustomizev1.KustomizationController,
+		Group: kustomizev1.GroupVersion.Group,
+	})
+	resourceManager.SetOwnerLabels(objects, kustomization.GetName(), kustomization.GetNamespace())
 
-	// prune
-	err = r.prune(ctx, kubeClient, kustomization, checksum)
+	// create an inventory of objects to be reconciled
+	newInventory := NewInventory()
+	err = AddObjectsToInventory(newInventory, objects)
 	if err != nil {
 		return kustomizev1.KustomizationNotReady(
 			kustomization,
 			source.GetArtifact().Revision,
-			kustomizev1.PruneFailedReason,
+			kustomizev1.BuildFailedReason,
 			err.Error(),
 		), err
 	}
 
+	// detect stale objects which are subject to garbage collection
+	var staleObjects []*unstructured.Unstructured
+	oldInventory := kustomization.Status.Inventory
+	if oldInventory != nil {
+		staleObjects, err = DiffInventory(oldInventory, newInventory)
+		if err != nil {
+			return kustomizev1.KustomizationNotReady(
+				kustomization,
+				source.GetArtifact().Revision,
+				kustomizev1.BuildFailedReason,
+				err.Error(),
+			), err
+		}
+	}
+
+	// contains only CRDs and Namespaces
+	var stageOne []*unstructured.Unstructured
+
+	// contains all objects except for CRDs and Namespaces
+	var stageTwo []*unstructured.Unstructured
+
+	for _, u := range objects {
+		if resourceManager.IsClusterDefinition(u.GetKind()) {
+			stageOne = append(stageOne, u)
+		} else {
+			stageTwo = append(stageTwo, u)
+		}
+	}
+
+	var changeSetLog strings.Builder
+
+	// validate, apply and wait for CRDs and Namespaces to register
+	if len(stageOne) > 0 {
+		changeSet, err := resourceManager.ApplyAll(ctx, stageOne, kustomization.Spec.Force)
+		if err != nil {
+			return kustomizev1.KustomizationNotReady(
+				kustomization,
+				source.GetArtifact().Revision,
+				meta.ReconciliationFailedReason,
+				err.Error(),
+			), err
+		}
+
+		if changeSet != nil && len(changeSet.Entries) > 0 {
+			log.Info("server-side apply completed", "output", changeSet.ToMap())
+			for _, change := range changeSet.Entries {
+				if change.Action != string(ssa.UnchangedAction) {
+					changeSetLog.WriteString(change.String() + "\n")
+				}
+			}
+		}
+
+		if err := resourceManager.Wait(stageOne, 2*time.Second, kustomization.GetTimeout()); err != nil {
+			return kustomizev1.KustomizationNotReady(
+				kustomization,
+				source.GetArtifact().Revision,
+				meta.ReconciliationFailedReason,
+				err.Error(),
+			), err
+		}
+	}
+
+	// sort by kind, validate and apply all the others objects
+	sort.Sort(objectutil.SortableUnstructureds(stageTwo))
+	if len(stageTwo) > 0 {
+		changeSet, err := resourceManager.ApplyAll(ctx, stageTwo, kustomization.Spec.Force)
+		if err != nil {
+			return kustomizev1.KustomizationNotReady(
+				kustomization,
+				source.GetArtifact().Revision,
+				meta.ReconciliationFailedReason,
+				err.Error(),
+			), err
+		}
+
+		if changeSet != nil && len(changeSet.Entries) > 0 {
+			log.Info("server-side apply completed", "output", changeSet.ToMap())
+			for _, change := range changeSet.Entries {
+				if change.Action != string(ssa.UnchangedAction) {
+					changeSetLog.WriteString(change.String() + "\n")
+				}
+			}
+		}
+	}
+
+	// emit event only if the server-side apply resulted in changes
+	applyLog := strings.TrimSuffix(changeSetLog.String(), "\n")
+	if applyLog == "" {
+		log.Info("server-side apply dry-run completed: no drift detected")
+	} else {
+		r.event(ctx, kustomization, source.GetArtifact().Revision, events.EventSeverityInfo, applyLog, nil)
+	}
+
+	// run garbage collection for stale objects that do not have pruning disabled
+	if kustomization.Spec.Prune {
+		changeSet, err := resourceManager.DeleteAll(ctx, staleObjects,
+			map[string]string{
+				fmt.Sprintf("%s/prune", kustomizev1.GroupVersion.Group): kustomizev1.DisabledValue,
+			},
+		)
+		if err != nil {
+			return kustomizev1.KustomizationNotReadyInventory(
+				kustomization,
+				newInventory,
+				source.GetArtifact().Revision,
+				kustomizev1.PruneFailedReason,
+				err.Error(),
+			), err
+		}
+
+		// emit event only if the prune operation resulted in changes
+		if changeSet != nil && len(changeSet.Entries) > 0 {
+			log.Info(fmt.Sprintf("garbage collection completed: %s", changeSet.String()))
+			r.event(ctx, kustomization, source.GetArtifact().Revision, events.EventSeverityInfo, changeSet.String(), nil)
+		}
+	}
+
 	// health assessment
-	err = r.checkHealth(ctx, statusPoller, kustomization, source.GetArtifact().Revision, changeSet != "")
+	err = r.checkHealth(ctx, resourceManager, kustomization, source.GetArtifact().Revision, applyLog != "")
 	if err != nil {
-		return kustomizev1.KustomizationNotReadySnapshot(
+		return kustomizev1.KustomizationNotReadyInventory(
 			kustomization,
-			snapshot,
+			newInventory,
 			source.GetArtifact().Revision,
 			kustomizev1.HealthCheckFailedReason,
 			err.Error(),
 		), err
 	}
 
-	return kustomizev1.KustomizationReady(
+	return kustomizev1.KustomizationReadyInventory(
 		kustomization,
-		snapshot,
+		newInventory,
 		source.GetArtifact().Revision,
 		meta.ReconciliationSucceededReason,
 		"Applied revision: "+source.GetArtifact().Revision,
@@ -498,12 +615,12 @@ func (r *KustomizationReconciler) getSource(ctx context.Context, kustomization k
 	return source, nil
 }
 
-func (r *KustomizationReconciler) generate(ctx context.Context, kubeClient client.Client, kustomization kustomizev1.Kustomization, dirPath string) (string, error) {
-	gen := NewGenerator(kustomization, kubeClient)
-	return gen.WriteFile(ctx, dirPath)
+func (r *KustomizationReconciler) generate(kustomization kustomizev1.Kustomization, dirPath string) error {
+	gen := NewGenerator(kustomization)
+	return gen.WriteFile(dirPath)
 }
 
-func (r *KustomizationReconciler) build(ctx context.Context, kustomization kustomizev1.Kustomization, checksum, dirPath string) (*kustomizev1.Snapshot, error) {
+func (r *KustomizationReconciler) build(ctx context.Context, kustomization kustomizev1.Kustomization, dirPath string) ([]byte, error) {
 	timeout := kustomization.GetTimeout()
 	ctx, cancel := context.WithTimeout(context.Background(), timeout)
 	defer cancel()
@@ -562,186 +679,20 @@ func (r *KustomizationReconciler) build(ctx context.Context, kustomization kusto
 		return nil, fmt.Errorf("kustomize build failed: %w", err)
 	}
 
-	manifestsFile := filepath.Join(dirPath, fmt.Sprintf("%s.yaml", kustomization.GetUID()))
-	if err := fs.WriteFile(manifestsFile, resources); err != nil {
-		return nil, err
-	}
-
-	return kustomizev1.NewSnapshot(resources, checksum)
+	return resources, nil
 }
 
-func (r *KustomizationReconciler) validate(ctx context.Context, kustomization kustomizev1.Kustomization, imp *KustomizeImpersonation, dirPath string) error {
-	if kustomization.Spec.Validation == "" || kustomization.Spec.Validation == "none" {
+func (r *KustomizationReconciler) checkHealth(ctx context.Context, man *ssa.ResourceManager, kustomization kustomizev1.Kustomization, revision string, changed bool) error {
+	if len(kustomization.Spec.HealthChecks) == 0 {
 		return nil
 	}
 
-	log := logr.FromContext(ctx)
-	timeout := kustomization.GetTimeout() + (time.Second * 1)
-	applyCtx, cancel := context.WithTimeout(ctx, timeout)
-	defer cancel()
-
-	validation := kustomization.Spec.Validation
-	if validation == "server" && kustomization.Spec.Force {
-		// Use client-side validation with force
-		validation = "client"
-		log.Info(fmt.Sprintf("Server-side validation is configured, falling-back to client-side validation since 'force' is enabled"))
-	}
-
-	cmd := fmt.Sprintf("cd %s && kubectl apply -f %s.yaml --timeout=%s --dry-run=%s --cache-dir=/tmp --force=%t",
-		dirPath, kustomization.GetUID(), kustomization.GetTimeout().String(), validation, kustomization.Spec.Force)
-
-	if kustomization.Spec.KubeConfig != nil {
-		kubeConfig, err := imp.WriteKubeConfig(ctx)
-		if err != nil {
-			return err
-		}
-		cmd = fmt.Sprintf("%s --kubeconfig=%s", cmd, kubeConfig)
-	} else {
-		// impersonate SA
-		if kustomization.Spec.ServiceAccountName != "" {
-			saToken, err := imp.GetServiceAccountToken(ctx)
-			if err != nil {
-				return fmt.Errorf("service account impersonation failed: %w", err)
-			}
-
-			cmd = fmt.Sprintf("%s --token %s", cmd, saToken)
-		}
-	}
-
-	command := exec.CommandContext(applyCtx, "/bin/sh", "-c", cmd)
-	output, err := command.CombinedOutput()
+	objects, err := referenceToUnstructured(kustomization.Spec.HealthChecks)
 	if err != nil {
-		if errors.Is(applyCtx.Err(), context.DeadlineExceeded) {
-			return fmt.Errorf("validation timeout: %w", applyCtx.Err())
-		}
-		return fmt.Errorf("validation failed: %s", parseApplyError(output))
-	}
-	return nil
-}
-
-func (r *KustomizationReconciler) apply(ctx context.Context, kustomization kustomizev1.Kustomization, imp *KustomizeImpersonation, dirPath string) (string, error) {
-	log := logr.FromContext(ctx)
-	start := time.Now()
-	timeout := kustomization.GetTimeout() + (time.Second * 1)
-	applyCtx, cancel := context.WithTimeout(ctx, timeout)
-	defer cancel()
-	fieldManager := "kustomize-controller"
-
-	cmd := fmt.Sprintf("cd %s && kubectl apply --field-manager=%s -f %s.yaml --timeout=%s --cache-dir=/tmp --force=%t",
-		dirPath, fieldManager, kustomization.GetUID(), kustomization.Spec.Interval.Duration.String(), kustomization.Spec.Force)
-
-	if kustomization.Spec.KubeConfig != nil {
-		kubeConfig, err := imp.WriteKubeConfig(ctx)
-		if err != nil {
-			return "", err
-		}
-		cmd = fmt.Sprintf("%s --kubeconfig=%s", cmd, kubeConfig)
-	} else {
-		// impersonate SA
-		if kustomization.Spec.ServiceAccountName != "" {
-			saToken, err := imp.GetServiceAccountToken(ctx)
-			if err != nil {
-				return "", fmt.Errorf("service account impersonation failed: %w", err)
-			}
-
-			cmd = fmt.Sprintf("%s --token %s", cmd, saToken)
-		}
-	}
-
-	command := exec.CommandContext(applyCtx, "/bin/sh", "-c", cmd)
-	output, err := command.CombinedOutput()
-	if err != nil {
-		if errors.Is(applyCtx.Err(), context.DeadlineExceeded) {
-			return "", fmt.Errorf("apply timeout: %w", applyCtx.Err())
-		}
-
-		if string(output) == "" {
-			return "", fmt.Errorf("apply failed: %w, kubectl process was killed, probably due to OOM", err)
-		}
-
-		applyErr := parseApplyError(output)
-		if applyErr == "" {
-			applyErr = "no error output found, this may happen because of a timeout"
-		}
-		return "", fmt.Errorf("apply failed: %s", applyErr)
-	}
-
-	resources := parseApplyOutput(output)
-	log.Info(
-		fmt.Sprintf("Kustomization applied in %s",
-			time.Now().Sub(start).String()),
-		"output", resources,
-	)
-
-	changeSet := ""
-	for obj, action := range resources {
-		if action != "" && action != "unchanged" {
-			changeSet += obj + " " + action + "\n"
-		}
-	}
-	return changeSet, nil
-}
-
-func (r *KustomizationReconciler) applyWithRetry(ctx context.Context, kustomization kustomizev1.Kustomization, imp *KustomizeImpersonation, revision, dirPath string, delay time.Duration) (string, error) {
-	log := logr.FromContext(ctx)
-	changeSet, err := r.apply(ctx, kustomization, imp, dirPath)
-	if err != nil {
-		// retry apply due to CRD/CR race
-		if strings.Contains(err.Error(), "could not find the requested resource") ||
-			strings.Contains(err.Error(), "no matches for kind") {
-			log.Info("retrying apply", "error", err.Error())
-			time.Sleep(delay)
-			if changeSet, err := r.apply(ctx, kustomization, imp, dirPath); err != nil {
-				return "", err
-			} else {
-				if changeSet != "" {
-					r.event(ctx, kustomization, revision, events.EventSeverityInfo, changeSet, nil)
-				}
-			}
-		} else {
-			return "", err
-		}
-	} else {
-		if changeSet != "" && kustomization.Status.LastAppliedRevision != revision {
-			r.event(ctx, kustomization, revision, events.EventSeverityInfo, changeSet, nil)
-		}
-	}
-	return changeSet, nil
-}
-
-func (r *KustomizationReconciler) prune(ctx context.Context, kubeClient client.Client, kustomization kustomizev1.Kustomization, newChecksum string) error {
-	if !kustomization.Spec.Prune || kustomization.Status.Snapshot == nil {
-		return nil
-	}
-	if kustomization.DeletionTimestamp.IsZero() && kustomization.Status.Snapshot.Checksum == newChecksum {
-		return nil
-	}
-
-	log := logr.FromContext(ctx)
-	gc := NewGarbageCollector(kubeClient, *kustomization.Status.Snapshot, newChecksum, logr.FromContext(ctx))
-
-	if output, ok := gc.Prune(kustomization.GetTimeout(),
-		kustomization.GetName(),
-		kustomization.GetNamespace(),
-	); !ok {
-		return fmt.Errorf("garbage collection failed: %s", output)
-	} else {
-		if output != "" {
-			log.Info(fmt.Sprintf("garbage collection completed: %s", output))
-			r.event(ctx, kustomization, newChecksum, events.EventSeverityInfo, output, nil)
-		}
-	}
-	return nil
-}
-
-func (r *KustomizationReconciler) checkHealth(ctx context.Context, statusPoller *polling.StatusPoller, kustomization kustomizev1.Kustomization, revision string, changed bool) error {
-	if len(kustomization.Spec.HealthChecks) == 0 {
-		return nil
+		return err
 	}
 
-	hc := NewHealthCheck(kustomization, statusPoller)
-
-	if err := hc.Assess(1 * time.Second); err != nil {
+	if err := man.Wait(objects, time.Second, kustomization.GetTimeout()); err != nil {
 		return err
 	}
 
@@ -754,22 +705,40 @@ func (r *KustomizationReconciler) checkHealth(ctx context.Context, statusPoller
 	return nil
 }
 
-func (r *KustomizationReconciler) reconcileDelete(ctx context.Context, kustomization kustomizev1.Kustomization) (ctrl.Result, error) {
+func (r *KustomizationReconciler) finalize(ctx context.Context, kustomization kustomizev1.Kustomization) (ctrl.Result, error) {
 	log := logr.FromContext(ctx)
 	if kustomization.Spec.Prune && !kustomization.Spec.Suspend {
 		// create any necessary kube-clients
 		imp := NewKustomizeImpersonation(kustomization, r.Client, r.StatusPoller, "")
-		client, _, err := imp.GetClient(ctx)
+		kubeClient, _, err := imp.GetClient(ctx)
 		if err != nil {
 			err = fmt.Errorf("failed to build kube client for Kustomization: %w", err)
 			log.Error(err, "Unable to prune for finalizer")
 			return ctrl.Result{}, err
 		}
-		if err := r.prune(ctx, client, kustomization, ""); err != nil {
+
+		resourceManager := ssa.NewResourceManager(kubeClient, nil, ssa.Owner{
+			Field: kustomizev1.KustomizationController,
+			Group: kustomizev1.GroupVersion.Group,
+		})
+
+		objects, err := ListObjectsInInventory(kustomization.Status.Inventory)
+
+		changeSet, err := resourceManager.DeleteAll(ctx, objects,
+			map[string]string{
+				fmt.Sprintf("%s/prune", kustomizev1.GroupVersion.Group): kustomizev1.DisabledValue,
+			},
+		)
+		if err != nil {
 			r.event(ctx, kustomization, kustomization.Status.LastAppliedRevision, events.EventSeverityError, "pruning for deleted resource failed", nil)
 			// Return the error so we retry the failed garbage collection
 			return ctrl.Result{}, err
 		}
+
+		if changeSet != nil && len(changeSet.Entries) > 0 {
+			r.event(ctx, kustomization, kustomization.Status.LastAppliedRevision, events.EventSeverityInfo, changeSet.String(), nil)
+		}
+
 	}
 
 	// Record deleted status
@@ -787,14 +756,24 @@ func (r *KustomizationReconciler) reconcileDelete(ctx context.Context, kustomiza
 
 func (r *KustomizationReconciler) event(ctx context.Context, kustomization kustomizev1.Kustomization, revision, severity, msg string, metadata map[string]string) {
 	log := logr.FromContext(ctx)
-	r.EventRecorder.Event(&kustomization, "Normal", severity, msg)
-	objRef, err := reference.GetReference(r.Scheme, &kustomization)
-	if err != nil {
-		log.Error(err, "unable to send event")
-		return
+
+	annotations := map[string]string{
+		kustomizev1.GroupVersion.Group + "/revision": revision,
+	}
+
+	eventtype := "Normal"
+	if severity == events.EventSeverityError {
+		eventtype = "Warning"
 	}
 
+	r.EventRecorder.AnnotatedEventf(&kustomization, annotations, eventtype, severity, msg)
+
 	if r.ExternalEventRecorder != nil {
+		objRef, err := reference.GetReference(r.Scheme, &kustomization)
+		if err != nil {
+			log.Error(err, "unable to send event")
+			return
+		}
 		if metadata == nil {
 			metadata = map[string]string{}
 		}
diff --git a/controllers/kustomization_decryptor.go b/controllers/kustomization_decryptor.go
index 5e384505..2488d5bb 100644
--- a/controllers/kustomization_decryptor.go
+++ b/controllers/kustomization_decryptor.go
@@ -38,7 +38,7 @@ import (
 	"sigs.k8s.io/kustomize/api/resource"
 	"sigs.k8s.io/yaml"
 
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
 	intkeyservice "github.com/fluxcd/kustomize-controller/internal/sops/keyservice"
 )
 
diff --git a/controllers/kustomization_decryptor_test.go b/controllers/kustomization_decryptor_test.go
index 8e8645b3..ab2699a8 100644
--- a/controllers/kustomization_decryptor_test.go
+++ b/controllers/kustomization_decryptor_test.go
@@ -23,7 +23,7 @@ import (
 	"testing"
 	"time"
 
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
 	"github.com/fluxcd/pkg/apis/meta"
 	sourcev1 "github.com/fluxcd/source-controller/api/v1beta1"
 	. "github.com/onsi/gomega"
@@ -50,7 +50,7 @@ func TestKustomizationReconciler_Decryptor(t *testing.T) {
 	g.Expect(err).ToNot(HaveOccurred())
 
 	repositoryName := types.NamespacedName{
-		Name:      fmt.Sprintf("%s", randStringRunes(5)),
+		Name:      fmt.Sprintf("sops-%s", randStringRunes(5)),
 		Namespace: id,
 	}
 
@@ -81,7 +81,7 @@ func TestKustomizationReconciler_Decryptor(t *testing.T) {
 	g.Expect(k8sClient.Create(context.Background(), sopsSecret)).To(Succeed())
 
 	kustomizationKey := types.NamespacedName{
-		Name:      "sops-" + randStringRunes(5),
+		Name:      fmt.Sprintf("sops-%s", randStringRunes(5)),
 		Namespace: id,
 	}
 	kustomization := &kustomizev1.Kustomization{
@@ -90,7 +90,8 @@ func TestKustomizationReconciler_Decryptor(t *testing.T) {
 			Namespace: kustomizationKey.Namespace,
 		},
 		Spec: kustomizev1.KustomizationSpec{
-			Path: "./",
+			Interval: metav1.Duration{Duration: reconciliationInterval},
+			Path:     "./",
 			KubeConfig: &kustomizev1.KubeConfig{
 				SecretRef: meta.LocalObjectReference{
 					Name: "kubeconfig",
diff --git a/controllers/kustomization_dependson_test.go b/controllers/kustomization_dependson_test.go
new file mode 100644
index 00000000..3043b399
--- /dev/null
+++ b/controllers/kustomization_dependson_test.go
@@ -0,0 +1,148 @@
+/*
+Copyright 2021 The Flux authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package controllers
+
+import (
+	"context"
+	"fmt"
+	"testing"
+	"time"
+
+	"github.com/fluxcd/pkg/apis/meta"
+	"github.com/fluxcd/pkg/runtime/dependency"
+	"github.com/fluxcd/pkg/testserver"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1beta1"
+	. "github.com/onsi/gomega"
+	apimeta "k8s.io/apimachinery/pkg/api/meta"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
+)
+
+func TestKustomizationReconciler_DependsOn(t *testing.T) {
+	g := NewWithT(t)
+	id := "dep-" + randStringRunes(5)
+	revision := "v1.0.0"
+
+	err := createNamespace(id)
+	g.Expect(err).NotTo(HaveOccurred(), "failed to create test namespace")
+
+	err = createKubeConfigSecret(id)
+	g.Expect(err).NotTo(HaveOccurred(), "failed to create kubeconfig secret")
+
+	manifests := func(name string, data string) []testserver.File {
+		return []testserver.File{
+			{
+				Name: "config.yaml",
+				Body: fmt.Sprintf(`---
+apiVersion: v1
+kind: ConfigMap
+metadata:
+  name: %[1]s
+data:
+  key: "%[2]s"
+`, name, data),
+			},
+		}
+	}
+
+	artifact, err := testServer.ArtifactFromFiles(manifests(id, id))
+	g.Expect(err).NotTo(HaveOccurred())
+
+	url := fmt.Sprintf("%s/%s", testServer.URL(), artifact)
+
+	repositoryName := types.NamespacedName{
+		Name:      fmt.Sprintf("dep-%s", randStringRunes(5)),
+		Namespace: id,
+	}
+
+	kustomizationKey := types.NamespacedName{
+		Name:      fmt.Sprintf("dep-%s", randStringRunes(5)),
+		Namespace: id,
+	}
+	kustomization := &kustomizev1.Kustomization{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      kustomizationKey.Name,
+			Namespace: kustomizationKey.Namespace,
+		},
+		Spec: kustomizev1.KustomizationSpec{
+			Interval: metav1.Duration{Duration: reconciliationInterval},
+			Path:     "./",
+			KubeConfig: &kustomizev1.KubeConfig{
+				SecretRef: meta.LocalObjectReference{
+					Name: "kubeconfig",
+				},
+			},
+			SourceRef: kustomizev1.CrossNamespaceSourceReference{
+				Name:      repositoryName.Name,
+				Namespace: repositoryName.Namespace,
+				Kind:      sourcev1.GitRepositoryKind,
+			},
+			TargetNamespace: id,
+			Prune:           true,
+		},
+	}
+
+	g.Expect(k8sClient.Create(context.Background(), kustomization)).To(Succeed())
+
+	resultK := &kustomizev1.Kustomization{}
+
+	g.Eventually(func() bool {
+		_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+		return apimeta.FindStatusCondition(resultK.Status.Conditions, meta.ReadyCondition) != nil
+	}, timeout, time.Second).Should(BeTrue())
+
+	t.Run("fails due to source not found", func(t *testing.T) {
+		g.Eventually(func() bool {
+			_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+			ready := apimeta.FindStatusCondition(resultK.Status.Conditions, meta.ReadyCondition)
+			return ready.Reason == kustomizev1.ArtifactFailedReason
+		}, timeout, time.Second).Should(BeTrue())
+	})
+
+	t.Run("reconciles when source is found", func(t *testing.T) {
+		err = applyGitRepository(repositoryName, url, revision, "")
+		g.Expect(err).NotTo(HaveOccurred())
+
+		g.Eventually(func() bool {
+			_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+			ready := apimeta.FindStatusCondition(resultK.Status.Conditions, meta.ReadyCondition)
+			return ready.Reason == meta.ReconciliationSucceededReason
+		}, timeout, time.Second).Should(BeTrue())
+	})
+
+	t.Run("fails due to dependency not found", func(t *testing.T) {
+		g.Eventually(func() error {
+			_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+			resultK.Spec.DependsOn = []dependency.CrossNamespaceDependencyReference{
+				{
+					Namespace: id,
+					Name:      "root",
+				},
+			}
+			return k8sClient.Update(context.Background(), resultK)
+		}, timeout, time.Second).Should(BeNil())
+
+		g.Eventually(func() bool {
+			_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+			ready := apimeta.FindStatusCondition(resultK.Status.Conditions, meta.ReadyCondition)
+			return ready.Reason == meta.DependencyNotReadyReason
+		}, timeout, time.Second).Should(BeTrue())
+	})
+}
diff --git a/controllers/kustomization_force_test.go b/controllers/kustomization_force_test.go
index 70c784a6..10577602 100644
--- a/controllers/kustomization_force_test.go
+++ b/controllers/kustomization_force_test.go
@@ -25,7 +25,7 @@ import (
 	"testing"
 	"time"
 
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
 	"github.com/fluxcd/pkg/apis/meta"
 	sourcev1 "github.com/fluxcd/source-controller/api/v1beta1"
 	. "github.com/onsi/gomega"
@@ -36,7 +36,7 @@ import (
 
 func TestKustomizationReconciler_Force(t *testing.T) {
 	g := NewWithT(t)
-	id := "sops-" + randStringRunes(5)
+	id := "force-" + randStringRunes(5)
 	revision := "v1.0.0"
 
 	err := createNamespace(id)
@@ -68,7 +68,7 @@ stringData:
 	url := fmt.Sprintf("%s/%s", testServer.URL(), artifact)
 
 	repositoryName := types.NamespacedName{
-		Name:      fmt.Sprintf("%s", randStringRunes(5)),
+		Name:      fmt.Sprintf("force-%s", randStringRunes(5)),
 		Namespace: id,
 	}
 
@@ -76,7 +76,7 @@ stringData:
 	g.Expect(err).NotTo(HaveOccurred())
 
 	kustomizationKey := types.NamespacedName{
-		Name:      "sops-" + randStringRunes(5),
+		Name:      fmt.Sprintf("force-%s", randStringRunes(5)),
 		Namespace: id,
 	}
 	kustomization := &kustomizev1.Kustomization{
@@ -85,7 +85,8 @@ stringData:
 			Namespace: kustomizationKey.Namespace,
 		},
 		Spec: kustomizev1.KustomizationSpec{
-			Path: "./",
+			Interval: metav1.Duration{Duration: reconciliationInterval},
+			Path:     "./",
 			KubeConfig: &kustomizev1.KubeConfig{
 				SecretRef: meta.LocalObjectReference{
 					Name: "kubeconfig",
@@ -137,6 +138,13 @@ stringData:
 		}, timeout, time.Second).Should(BeTrue())
 
 		g.Expect(apimeta.IsStatusConditionTrue(resultK.Status.Conditions, meta.ReadyCondition)).To(BeFalse())
+
+		t.Run("emits validation error event", func(t *testing.T) {
+			events := getEvents(resultK.GetName(), map[string]string{"kustomize.toolkit.fluxcd.io/revision": revision})
+			g.Expect(len(events) > 0).To(BeTrue())
+			g.Expect(events[0].Type).To(BeIdenticalTo("Warning"))
+			g.Expect(events[0].Message).To(ContainSubstring("invalid, error: secret is immutable"))
+		})
 	})
 
 	t.Run("recreates immutable secret", func(t *testing.T) {
@@ -153,8 +161,6 @@ stringData:
 			return k8sClient.Update(context.Background(), resultK)
 		}, timeout, time.Second).Should(BeNil())
 
-		g.Expect(k8sClient.Update(context.Background(), resultK)).To(Succeed())
-
 		g.Eventually(func() bool {
 			_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
 			return resultK.Status.LastAppliedRevision == revision
diff --git a/controllers/kustomization_gc.go b/controllers/kustomization_gc.go
deleted file mode 100644
index d6781aee..00000000
--- a/controllers/kustomization_gc.go
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
-Copyright 2020 The Flux authors
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package controllers
-
-import (
-	"context"
-	"fmt"
-	"time"
-
-	"github.com/go-logr/logr"
-	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-	"sigs.k8s.io/controller-runtime/pkg/client"
-
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
-)
-
-type KustomizeGarbageCollector struct {
-	snapshot    kustomizev1.Snapshot
-	newChecksum string
-	log         logr.Logger
-	client.Client
-}
-
-func NewGarbageCollector(kubeClient client.Client, snapshot kustomizev1.Snapshot, newChecksum string, log logr.Logger) *KustomizeGarbageCollector {
-	return &KustomizeGarbageCollector{
-		Client:      kubeClient,
-		snapshot:    snapshot,
-		newChecksum: newChecksum,
-		log:         log,
-	}
-}
-
-// Prune deletes Kubernetes objects removed from source.
-// Namespaced objects are removed before global ones, as in CRs before CRDs.
-// The garbage collector determines what objects to prune based on
-// a label selector that contains the previously applied revision.
-// The garbage collector ignores objects that are no longer present
-// on the cluster or if they are marked for deleting using Kubernetes finalizers.
-func (kgc *KustomizeGarbageCollector) Prune(timeout time.Duration, name string, namespace string) (string, bool) {
-	changeSet := ""
-	outErr := ""
-
-	ctx, cancel := context.WithTimeout(context.Background(), timeout+time.Second)
-	defer cancel()
-
-	for ns, gvks := range kgc.snapshot.NamespacedKinds() {
-		for _, gvk := range gvks {
-			ulist := &unstructured.UnstructuredList{}
-			ulist.SetGroupVersionKind(schema.GroupVersionKind{
-				Group:   gvk.Group,
-				Kind:    gvk.Kind + "List",
-				Version: gvk.Version,
-			})
-
-			err := kgc.List(ctx, ulist, client.InNamespace(ns), kgc.matchingLabels(name, namespace))
-			if err == nil {
-				for _, item := range ulist.Items {
-					id := fmt.Sprintf("%s/%s/%s", item.GetKind(), item.GetNamespace(), item.GetName())
-
-					if kgc.shouldSkip(item) {
-						kgc.log.V(1).Info(fmt.Sprintf("gc is disabled for '%s'", id))
-						continue
-					}
-
-					if kgc.hasBlockOwnerDeletion(item) {
-						kgc.log.V(1).Info(fmt.Sprintf("gc is disabled for '%s' due to 'ownerReference.blockOwnerDeletion=true'", id))
-						continue
-					}
-
-					if kgc.isStale(item) && item.GetDeletionTimestamp().IsZero() {
-						err = kgc.Delete(ctx, &item)
-						if err != nil {
-							outErr += fmt.Sprintf("delete failed for %s: %v\n", id, err)
-						} else {
-							if len(item.GetFinalizers()) > 0 {
-								changeSet += fmt.Sprintf("%s marked for deletion\n", id)
-							} else {
-								changeSet += fmt.Sprintf("%s deleted\n", id)
-							}
-						}
-					}
-				}
-			} else {
-				kgc.log.V(1).Info(fmt.Sprintf("gc query failed for %s: %v", gvk.Kind, err))
-			}
-		}
-	}
-
-	for _, gvk := range kgc.snapshot.NonNamespacedKinds() {
-		ulist := &unstructured.UnstructuredList{}
-		ulist.SetGroupVersionKind(schema.GroupVersionKind{
-			Group:   gvk.Group,
-			Kind:    gvk.Kind + "List",
-			Version: gvk.Version,
-		})
-
-		err := kgc.List(ctx, ulist, kgc.matchingLabels(name, namespace))
-		if err == nil {
-			for _, item := range ulist.Items {
-				id := fmt.Sprintf("%s/%s", item.GetKind(), item.GetName())
-
-				if kgc.shouldSkip(item) {
-					kgc.log.V(1).Info(fmt.Sprintf("gc is disabled for '%s'", id))
-					continue
-				}
-
-				if kgc.hasBlockOwnerDeletion(item) {
-					kgc.log.V(1).Info(fmt.Sprintf("gc is disabled for '%s' due to 'ownerReference.blockOwnerDeletion=true'", id))
-					continue
-				}
-
-				if kgc.isStale(item) && item.GetDeletionTimestamp().IsZero() {
-					err = kgc.Delete(ctx, &item)
-					if err != nil {
-						outErr += fmt.Sprintf("delete failed for %s: %v\n", id, err)
-					} else {
-						if len(item.GetFinalizers()) > 0 {
-							changeSet += fmt.Sprintf("%s/%s marked for deletion\n", item.GetKind(), item.GetName())
-						} else {
-							changeSet += fmt.Sprintf("%s/%s deleted\n", item.GetKind(), item.GetName())
-						}
-					}
-				}
-			}
-		} else {
-			kgc.log.V(1).Info(fmt.Sprintf("gc query failed for %s: %v", gvk.Kind, err))
-		}
-	}
-
-	if outErr != "" {
-		return outErr, false
-	}
-	return changeSet, true
-}
-
-// Determine staleness by checking if the annotation matches the latest checksum
-func (kgc *KustomizeGarbageCollector) isStale(obj unstructured.Unstructured) bool {
-	itemAnnotationChecksum := obj.GetAnnotations()[fmt.Sprintf("%s/checksum", kustomizev1.GroupVersion.Group)]
-
-	switch kgc.newChecksum {
-	// when the Kustomization is deleted the new checksum is set to string empty making all objects stale
-	case "":
-		return true
-	// skip GC if the new checksum matches the object checksum
-	case itemAnnotationChecksum:
-		return false
-	}
-
-	// skip GC if the checksum annotation is missing from the object
-	return itemAnnotationChecksum != ""
-}
-
-func (kgc *KustomizeGarbageCollector) hasBlockOwnerDeletion(obj unstructured.Unstructured) bool {
-	for _, ownerReference := range obj.GetOwnerReferences() {
-		if bod := ownerReference.BlockOwnerDeletion; bod != nil && *bod == true {
-			return true
-		}
-	}
-	return false
-}
-
-func (kgc *KustomizeGarbageCollector) shouldSkip(obj unstructured.Unstructured) bool {
-	key := fmt.Sprintf("%s/prune", kustomizev1.GroupVersion.Group)
-
-	return obj.GetLabels()[key] == kustomizev1.DisabledValue || obj.GetAnnotations()[key] == kustomizev1.DisabledValue
-}
-
-func (kgc *KustomizeGarbageCollector) matchingLabels(name, namespace string) client.MatchingLabels {
-	return selectorLabels(name, namespace)
-}
-
-func gcLabels(name, namespace, checksum string) map[string]string {
-	return map[string]string{
-		fmt.Sprintf("%s/name", kustomizev1.GroupVersion.Group):      name,
-		fmt.Sprintf("%s/namespace", kustomizev1.GroupVersion.Group): namespace,
-	}
-}
-func gcAnnotation(checksum string) map[string]string {
-	return map[string]string{
-		fmt.Sprintf("%s/checksum", kustomizev1.GroupVersion.Group): checksum,
-	}
-}
-
-func selectorLabels(name, namespace string) map[string]string {
-	return map[string]string{
-		fmt.Sprintf("%s/name", kustomizev1.GroupVersion.Group):      name,
-		fmt.Sprintf("%s/namespace", kustomizev1.GroupVersion.Group): namespace,
-	}
-
-}
diff --git a/controllers/kustomization_generator.go b/controllers/kustomization_generator.go
index 59880605..2507d844 100644
--- a/controllers/kustomization_generator.go
+++ b/controllers/kustomization_generator.go
@@ -17,8 +17,6 @@ limitations under the License.
 package controllers
 
 import (
-	"context"
-	"crypto/sha1"
 	"encoding/json"
 	"fmt"
 	"io/ioutil"
@@ -27,7 +25,6 @@ import (
 	"strings"
 	"sync"
 
-	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/kustomize/api/filesys"
 	"sigs.k8s.io/kustomize/api/konfig"
 	"sigs.k8s.io/kustomize/api/krusty"
@@ -36,45 +33,30 @@ import (
 	kustypes "sigs.k8s.io/kustomize/api/types"
 	"sigs.k8s.io/yaml"
 
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
 	"github.com/fluxcd/pkg/apis/kustomize"
 )
 
-const (
-	transformerFileName           = "kustomization-gc-labels.yaml"
-	transformerAnnotationFileName = "kustomization-gc-annotations.yaml"
-)
-
 type KustomizeGenerator struct {
 	kustomization kustomizev1.Kustomization
-	client.Client
 }
 
-func NewGenerator(kustomization kustomizev1.Kustomization, kubeClient client.Client) *KustomizeGenerator {
+func NewGenerator(kustomization kustomizev1.Kustomization) *KustomizeGenerator {
 	return &KustomizeGenerator{
 		kustomization: kustomization,
-		Client:        kubeClient,
 	}
 }
 
-func (kg *KustomizeGenerator) WriteFile(ctx context.Context, dirPath string) (string, error) {
-	kfile := filepath.Join(dirPath, konfig.DefaultKustomizationFileName())
-
-	checksum, err := kg.checksum(ctx, dirPath)
-	if err != nil {
-		return "", err
+func (kg *KustomizeGenerator) WriteFile(dirPath string) error {
+	if err := kg.generateKustomization(dirPath); err != nil {
+		return err
 	}
 
-	if err := kg.generateLabelTransformer(checksum, dirPath); err != nil {
-		return "", err
-	}
-	if err = kg.generateAnnotationTransformer(checksum, dirPath); err != nil {
-		return "", err
-	}
+	kfile := filepath.Join(dirPath, konfig.DefaultKustomizationFileName())
 
 	data, err := ioutil.ReadFile(kfile)
 	if err != nil {
-		return "", err
+		return err
 	}
 
 	kus := kustypes.Kustomization{
@@ -85,20 +67,7 @@ func (kg *KustomizeGenerator) WriteFile(ctx context.Context, dirPath string) (st
 	}
 
 	if err := yaml.Unmarshal(data, &kus); err != nil {
-		return "", err
-	}
-
-	if len(kus.Transformers) == 0 {
-		kus.Transformers = []string{transformerFileName, transformerAnnotationFileName}
-	} else {
-		if !find(kus.Transformers, transformerFileName) {
-			kus.Transformers = append(kus.Transformers, transformerFileName)
-		}
-
-		if !find(kus.Transformers, transformerAnnotationFileName) {
-			kus.Transformers = append(kus.Transformers, transformerAnnotationFileName)
-		}
-
+		return err
 	}
 
 	if kg.kustomization.Spec.TargetNamespace != "" {
@@ -119,7 +88,7 @@ func (kg *KustomizeGenerator) WriteFile(ctx context.Context, dirPath string) (st
 	for _, m := range kg.kustomization.Spec.PatchesJSON6902 {
 		patch, err := json.Marshal(m.Patch)
 		if err != nil {
-			return "", err
+			return err
 		}
 		kus.PatchesJson6902 = append(kus.PatchesJson6902, kustypes.Patch{
 			Patch:  string(patch),
@@ -142,10 +111,10 @@ func (kg *KustomizeGenerator) WriteFile(ctx context.Context, dirPath string) (st
 
 	kd, err := yaml.Marshal(kus)
 	if err != nil {
-		return "", err
+		return err
 	}
 
-	return checksum, ioutil.WriteFile(kfile, kd, os.ModePerm)
+	return ioutil.WriteFile(kfile, kd, os.ModePerm)
 }
 
 func checkKustomizeImageExists(images []kustypes.Image, imageName string) (bool, int) {
@@ -193,7 +162,7 @@ func (kg *KustomizeGenerator) generateKustomization(dirPath string) error {
 			}
 
 			extension := filepath.Ext(path)
-			if !containsString([]string{".yaml", ".yml"}, extension) {
+			if extension != ".yaml" && extension != ".yml" {
 				return nil
 			}
 
@@ -249,124 +218,6 @@ func (kg *KustomizeGenerator) generateKustomization(dirPath string) error {
 	return ioutil.WriteFile(kfile, kd, os.ModePerm)
 }
 
-func (kg *KustomizeGenerator) checksum(ctx context.Context, dirPath string) (string, error) {
-	if err := kg.generateKustomization(dirPath); err != nil {
-		return "", fmt.Errorf("kustomize create failed: %w", err)
-	}
-
-	fs := filesys.MakeFsOnDisk()
-	m, err := buildKustomization(fs, dirPath)
-	if err != nil {
-		return "", fmt.Errorf("kustomize build failed: %w", err)
-	}
-
-	// run variable substitutions
-	if kg.kustomization.Spec.PostBuild != nil {
-		for _, res := range m.Resources() {
-			outRes, err := substituteVariables(ctx, kg.Client, kg.kustomization, res)
-			if err != nil {
-				return "", fmt.Errorf("var substitution failed for '%s': %w", res.GetName(), err)
-			}
-
-			if outRes != nil {
-				_, err = m.Replace(res)
-				if err != nil {
-					return "", err
-				}
-			}
-		}
-	}
-
-	resources, err := m.AsYaml()
-	if err != nil {
-		return "", fmt.Errorf("kustomize build failed: %w", err)
-	}
-
-	return fmt.Sprintf("%x", sha1.Sum(resources)), nil
-}
-
-func (kg *KustomizeGenerator) generateAnnotationTransformer(checksum, dirPath string) error {
-	var annotations map[string]string
-	// add checksum annotations only if GC is enabled
-	if kg.kustomization.Spec.Prune {
-		annotations = gcAnnotation(checksum)
-	}
-
-	var lt = struct {
-		ApiVersion string `json:"apiVersion" yaml:"apiVersion"`
-		Kind       string `json:"kind" yaml:"kind"`
-		Metadata   struct {
-			Name string `json:"name" yaml:"name"`
-		} `json:"metadata" yaml:"metadata"`
-		Annotations map[string]string    `json:"annotations,omitempty" yaml:"annotations,omitempty"`
-		FieldSpecs  []kustypes.FieldSpec `json:"fieldSpecs,omitempty" yaml:"fieldSpecs,omitempty"`
-	}{
-		ApiVersion: "builtin",
-		Kind:       "AnnotationsTransformer",
-		Metadata: struct {
-			Name string `json:"name" yaml:"name"`
-		}{
-			Name: kg.kustomization.GetName(),
-		},
-		Annotations: annotations,
-		FieldSpecs: []kustypes.FieldSpec{
-			{Path: "metadata/annotations", CreateIfNotPresent: true},
-		},
-	}
-
-	data, err := yaml.Marshal(lt)
-	if err != nil {
-		return err
-	}
-
-	annotationsFile := filepath.Join(dirPath, transformerAnnotationFileName)
-	if err := ioutil.WriteFile(annotationsFile, data, os.ModePerm); err != nil {
-		return err
-	}
-
-	return nil
-}
-
-func (kg *KustomizeGenerator) generateLabelTransformer(checksum, dirPath string) error {
-	labels := selectorLabels(kg.kustomization.GetName(), kg.kustomization.GetNamespace())
-
-	labels = gcLabels(kg.kustomization.GetName(), kg.kustomization.GetNamespace(), checksum)
-
-	var lt = struct {
-		ApiVersion string `json:"apiVersion" yaml:"apiVersion"`
-		Kind       string `json:"kind" yaml:"kind"`
-		Metadata   struct {
-			Name string `json:"name" yaml:"name"`
-		} `json:"metadata" yaml:"metadata"`
-		Labels     map[string]string    `json:"labels,omitempty" yaml:"labels,omitempty"`
-		FieldSpecs []kustypes.FieldSpec `json:"fieldSpecs,omitempty" yaml:"fieldSpecs,omitempty"`
-	}{
-		ApiVersion: "builtin",
-		Kind:       "LabelTransformer",
-		Metadata: struct {
-			Name string `json:"name" yaml:"name"`
-		}{
-			Name: kg.kustomization.GetName(),
-		},
-		Labels: labels,
-		FieldSpecs: []kustypes.FieldSpec{
-			{Path: "metadata/labels", CreateIfNotPresent: true},
-		},
-	}
-
-	data, err := yaml.Marshal(lt)
-	if err != nil {
-		return err
-	}
-
-	labelsFile := filepath.Join(dirPath, transformerFileName)
-	if err := ioutil.WriteFile(labelsFile, data, os.ModePerm); err != nil {
-		return err
-	}
-
-	return nil
-}
-
 func adaptSelector(selector *kustomize.Selector) (output *kustypes.Selector) {
 	if selector != nil {
 		output = &kustypes.Selector{}
@@ -385,7 +236,6 @@ func adaptSelector(selector *kustomize.Selector) (output *kustypes.Selector) {
 var kustomizeBuildMutex sync.Mutex
 
 // buildKustomization wraps krusty.MakeKustomizer with the following settings:
-// - reorder the resources just before output (Namespaces and Cluster roles/role bindings first, CRDs before CRs, Webhooks last)
 // - load files from outside the kustomization.yaml root
 // - disable plugins except for the builtin ones
 func buildKustomization(fs filesys.FileSystem, dirPath string) (resmap.ResMap, error) {
@@ -395,23 +245,10 @@ func buildKustomization(fs filesys.FileSystem, dirPath string) (resmap.ResMap, e
 	defer kustomizeBuildMutex.Unlock()
 
 	buildOptions := &krusty.Options{
-		DoLegacyResourceSort: true,
-		LoadRestrictions:     kustypes.LoadRestrictionsNone,
-		AddManagedbyLabel:    false,
-		DoPrune:              false,
-		PluginConfig:         kustypes.DisabledPluginConfig(),
+		LoadRestrictions: kustypes.LoadRestrictionsNone,
+		PluginConfig:     kustypes.DisabledPluginConfig(),
 	}
 
 	k := krusty.MakeKustomizer(buildOptions)
 	return k.Run(fs, dirPath)
 }
-
-func find(source []string, value string) bool {
-	for _, item := range source {
-		if item == value {
-			return true
-		}
-	}
-
-	return false
-}
diff --git a/controllers/kustomization_healthcheck.go b/controllers/kustomization_healthcheck.go
deleted file mode 100644
index e69a320f..00000000
--- a/controllers/kustomization_healthcheck.go
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
-Copyright 2020 The Flux authors
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package controllers
-
-import (
-	"context"
-	"fmt"
-	"strings"
-	"time"
-
-	"github.com/fluxcd/pkg/apis/meta"
-	"k8s.io/apimachinery/pkg/runtime/schema"
-	"sigs.k8s.io/cli-utils/pkg/kstatus/polling"
-	"sigs.k8s.io/cli-utils/pkg/kstatus/polling/aggregator"
-	"sigs.k8s.io/cli-utils/pkg/kstatus/polling/collector"
-	"sigs.k8s.io/cli-utils/pkg/kstatus/polling/event"
-	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
-	"sigs.k8s.io/cli-utils/pkg/object"
-
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
-)
-
-type KustomizeHealthCheck struct {
-	kustomization kustomizev1.Kustomization
-	statusPoller  *polling.StatusPoller
-}
-
-func NewHealthCheck(kustomization kustomizev1.Kustomization, statusPoller *polling.StatusPoller) *KustomizeHealthCheck {
-	return &KustomizeHealthCheck{
-		kustomization: kustomization,
-		statusPoller:  statusPoller,
-	}
-}
-
-func (hc *KustomizeHealthCheck) Assess(pollInterval time.Duration) error {
-	objMetadata, err := hc.toObjMetadata(hc.kustomization.Spec.HealthChecks)
-	if err != nil {
-		return err
-	}
-
-	timeout := hc.kustomization.GetTimeout() + (time.Second * 1)
-	ctx, cancel := context.WithTimeout(context.Background(), timeout)
-	defer cancel()
-
-	opts := polling.Options{PollInterval: pollInterval, UseCache: true}
-	eventsChan := hc.statusPoller.Poll(ctx, objMetadata, opts)
-	coll := collector.NewResourceStatusCollector(objMetadata)
-	lastStatus := make(map[object.ObjMetadata]*event.ResourceStatus)
-	done := coll.ListenWithObserver(eventsChan, collector.ObserverFunc(
-		func(statusCollector *collector.ResourceStatusCollector, e event.Event) {
-			var rss []*event.ResourceStatus
-			for _, rs := range statusCollector.ResourceStatuses {
-				if rs == nil {
-					continue
-				}
-				// skip DeadlineExceeded errors because kstatus emits that error
-				// for every resource it's monitoring even when only one of them
-				// actually fails.
-				if rs.Error != context.DeadlineExceeded {
-					lastStatus[rs.Identifier] = rs
-				}
-				rss = append(rss, rs)
-			}
-			desired := status.CurrentStatus
-			aggStatus := aggregator.AggregateStatus(rss, desired)
-			if aggStatus == desired {
-				cancel()
-				return
-			}
-		}),
-	)
-
-	<-done
-
-	if coll.Error != nil {
-		return coll.Error
-	}
-
-	if ctx.Err() == context.DeadlineExceeded {
-		errors := []string{}
-		for id, rs := range coll.ResourceStatuses {
-			if rs == nil {
-				errors = append(errors, fmt.Sprintf("no status for %s available", id))
-				continue
-			}
-			if lastStatus[id] == nil {
-				// this is only nil in the rare case where no status can be determined for the resource at all
-				errors = append(errors, fmt.Sprintf("%s (unknown status)", hc.objMetadataToString(rs.Identifier)))
-			} else if lastStatus[id].Status != status.CurrentStatus {
-				idString := hc.objMetadataToString(rs.Identifier)
-				var bld strings.Builder
-				bld.WriteString(fmt.Sprintf("%s (status '%s')", idString, lastStatus[id].Status))
-				if rs.Error != nil {
-					bld.WriteString(fmt.Sprintf(": %s", rs.Error))
-				}
-				errors = append(errors, bld.String())
-			}
-		}
-		return fmt.Errorf("Health check failed for [%s]", strings.Join(errors, ", "))
-	}
-
-	return nil
-}
-
-func (hc *KustomizeHealthCheck) toObjMetadata(cr []meta.NamespacedObjectKindReference) ([]object.ObjMetadata, error) {
-	oo := []object.ObjMetadata{}
-	for _, c := range cr {
-		// For backwards compatibility
-		if c.APIVersion == "" {
-			c.APIVersion = "apps/v1"
-		}
-
-		gv, err := schema.ParseGroupVersion(c.APIVersion)
-		if err != nil {
-			return []object.ObjMetadata{}, err
-		}
-
-		gk := schema.GroupKind{Group: gv.Group, Kind: c.Kind}
-		o, err := object.CreateObjMetadata(c.Namespace, c.Name, gk)
-		if err != nil {
-			return []object.ObjMetadata{}, err
-		}
-
-		oo = append(oo, o)
-	}
-	return oo, nil
-}
-
-func (hc *KustomizeHealthCheck) objMetadataToString(om object.ObjMetadata) string {
-	return fmt.Sprintf("%s '%s/%s'", om.GroupKind.Kind, om.Namespace, om.Name)
-}
diff --git a/controllers/kustomization_impersonation.go b/controllers/kustomization_impersonation.go
index bc067a9e..59b940bf 100644
--- a/controllers/kustomization_impersonation.go
+++ b/controllers/kustomization_impersonation.go
@@ -19,7 +19,6 @@ package controllers
 import (
 	"context"
 	"fmt"
-	"io/ioutil"
 	"strings"
 
 	corev1 "k8s.io/api/core/v1"
@@ -30,7 +29,7 @@ import (
 	"sigs.k8s.io/controller-runtime/pkg/client/apiutil"
 	"sigs.k8s.io/controller-runtime/pkg/client/config"
 
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
 )
 
 type KustomizeImpersonation struct {
@@ -162,28 +161,6 @@ func (ki *KustomizeImpersonation) clientForKubeConfig(ctx context.Context) (clie
 	return client, statusPoller, err
 }
 
-func (ki *KustomizeImpersonation) WriteKubeConfig(ctx context.Context) (string, error) {
-	secretName := types.NamespacedName{
-		Namespace: ki.kustomization.GetNamespace(),
-		Name:      ki.kustomization.Spec.KubeConfig.SecretRef.Name,
-	}
-
-	kubeConfig, err := ki.getKubeConfig(ctx)
-	if err != nil {
-		return "", err
-	}
-
-	f, err := ioutil.TempFile(ki.workdir, "kubeconfig")
-	defer f.Close()
-	if err != nil {
-		return "", fmt.Errorf("unable to write KubeConfig secret '%s' to storage: %w", secretName.String(), err)
-	}
-	if _, err := f.Write(kubeConfig); err != nil {
-		return "", fmt.Errorf("unable to write KubeConfig secret '%s' to storage: %w", secretName.String(), err)
-	}
-	return f.Name(), nil
-}
-
 func (ki *KustomizeImpersonation) getKubeConfig(ctx context.Context) ([]byte, error) {
 	secretName := types.NamespacedName{
 		Namespace: ki.kustomization.GetNamespace(),
diff --git a/controllers/kustomization_indexers.go b/controllers/kustomization_indexers.go
index f8d3c7c7..86e4e14c 100644
--- a/controllers/kustomization_indexers.go
+++ b/controllers/kustomization_indexers.go
@@ -23,7 +23,7 @@ import (
 	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/reconcile"
 
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
 	"github.com/fluxcd/pkg/runtime/dependency"
 	sourcev1 "github.com/fluxcd/source-controller/api/v1beta1"
 )
diff --git a/controllers/kustomization_inventory.go b/controllers/kustomization_inventory.go
new file mode 100644
index 00000000..52443d7b
--- /dev/null
+++ b/controllers/kustomization_inventory.go
@@ -0,0 +1,165 @@
+/*
+Copyright 2021 The Flux authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package controllers
+
+import (
+	"github.com/fluxcd/pkg/apis/meta"
+	"sort"
+
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"sigs.k8s.io/cli-utils/pkg/object"
+
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
+	"github.com/fluxcd/kustomize-controller/internal/objectutil"
+)
+
+func NewInventory() *kustomizev1.Inventory {
+	return &kustomizev1.Inventory{
+		Entries: []kustomizev1.Entry{},
+	}
+}
+
+// AddObjectsToInventory extracts the metadata from the given objects and adds it to the inventory.
+func AddObjectsToInventory(inv *kustomizev1.Inventory, objects []*unstructured.Unstructured) error {
+	sort.Sort(objectutil.SortableUnstructureds(objects))
+	for _, om := range objects {
+		objMetadata := object.UnstructuredToObjMeta(om)
+		gv, err := schema.ParseGroupVersion(om.GetAPIVersion())
+		if err != nil {
+			return err
+		}
+
+		inv.Entries = append(inv.Entries, kustomizev1.Entry{
+			ObjectID:      objMetadata.String(),
+			ObjectVersion: gv.Version,
+		})
+	}
+
+	return nil
+}
+
+// ListObjectsInInventory returns the inventory entries as unstructured.Unstructured objects.
+func ListObjectsInInventory(inv *kustomizev1.Inventory) ([]*unstructured.Unstructured, error) {
+	objects := make([]*unstructured.Unstructured, 0)
+
+	for _, entry := range inv.Entries {
+		objMetadata, err := object.ParseObjMetadata(entry.ObjectID)
+		if err != nil {
+			return nil, err
+		}
+
+		u := &unstructured.Unstructured{}
+		u.SetGroupVersionKind(schema.GroupVersionKind{
+			Group:   objMetadata.GroupKind.Group,
+			Kind:    objMetadata.GroupKind.Kind,
+			Version: entry.ObjectVersion,
+		})
+		u.SetName(objMetadata.Name)
+		u.SetNamespace(objMetadata.Namespace)
+		objects = append(objects, u)
+	}
+
+	sort.Sort(objectutil.SortableUnstructureds(objects))
+	return objects, nil
+}
+
+// ListMetaInInventory returns the inventory entries as object.ObjMetadata objects.
+func ListMetaInInventory(inv *kustomizev1.Inventory) ([]object.ObjMetadata, error) {
+	var metas []object.ObjMetadata
+	for _, e := range inv.Entries {
+		m, err := object.ParseObjMetadata(e.ObjectID)
+		if err != nil {
+			return metas, err
+		}
+		metas = append(metas, m)
+	}
+
+	return metas, nil
+}
+
+// DiffInventory returns the slice of objects that do not exist in the target inventory.
+func DiffInventory(inv *kustomizev1.Inventory, target *kustomizev1.Inventory) ([]*unstructured.Unstructured, error) {
+	versionOf := func(i *kustomizev1.Inventory, objMetadata object.ObjMetadata) string {
+		for _, entry := range i.Entries {
+			if entry.ObjectID == objMetadata.String() {
+				return entry.ObjectVersion
+			}
+		}
+		return ""
+	}
+
+	objects := make([]*unstructured.Unstructured, 0)
+	aList, err := ListMetaInInventory(inv)
+	if err != nil {
+		return nil, err
+	}
+
+	bList, err := ListMetaInInventory(target)
+	if err != nil {
+		return nil, err
+	}
+
+	list := object.SetDiff(aList, bList)
+	if len(list) == 0 {
+		return objects, nil
+	}
+
+	for _, metadata := range list {
+		u := &unstructured.Unstructured{}
+		u.SetGroupVersionKind(schema.GroupVersionKind{
+			Group:   metadata.GroupKind.Group,
+			Kind:    metadata.GroupKind.Kind,
+			Version: versionOf(inv, metadata),
+		})
+		u.SetName(metadata.Name)
+		u.SetNamespace(metadata.Namespace)
+		objects = append(objects, u)
+	}
+
+	sort.Sort(objectutil.SortableUnstructureds(objects))
+	return objects, nil
+}
+
+func referenceToUnstructured(cr []meta.NamespacedObjectKindReference) ([]*unstructured.Unstructured, error) {
+	var objects []*unstructured.Unstructured
+
+	for _, c := range cr {
+		// For backwards compatibility with Kustomization v1beta1
+		if c.APIVersion == "" {
+			c.APIVersion = "apps/v1"
+		}
+
+		gv, err := schema.ParseGroupVersion(c.APIVersion)
+		if err != nil {
+			return objects, err
+		}
+
+		u := &unstructured.Unstructured{}
+		u.SetGroupVersionKind(schema.GroupVersionKind{
+			Group:   gv.Group,
+			Kind:    c.Kind,
+			Version: gv.Version,
+		})
+		u.SetName(c.Name)
+		u.SetNamespace(c.Namespace)
+		objects = append(objects, u)
+
+	}
+
+	return objects, nil
+}
diff --git a/controllers/kustomization_gc_test.go b/controllers/kustomization_prune_test.go
similarity index 67%
rename from controllers/kustomization_gc_test.go
rename to controllers/kustomization_prune_test.go
index 7f4dd395..36e0882e 100644
--- a/controllers/kustomization_gc_test.go
+++ b/controllers/kustomization_prune_test.go
@@ -22,7 +22,7 @@ import (
 	"testing"
 	"time"
 
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
 	"github.com/fluxcd/pkg/apis/meta"
 	"github.com/fluxcd/pkg/testserver"
 	sourcev1 "github.com/fluxcd/source-controller/api/v1beta1"
@@ -80,7 +80,7 @@ data:
 	url := fmt.Sprintf("%s/%s", testServer.URL(), artifact)
 
 	repositoryName := types.NamespacedName{
-		Name:      fmt.Sprintf("%s", randStringRunes(5)),
+		Name:      fmt.Sprintf("gc-%s", randStringRunes(5)),
 		Namespace: id,
 	}
 
@@ -88,7 +88,7 @@ data:
 	g.Expect(err).NotTo(HaveOccurred())
 
 	kustomizationKey := types.NamespacedName{
-		Name:      "sops-" + randStringRunes(5),
+		Name:      fmt.Sprintf("gc-%s", randStringRunes(5)),
 		Namespace: id,
 	}
 	kustomization := &kustomizev1.Kustomization{
@@ -97,7 +97,8 @@ data:
 			Namespace: kustomizationKey.Namespace,
 		},
 		Spec: kustomizev1.KustomizationSpec{
-			Path: "./",
+			Interval: metav1.Duration{Duration: reconciliationInterval},
+			Path:     "./",
 			KubeConfig: &kustomizev1.KubeConfig{
 				SecretRef: meta.LocalObjectReference{
 					Name: "kubeconfig",
@@ -117,17 +118,19 @@ data:
 
 	resultK := &kustomizev1.Kustomization{}
 	resultSecret := &corev1.Secret{}
+	resultConfig := &corev1.ConfigMap{}
 
 	g.Eventually(func() bool {
 		_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
 		return resultK.Status.LastAppliedRevision == revision
 	}, timeout, time.Second).Should(BeTrue())
 
-	t.Run("creates secret", func(t *testing.T) {
+	t.Run("creates objects", func(t *testing.T) {
 		g.Expect(k8sClient.Get(context.Background(), types.NamespacedName{Name: id, Namespace: id}, resultSecret)).Should(Succeed())
+		g.Expect(k8sClient.Get(context.Background(), types.NamespacedName{Name: id, Namespace: id}, resultConfig)).Should(Succeed())
 	})
 
-	t.Run("deletes stale secret", func(t *testing.T) {
+	t.Run("deletes stale objects", func(t *testing.T) {
 		newID := randStringRunes(5)
 		artifact, err := testServer.ArtifactFromFiles(manifests(newID, newID))
 		g.Expect(err).NotTo(HaveOccurred())
@@ -146,80 +149,20 @@ data:
 		old := &corev1.Secret{}
 		err = k8sClient.Get(context.Background(), types.NamespacedName{Name: id, Namespace: id}, old)
 		g.Expect(apierrors.IsNotFound(err)).To(BeTrue())
-
 	})
 
-	t.Run("handles blockOwnerDeletion", func(t *testing.T) {
-		owner := &corev1.ServiceAccount{
-			ObjectMeta: metav1.ObjectMeta{
-				Name:      "test",
-				Namespace: id,
-			},
-		}
-		g.Expect(k8sClient.Create(context.Background(), owner)).To(Succeed())
-
-		sa := &corev1.ServiceAccount{}
-		g.Expect(k8sClient.Get(context.Background(), client.ObjectKeyFromObject(owner), sa)).To(Succeed())
-
-		blockOwnerDeletion := true
-		owned := &corev1.ConfigMap{
-			TypeMeta: metav1.TypeMeta{},
-			ObjectMeta: metav1.ObjectMeta{
-				Name:        "test1",
-				Namespace:   id,
-				Labels:      resultSecret.GetLabels(),
-				Annotations: resultSecret.GetAnnotations(),
-				OwnerReferences: []metav1.OwnerReference{
-					{
-						APIVersion:         "v1",
-						Kind:               "ServiceAccount",
-						Name:               sa.Name,
-						UID:                sa.UID,
-						Controller:         &blockOwnerDeletion,
-						BlockOwnerDeletion: &blockOwnerDeletion,
-					},
-				},
-			},
-		}
-		g.Expect(k8sClient.Create(context.Background(), owned)).To(Succeed())
-
-		blockOwnerDeletion = false
-		notOwned := &corev1.ConfigMap{
-			TypeMeta: metav1.TypeMeta{},
-			ObjectMeta: metav1.ObjectMeta{
-				Name:        "test2",
-				Namespace:   id,
-				Labels:      resultSecret.GetLabels(),
-				Annotations: resultSecret.GetAnnotations(),
-				OwnerReferences: []metav1.OwnerReference{
-					{
-						APIVersion:         "v1",
-						Kind:               "ServiceAccount",
-						Name:               sa.Name,
-						UID:                sa.UID,
-						Controller:         &blockOwnerDeletion,
-						BlockOwnerDeletion: &blockOwnerDeletion,
-					},
-				},
-			},
-		}
-		g.Expect(k8sClient.Create(context.Background(), notOwned)).To(Succeed())
-
+	t.Run("handles finalizer", func(t *testing.T) {
 		g.Expect(k8sClient.Delete(context.Background(), kustomization)).To(Succeed())
 		g.Eventually(func() bool {
-			err = k8sClient.Get(context.Background(), client.ObjectKey{Name: kustomization.Name, Namespace: id}, kustomization)
+			err = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), kustomization)
 			return apierrors.IsNotFound(err)
 		}, timeout, time.Second).Should(BeTrue())
 
-		cf := &corev1.ConfigMap{}
-		g.Expect(k8sClient.Get(context.Background(), client.ObjectKeyFromObject(owned), cf)).To(Succeed())
-
-		err = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(notOwned), cf)
+		err = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(resultSecret), resultSecret)
 		g.Expect(apierrors.IsNotFound(err)).To(BeTrue())
 	})
 
 	t.Run("preserves objects with pruning disabled", func(t *testing.T) {
-		cf := &corev1.ConfigMap{}
-		g.Expect(k8sClient.Get(context.Background(), types.NamespacedName{Name: id, Namespace: id}, cf)).Should(Succeed())
+		g.Expect(k8sClient.Get(context.Background(), client.ObjectKeyFromObject(resultConfig), resultConfig)).Should(Succeed())
 	})
 }
diff --git a/controllers/kustomization_transformers_test.go b/controllers/kustomization_transformer_test.go
similarity index 97%
rename from controllers/kustomization_transformers_test.go
rename to controllers/kustomization_transformer_test.go
index ebb0609c..d0b8dfb3 100644
--- a/controllers/kustomization_transformers_test.go
+++ b/controllers/kustomization_transformer_test.go
@@ -25,7 +25,7 @@ import (
 	"testing"
 	"time"
 
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
 	"github.com/fluxcd/pkg/apis/meta"
 	sourcev1 "github.com/fluxcd/source-controller/api/v1beta1"
 	. "github.com/onsi/gomega"
@@ -74,7 +74,8 @@ func TestKustomizationReconciler_KustomizeTransformer(t *testing.T) {
 			Namespace: kustomizationKey.Namespace,
 		},
 		Spec: kustomizev1.KustomizationSpec{
-			Path: "./",
+			Interval: metav1.Duration{Duration: reconciliationInterval},
+			Path:     "./",
 			KubeConfig: &kustomizev1.KubeConfig{
 				SecretRef: meta.LocalObjectReference{
 					Name: "kubeconfig",
@@ -198,7 +199,8 @@ func TestKustomizationReconciler_KustomizeTransformerFiles(t *testing.T) {
 			Namespace: kustomizationKey.Namespace,
 		},
 		Spec: kustomizev1.KustomizationSpec{
-			Path: "./",
+			Interval: metav1.Duration{Duration: reconciliationInterval},
+			Path:     "./",
 			KubeConfig: &kustomizev1.KubeConfig{
 				SecretRef: meta.LocalObjectReference{
 					Name: "kubeconfig",
@@ -318,7 +320,8 @@ func TestKustomizationReconciler_FluxTransformers(t *testing.T) {
 			Namespace: kustomizationKey.Namespace,
 		},
 		Spec: kustomizev1.KustomizationSpec{
-			Path: "./",
+			Interval: metav1.Duration{Duration: reconciliationInterval},
+			Path:     "./",
 			KubeConfig: &kustomizev1.KubeConfig{
 				SecretRef: meta.LocalObjectReference{
 					Name: "kubeconfig",
diff --git a/controllers/kustomization_varsub.go b/controllers/kustomization_varsub.go
index 67b3e840..4fbd07cb 100644
--- a/controllers/kustomization_varsub.go
+++ b/controllers/kustomization_varsub.go
@@ -13,7 +13,7 @@ import (
 	"sigs.k8s.io/kustomize/api/resource"
 	"sigs.k8s.io/yaml"
 
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
 )
 
 // varsubRegex is the regular expression used to validate
diff --git a/controllers/kustomization_vars_test.go b/controllers/kustomization_varsub_test.go
similarity index 96%
rename from controllers/kustomization_vars_test.go
rename to controllers/kustomization_varsub_test.go
index 83043aad..d3577538 100644
--- a/controllers/kustomization_vars_test.go
+++ b/controllers/kustomization_varsub_test.go
@@ -21,7 +21,7 @@ import (
 	"fmt"
 	"testing"
 
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
 	"github.com/fluxcd/pkg/apis/meta"
 	"github.com/fluxcd/pkg/testserver"
 	sourcev1 "github.com/fluxcd/source-controller/api/v1beta1"
@@ -33,7 +33,7 @@ import (
 	"sigs.k8s.io/controller-runtime/pkg/client"
 )
 
-func TestKustomizationReconciler_Vars(t *testing.T) {
+func TestKustomizationReconciler_Varsub(t *testing.T) {
 	g := NewWithT(t)
 	id := "vars-" + randStringRunes(5)
 	revision := "v1.0.0/" + randStringRunes(7)
@@ -120,10 +120,6 @@ metadata:
 				Kind: sourcev1.GitRepositoryKind,
 				Name: repositoryName.Name,
 			},
-			Suspend:    false,
-			Timeout:    nil,
-			Validation: "client",
-			Force:      false,
 			PostBuild: &kustomizev1.PostBuild{
 				Substitute: map[string]string{"_Region": "eu-central-1"},
 				SubstituteFrom: []kustomizev1.SubstituteReference{
diff --git a/controllers/kustomization_wait_test.go b/controllers/kustomization_wait_test.go
new file mode 100644
index 00000000..9e773d4d
--- /dev/null
+++ b/controllers/kustomization_wait_test.go
@@ -0,0 +1,164 @@
+/*
+Copyright 2021 The Flux authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package controllers
+
+import (
+	"context"
+	"fmt"
+	"testing"
+	"time"
+
+	"github.com/fluxcd/pkg/apis/meta"
+	"github.com/fluxcd/pkg/testserver"
+	sourcev1 "github.com/fluxcd/source-controller/api/v1beta1"
+	. "github.com/onsi/gomega"
+	apimeta "k8s.io/apimachinery/pkg/api/meta"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/types"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
+)
+
+func TestKustomizationReconciler_HealthCheck(t *testing.T) {
+	g := NewWithT(t)
+	id := "wait-" + randStringRunes(5)
+	revision := "v1.0.0"
+
+	err := createNamespace(id)
+	g.Expect(err).NotTo(HaveOccurred(), "failed to create test namespace")
+
+	err = createKubeConfigSecret(id)
+	g.Expect(err).NotTo(HaveOccurred(), "failed to create kubeconfig secret")
+
+	manifests := func(name string, data string) []testserver.File {
+		return []testserver.File{
+			{
+				Name: "config.yaml",
+				Body: fmt.Sprintf(`---
+apiVersion: v1
+kind: ConfigMap
+metadata:
+  name: %[1]s
+data:
+  key: "%[2]s"
+`, name, data),
+			},
+		}
+	}
+
+	artifact, err := testServer.ArtifactFromFiles(manifests(id, id))
+	g.Expect(err).NotTo(HaveOccurred())
+
+	url := fmt.Sprintf("%s/%s", testServer.URL(), artifact)
+
+	repositoryName := types.NamespacedName{
+		Name:      fmt.Sprintf("wait-%s", randStringRunes(5)),
+		Namespace: id,
+	}
+
+	err = applyGitRepository(repositoryName, url, revision, "")
+	g.Expect(err).NotTo(HaveOccurred())
+
+	kustomizationKey := types.NamespacedName{
+		Name:      fmt.Sprintf("wait-%s", randStringRunes(5)),
+		Namespace: id,
+	}
+	kustomization := &kustomizev1.Kustomization{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      kustomizationKey.Name,
+			Namespace: kustomizationKey.Namespace,
+		},
+		Spec: kustomizev1.KustomizationSpec{
+			Interval: metav1.Duration{Duration: 2 * time.Minute},
+			Path:     "./",
+			KubeConfig: &kustomizev1.KubeConfig{
+				SecretRef: meta.LocalObjectReference{
+					Name: "kubeconfig",
+				},
+			},
+			SourceRef: kustomizev1.CrossNamespaceSourceReference{
+				Name:      repositoryName.Name,
+				Namespace: repositoryName.Namespace,
+				Kind:      sourcev1.GitRepositoryKind,
+			},
+			TargetNamespace: id,
+			Prune:           true,
+			Timeout:         &metav1.Duration{Duration: time.Second},
+			HealthChecks: []meta.NamespacedObjectKindReference{
+				{
+					APIVersion: "v1",
+					Kind:       "ConfigMap",
+					Name:       id,
+					Namespace:  id,
+				},
+			},
+		},
+	}
+
+	g.Expect(k8sClient.Create(context.Background(), kustomization)).To(Succeed())
+
+	resultK := &kustomizev1.Kustomization{}
+
+	g.Eventually(func() bool {
+		_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+		return resultK.Status.LastAppliedRevision == revision
+	}, timeout, time.Second).Should(BeTrue())
+
+	t.Run("reports healthy status", func(t *testing.T) {
+		g.Eventually(func() bool {
+			_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+			ready := apimeta.IsStatusConditionTrue(resultK.Status.Conditions, meta.ReadyCondition)
+			healthy := apimeta.IsStatusConditionTrue(resultK.Status.Conditions, kustomizev1.HealthyCondition)
+			return ready && healthy
+		}, timeout, time.Second).Should(BeTrue())
+	})
+
+	t.Run("reports unhealthy status", func(t *testing.T) {
+		g.Eventually(func() error {
+			_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+			resultK.Spec.HealthChecks = []meta.NamespacedObjectKindReference{
+				{
+					APIVersion: "v1",
+					Kind:       "ConfigMap",
+					Name:       "does-not-exists",
+					Namespace:  id,
+				},
+			}
+			return k8sClient.Update(context.Background(), resultK)
+		}, timeout, time.Second).Should(BeNil())
+
+		g.Eventually(func() bool {
+			_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+			ready := apimeta.FindStatusCondition(resultK.Status.Conditions, meta.ReadyCondition)
+			return ready.Reason == meta.ProgressingReason
+		}, timeout, time.Second).Should(BeTrue())
+
+		g.Eventually(func() bool {
+			_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+			healthy := apimeta.FindStatusCondition(resultK.Status.Conditions, kustomizev1.HealthyCondition)
+			return healthy.Reason == kustomizev1.HealthCheckFailedReason
+		}, time.Minute, time.Second).Should(BeTrue())
+	})
+
+	t.Run("emits unhealthy event", func(t *testing.T) {
+		events := getEvents(resultK.GetName(), map[string]string{"kustomize.toolkit.fluxcd.io/revision": revision})
+		g.Expect(len(events) > 0).To(BeTrue())
+		g.Expect(events[len(events)-1].Type).To(BeIdenticalTo("Warning"))
+		g.Expect(events[len(events)-1].Message).To(ContainSubstring("NotFound"))
+	})
+}
diff --git a/controllers/suite_test.go b/controllers/suite_test.go
index ff11c6d8..dea65b61 100644
--- a/controllers/suite_test.go
+++ b/controllers/suite_test.go
@@ -30,7 +30,7 @@ import (
 	"testing"
 	"time"
 
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
 	"github.com/fluxcd/pkg/apis/meta"
 	"github.com/fluxcd/pkg/runtime/controller"
 	"github.com/fluxcd/pkg/testserver"
@@ -126,6 +126,14 @@ func TestMain(m *testing.M) {
 
 	code := m.Run()
 
+	events := &corev1.EventList{}
+	_ = k8sClient.List(ctx, events)
+	for _, event := range events.Items {
+		fmt.Println(fmt.Sprintf("%s %s \n%s\n",
+			event.InvolvedObject.Name, event.GetAnnotations()["kustomize.toolkit.fluxcd.io/revision"],
+			event.Message))
+	}
+
 	fmt.Println("Stopping the file server")
 	testServer.Stop()
 	if err := os.RemoveAll(testServer.Root()); err != nil {
@@ -148,6 +156,27 @@ func randStringRunes(n int) string {
 	return string(b)
 }
 
+func getEvents(objName string, annotations map[string]string) []corev1.Event {
+	var result []corev1.Event
+	events := &corev1.EventList{}
+	_ = k8sClient.List(ctx, events)
+	for _, event := range events.Items {
+		if event.InvolvedObject.Name == objName {
+			if annotations == nil && len(annotations) == 0 {
+				result = append(result, event)
+			} else {
+				for ak, av := range annotations {
+					if event.GetAnnotations()[ak] == av {
+						result = append(result, event)
+						break
+					}
+				}
+			}
+		}
+	}
+	return result
+}
+
 func createNamespace(name string) error {
 	namespace := &corev1.Namespace{
 		ObjectMeta: metav1.ObjectMeta{Name: name},
diff --git a/controllers/utils.go b/controllers/utils.go
deleted file mode 100644
index 5a48c1e6..00000000
--- a/controllers/utils.go
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
-Copyright 2020 The Flux authors
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-*/
-
-package controllers
-
-import (
-	"errors"
-	"regexp"
-	"strings"
-)
-
-// parseApplyOutput extracts the objects and the action
-// performed by kubectl e.g.:
-// service/backend created
-// service/frontend configured
-// service/database unchanged
-func parseApplyOutput(in []byte) map[string]string {
-	result := make(map[string]string)
-	input := strings.Split(string(in), "\n")
-	if len(input) == 0 {
-		return result
-	}
-	var parts []string
-	for _, str := range input {
-		if str != "" {
-			parts = append(parts, str)
-		}
-	}
-	for _, str := range parts {
-		kv := strings.Split(str, " ")
-		if len(kv) > 1 {
-			result[kv[0]] = kv[1]
-		}
-	}
-	return result
-}
-
-// parseApplyError extracts the errors from the kubectl
-// apply output by removing the successfully applied objects
-func parseApplyError(in []byte) string {
-	errors := ""
-	lines := strings.Split(string(in), "\n")
-	for _, line := range lines {
-		if line != "" &&
-			!strings.HasSuffix(line, "created") &&
-			!strings.HasSuffix(line, "created (dry run)") &&
-			!strings.HasSuffix(line, "created (server dry run)") &&
-			!strings.HasSuffix(line, "configured") &&
-			!strings.HasSuffix(line, "configured (dry run)") &&
-			!strings.HasSuffix(line, "configured (server dry run)") &&
-			!strings.HasSuffix(line, "unchanged") &&
-			!strings.HasSuffix(line, "unchanged (dry run)") &&
-			!strings.HasSuffix(line, "unchanged (server dry run)") {
-			errors += line + "\n"
-		}
-	}
-
-	return errors
-}
-
-func containsString(slice []string, s string) bool {
-	for _, item := range slice {
-		if item == s {
-			return true
-		}
-	}
-	return false
-}
-
-func stripSensitiveData(err error) error {
-	r := regexp.MustCompile(`(v1.Secret.(StringData|Data):) (.*)`)
-	newErr := r.ReplaceAllString(err.Error(), "$1 [ ** REDACTED ** ]")
-
-	// strip data from bigger context
-	r = regexp.MustCompile(`((stringData|data)\":{)(.*)(})`)
-	newErr = r.ReplaceAllString(newErr, "$1 [ ** REDACTED ** ] $4")
-
-	return errors.New(newErr)
-}
diff --git a/controllers/utils_test.go b/controllers/utils_test.go
deleted file mode 100644
index c8bc3fa5..00000000
--- a/controllers/utils_test.go
+++ /dev/null
@@ -1,86 +0,0 @@
-package controllers
-
-import (
-	"errors"
-	"strings"
-	"testing"
-)
-
-func TestParseApplyError(t *testing.T) {
-	tests := []struct {
-		name     string
-		in       []byte
-		filtered string
-	}{
-		{
-			"apply",
-			[]byte(`
-gitrepository.source.toolkit.fluxcd.io/flux-workspaces unchanged
-ingressroute.traefik.containo.us/flux-receiver configured
-service/notification-controller created
-The Service "webhook-receiver" is invalid: spec.clusterIP: Invalid value: "10.200.133.61": field is immutable
-`),
-			`The Service "webhook-receiver" is invalid: spec.clusterIP: Invalid value: "10.200.133.61": field is immutable`,
-		},
-		{
-			"client dry-run",
-			[]byte(`
-gitrepository.source.toolkit.fluxcd.io/flux-workspaces unchanged (dry run)
-ingressroute.traefik.containo.us/flux-receiver configured (dry run)
-service/notification-controller created (dry run)
-error: error validating data: unknown field "ima  ge" in io.k8s.api.core.v1.Container
-`),
-			`error: error validating data: unknown field "ima  ge" in io.k8s.api.core.v1.Container`,
-		},
-		{
-			"server dry-run",
-			[]byte(`
-gitrepository.source.toolkit.fluxcd.io/flux-workspaces unchanged (server dry run)
-ingressroute.traefik.containo.us/flux-receiver configured (server dry run)
-service/notification-controller created (server dry run)
-error: error validating data: unknown field "ima  ge" in io.k8s.api.core.v1.Container
-`),
-			`error: error validating data: unknown field "ima  ge" in io.k8s.api.core.v1.Container`,
-		},
-	}
-
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			filtered := parseApplyError(tt.in)
-			filtered = strings.TrimSpace(filtered)
-
-			if tt.filtered != filtered {
-				t.Errorf("expected %q, but actual %q", tt.filtered, filtered)
-			}
-		})
-	}
-}
-
-func TestStripSensitiveData(t *testing.T) {
-	tests := []struct {
-		name     string
-		in       error
-		expected error
-	}{
-		{
-			"stringData",
-			errors.New("apply failed: Error from server (BadRequest): error when creating \"0f1563ce-8273-4879-99dd-f6f58629cc2d.yaml\": Secret in version \"v1\" cannot be handled as a Secret: v1.Secret.StringData: ReadString: expects \" or n, but found 0, error found in #10 byte of ...|\"secret\":0}}\n|..., bigger context ...|\"namespace\":\"sensitive-data-dkgvw\"},\"stringData\":{\"secret\":0}}\n|...\n"),
-			errors.New("apply failed: Error from server (BadRequest): error when creating \"0f1563ce-8273-4879-99dd-f6f58629cc2d.yaml\": Secret in version \"v1\" cannot be handled as a Secret: v1.Secret.StringData: [ ** REDACTED ** ]\n|..., bigger context ...|\"namespace\":\"sensitive-data-dkgvw\"},\"stringData\":{ [ ** REDACTED ** ] }\n|...\n"),
-		},
-		{
-			"data",
-			errors.New("apply failed: Error from server (BadRequest): error when creating \"0f1563ce-8273-4879-99dd-f6f58629cc2d.yaml\": Secret in version \"v1\" cannot be handled as a Secret: v1.Secret.Data: ReadString: expects \" or n, but found 0, error found in #10 byte of ...|\"secret\":0}}\n|..., bigger context ...|\"namespace\":\"sensitive-data-dkgvw\"},\"data\":{\"secret\":0}}\n|...\n"),
-			errors.New("apply failed: Error from server (BadRequest): error when creating \"0f1563ce-8273-4879-99dd-f6f58629cc2d.yaml\": Secret in version \"v1\" cannot be handled as a Secret: v1.Secret.Data: [ ** REDACTED ** ]\n|..., bigger context ...|\"namespace\":\"sensitive-data-dkgvw\"},\"data\":{ [ ** REDACTED ** ] }\n|...\n"),
-		},
-	}
-
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			expected := stripSensitiveData(tt.in)
-
-			if expected.Error() != tt.expected.Error() {
-				t.Errorf("\nexpected:\n%q\ngot:\n%q\n", tt.expected.Error(), expected.Error())
-			}
-		})
-	}
-}
diff --git a/main.go b/main.go
index f89c43c1..1d577f43 100644
--- a/main.go
+++ b/main.go
@@ -38,13 +38,11 @@ import (
 	"github.com/fluxcd/pkg/runtime/probes"
 	sourcev1 "github.com/fluxcd/source-controller/api/v1beta1"
 
-	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta1"
+	kustomizev1 "github.com/fluxcd/kustomize-controller/api/v1beta2"
 	"github.com/fluxcd/kustomize-controller/controllers"
 	// +kubebuilder:scaffold:imports
 )
 
-const controllerName = "kustomize-controller"
-
 var (
 	scheme   = runtime.NewScheme()
 	setupLog = ctrl.Log.WithName("setup")
@@ -89,7 +87,7 @@ func main() {
 
 	var eventRecorder *events.Recorder
 	if eventsAddr != "" {
-		if er, err := events.NewRecorder(eventsAddr, controllerName); err != nil {
+		if er, err := events.NewRecorder(eventsAddr, kustomizev1.KustomizationController); err != nil {
 			setupLog.Error(err, "unable to create event recorder")
 			os.Exit(1)
 		} else {
@@ -116,7 +114,7 @@ func main() {
 		LeaseDuration:                 &leaderElectionOptions.LeaseDuration,
 		RenewDeadline:                 &leaderElectionOptions.RenewDeadline,
 		RetryPeriod:                   &leaderElectionOptions.RetryPeriod,
-		LeaderElectionID:              fmt.Sprintf("%s-leader-election", controllerName),
+		LeaderElectionID:              fmt.Sprintf("%s-leader-election", kustomizev1.KustomizationController),
 		Namespace:                     watchNamespace,
 		Logger:                        ctrl.Log,
 	})
@@ -131,7 +129,7 @@ func main() {
 	if err = (&controllers.KustomizationReconciler{
 		Client:                mgr.GetClient(),
 		Scheme:                mgr.GetScheme(),
-		EventRecorder:         mgr.GetEventRecorderFor(controllerName),
+		EventRecorder:         mgr.GetEventRecorderFor(kustomizev1.KustomizationController),
 		ExternalEventRecorder: eventRecorder,
 		MetricsRecorder:       metricsRecorder,
 		StatusPoller:          polling.NewStatusPoller(mgr.GetClient(), mgr.GetRESTMapper()),
