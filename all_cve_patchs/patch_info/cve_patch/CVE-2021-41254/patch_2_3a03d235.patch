From 3a03d235c241e097e0b6c5d293eca1e55e7c3917 Mon Sep 17 00:00:00 2001
From: Stefan Prodan <stefan.prodan@gmail.com>
Date: Sat, 11 Sep 2021 18:42:58 +0300
Subject: [PATCH] Add SSA resource manager Package ssa contains utilities for
 managing Kubernetes resources using sever-side apply. Package objectutil
 contains utilities for manipulating Kubernetes objects.

Signed-off-by: Stefan Prodan <stefan.prodan@gmail.com>
---
 go.mod                              |   1 +
 internal/objectutil/doc.go          |  19 +++
 internal/objectutil/fmt.go          |  64 ++++++++++
 internal/objectutil/io.go           | 138 +++++++++++++++++++++
 internal/objectutil/sort.go         | 123 +++++++++++++++++++
 internal/ssa/changeset.go           |  84 +++++++++++++
 internal/ssa/doc.go                 |  20 +++
 internal/ssa/main_test.go           | 107 ++++++++++++++++
 internal/ssa/manager.go             |  69 +++++++++++
 internal/ssa/manager_apply.go       | 181 +++++++++++++++++++++++++++
 internal/ssa/manager_apply_test.go  | 183 ++++++++++++++++++++++++++++
 internal/ssa/manager_delete.go      |  79 ++++++++++++
 internal/ssa/manager_delete_test.go |  85 +++++++++++++
 internal/ssa/manager_diff.go        | 136 +++++++++++++++++++++
 internal/ssa/manager_diff_test.go   | 100 +++++++++++++++
 internal/ssa/manager_wait.go        | 128 +++++++++++++++++++
 internal/ssa/owner.go               |  27 ++++
 internal/ssa/testdata/test1.yaml    |  53 ++++++++
 18 files changed, 1597 insertions(+)
 create mode 100644 internal/objectutil/doc.go
 create mode 100644 internal/objectutil/fmt.go
 create mode 100644 internal/objectutil/io.go
 create mode 100644 internal/objectutil/sort.go
 create mode 100644 internal/ssa/changeset.go
 create mode 100644 internal/ssa/doc.go
 create mode 100644 internal/ssa/main_test.go
 create mode 100644 internal/ssa/manager.go
 create mode 100644 internal/ssa/manager_apply.go
 create mode 100644 internal/ssa/manager_apply_test.go
 create mode 100644 internal/ssa/manager_delete.go
 create mode 100644 internal/ssa/manager_delete_test.go
 create mode 100644 internal/ssa/manager_diff.go
 create mode 100644 internal/ssa/manager_diff_test.go
 create mode 100644 internal/ssa/manager_wait.go
 create mode 100644 internal/ssa/owner.go
 create mode 100644 internal/ssa/testdata/test1.yaml

diff --git a/go.mod b/go.mod
index 684a00d1..91887d93 100644
--- a/go.mod
+++ b/go.mod
@@ -16,6 +16,7 @@ require (
 	github.com/fluxcd/pkg/untar v0.1.0
 	github.com/fluxcd/source-controller/api v0.15.4
 	github.com/go-logr/logr v0.4.0
+	github.com/google/go-cmp v0.5.5
 	github.com/hashicorp/go-retryablehttp v0.6.8
 	github.com/howeyc/gopass v0.0.0-20170109162249-bf9dde6d0d2c
 	github.com/onsi/gomega v1.15.0
diff --git a/internal/objectutil/doc.go b/internal/objectutil/doc.go
new file mode 100644
index 00000000..643341e2
--- /dev/null
+++ b/internal/objectutil/doc.go
@@ -0,0 +1,19 @@
+/*
+Copyright 2021 Stefan Prodan
+Copyright 2021 The Flux authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Package objectutil contains utilities for manipulating Kubernetes objects.
+package objectutil
diff --git a/internal/objectutil/fmt.go b/internal/objectutil/fmt.go
new file mode 100644
index 00000000..b2d0eaad
--- /dev/null
+++ b/internal/objectutil/fmt.go
@@ -0,0 +1,64 @@
+/*
+Copyright 2021 Stefan Prodan
+Copyright 2021 The Flux authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package objectutil
+
+import (
+	"strings"
+
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"sigs.k8s.io/cli-utils/pkg/object"
+)
+
+const fmtSeparator = "/"
+
+// FmtObjMetadata returns the object ID in the format <kind>/<namespace>/<name>.
+func FmtObjMetadata(obj object.ObjMetadata) string {
+	var builder strings.Builder
+	builder.WriteString(obj.GroupKind.Kind + fmtSeparator)
+	if obj.Namespace != "" {
+		builder.WriteString(obj.Namespace + fmtSeparator)
+	}
+	builder.WriteString(obj.Name)
+	return builder.String()
+}
+
+// FmtUnstructured returns the object ID in the format <kind>/<namespace>/<name>.
+func FmtUnstructured(obj *unstructured.Unstructured) string {
+	return FmtObjMetadata(object.UnstructuredToObjMeta(obj))
+}
+
+// MaskSecret replaces the data key values with the given mask.
+func MaskSecret(object *unstructured.Unstructured, mask string) (*unstructured.Unstructured, error) {
+	data, found, err := unstructured.NestedMap(object.Object, "data")
+	if err != nil {
+		return nil, err
+	}
+
+	if found {
+		for k, _ := range data {
+			data[k] = mask
+		}
+
+		err = unstructured.SetNestedMap(object.Object, data, "data")
+		if err != nil {
+			return nil, err
+		}
+	}
+
+	return object, err
+}
diff --git a/internal/objectutil/io.go b/internal/objectutil/io.go
new file mode 100644
index 00000000..a9e19b23
--- /dev/null
+++ b/internal/objectutil/io.go
@@ -0,0 +1,138 @@
+/*
+Copyright 2021 Stefan Prodan
+Copyright 2021 The Flux authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package objectutil
+
+import (
+	"encoding/json"
+	"io"
+	"strings"
+
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	apiruntime "k8s.io/apimachinery/pkg/runtime"
+	yamlutil "k8s.io/apimachinery/pkg/util/yaml"
+	"sigs.k8s.io/yaml"
+)
+
+// ReadObject decodes a YAML or JSON document from the given reader into an unstructured Kubernetes API object.
+func ReadObject(r io.Reader) (*unstructured.Unstructured, error) {
+	reader := yamlutil.NewYAMLOrJSONDecoder(r, 2048)
+	obj := &unstructured.Unstructured{}
+	err := reader.Decode(obj)
+	if err != nil {
+		return nil, err
+	}
+
+	return obj, nil
+}
+
+// ReadObjects decodes the YAML or JSON documents from the given reader into unstructured Kubernetes API objects.
+func ReadObjects(r io.Reader) ([]*unstructured.Unstructured, error) {
+	reader := yamlutil.NewYAMLOrJSONDecoder(r, 2048)
+	objects := make([]*unstructured.Unstructured, 0)
+
+	for {
+		obj := &unstructured.Unstructured{}
+		err := reader.Decode(obj)
+		if err != nil {
+			if err == io.EOF {
+				err = nil
+				break
+			}
+			return objects, err
+		}
+
+		if obj.IsList() {
+			err = obj.EachListItem(func(item apiruntime.Object) error {
+				obj := item.(*unstructured.Unstructured)
+				objects = append(objects, obj)
+				return nil
+			})
+			if err != nil {
+				return objects, err
+			}
+			continue
+		}
+
+		if IsKubernetesObject(obj) && !IsKustomization(obj) {
+			objects = append(objects, obj)
+		}
+	}
+
+	return objects, nil
+}
+
+func IsKubernetesObject(object *unstructured.Unstructured) bool {
+	if object.GetName() == "" || object.GetKind() == "" || object.GetAPIVersion() == "" {
+		return false
+	}
+	return true
+}
+
+func IsKustomization(object *unstructured.Unstructured) bool {
+	if object.GetKind() == "Kustomization" && object.GroupVersionKind().GroupKind().Group == "kustomize.config.k8s.io" {
+		return true
+	}
+	return false
+}
+
+// ObjectToYAML encodes the given Kubernetes API object to YAML.
+func ObjectToYAML(object *unstructured.Unstructured) string {
+	var builder strings.Builder
+	data, err := yaml.Marshal(object)
+	if err != nil {
+		return ""
+	}
+	builder.Write(data)
+	builder.WriteString("---\n")
+
+	return builder.String()
+}
+
+// ObjectsToYAML encodes the given Kubernetes API objects to a YAML multi-doc.
+func ObjectsToYAML(objects []*unstructured.Unstructured) (string, error) {
+	var builder strings.Builder
+	for _, obj := range objects {
+		data, err := yaml.Marshal(obj)
+		if err != nil {
+			return "", err
+		}
+		builder.Write(data)
+		builder.WriteString("---\n")
+	}
+	return builder.String(), nil
+}
+
+// ObjectsToJSON encodes the given Kubernetes API objects to a YAML multi-doc.
+func ObjectsToJSON(objects []*unstructured.Unstructured) (string, error) {
+	list := struct {
+		ApiVersion string                       `json:"apiVersion,omitempty"`
+		Kind       string                       `json:"kind,omitempty"`
+		Items      []*unstructured.Unstructured `json:"items,omitempty"`
+	}{
+		ApiVersion: "v1",
+		Kind:       "ListMeta",
+		Items:      objects,
+	}
+
+	data, err := json.MarshalIndent(list, "", "    ")
+	if err != nil {
+		return "", err
+	}
+
+	return string(data), nil
+}
diff --git a/internal/objectutil/sort.go b/internal/objectutil/sort.go
new file mode 100644
index 00000000..da33d2f0
--- /dev/null
+++ b/internal/objectutil/sort.go
@@ -0,0 +1,123 @@
+/*
+Copyright 2021 Stefan Prodan.
+Copyright 2020 The Kubernetes Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package objectutil
+
+import (
+	"sort"
+
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"sigs.k8s.io/cli-utils/pkg/object"
+)
+
+type SortableUnstructureds []*unstructured.Unstructured
+
+var _ sort.Interface = SortableUnstructureds{}
+
+func (a SortableUnstructureds) Len() int      { return len(a) }
+func (a SortableUnstructureds) Swap(i, j int) { a[i], a[j] = a[j], a[i] }
+func (a SortableUnstructureds) Less(i, j int) bool {
+	first := object.UnstructuredToObjMeta(a[i])
+	second := object.UnstructuredToObjMeta(a[j])
+	return less(first, second)
+}
+
+type SortableMetas []object.ObjMetadata
+
+var _ sort.Interface = SortableMetas{}
+
+func (a SortableMetas) Len() int      { return len(a) }
+func (a SortableMetas) Swap(i, j int) { a[i], a[j] = a[j], a[i] }
+func (a SortableMetas) Less(i, j int) bool {
+	return less(a[i], a[j])
+}
+
+func less(i, j object.ObjMetadata) bool {
+	if !Equals(i.GroupKind, j.GroupKind) {
+		return IsLessThan(i.GroupKind, j.GroupKind)
+	}
+	// In case of tie, compare the namespace and name combination so that the output
+	// order is consistent irrespective of input order
+	if i.Namespace != j.Namespace {
+		return i.Namespace < j.Namespace
+	}
+	return i.Name < j.Name
+}
+
+var kind2index = computeKind2index()
+
+func computeKind2index() map[string]int {
+	// An attempt to order things to help k8s, e.g.
+	// a Service should come before things that refer to it.
+	// Namespace should be first.
+	// In some cases order just specified to provide determinism.
+	orderFirst := []string{
+		"CustomResourceDefinition",
+		"Namespace",
+		"ResourceQuota",
+		"StorageClass",
+		"ServiceAccount",
+		"PodSecurityPolicy",
+		"Role",
+		"ClusterRole",
+		"RoleBinding",
+		"ClusterRoleBinding",
+		"ConfigMap",
+		"Secret",
+		"Service",
+		"LimitRange",
+		"PriorityClass",
+		"Deployment",
+		"StatefulSet",
+		"CronJob",
+		"PodDisruptionBudget",
+	}
+	orderLast := []string{
+		"MutatingWebhookConfiguration",
+		"ValidatingWebhookConfiguration",
+	}
+	kind2indexResult := make(map[string]int, len(orderFirst)+len(orderLast))
+	for i, n := range orderFirst {
+		kind2indexResult[n] = -len(orderFirst) + i
+	}
+	for i, n := range orderLast {
+		kind2indexResult[n] = 1 + i
+	}
+	return kind2indexResult
+}
+
+// getIndexByKind returns the index of the kind respecting the order
+func getIndexByKind(kind string) int {
+	return kind2index[kind]
+}
+
+func Equals(i, j schema.GroupKind) bool {
+	return i.Group == j.Group && i.Kind == j.Kind
+}
+
+func IsLessThan(i, j schema.GroupKind) bool {
+	indexI := getIndexByKind(i.Kind)
+	indexJ := getIndexByKind(j.Kind)
+	if indexI != indexJ {
+		return indexI < indexJ
+	}
+	if i.Group != j.Group {
+		return i.Group < j.Group
+	}
+	return i.Kind < j.Kind
+}
diff --git a/internal/ssa/changeset.go b/internal/ssa/changeset.go
new file mode 100644
index 00000000..0f9b8ff9
--- /dev/null
+++ b/internal/ssa/changeset.go
@@ -0,0 +1,84 @@
+/*
+Copyright 2021 Stefan Prodan
+Copyright 2021 The Flux authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package ssa
+
+import (
+	"fmt"
+	"strings"
+)
+
+// Action resents the action type performed by the reconciliation process.
+type Action string
+
+const (
+	CreatedAction    Action = "created"
+	ConfiguredAction Action = "configured"
+	UnchangedAction  Action = "unchanged"
+	DeletedAction    Action = "deleted"
+	UnknownAction    Action = "unknown"
+)
+
+// ChangeSet holds the result of the reconciliation of an object collection.
+type ChangeSet struct {
+	Entries []ChangeSetEntry
+}
+
+// NewChangeSet returns a ChangeSet will an empty slice of entries.
+func NewChangeSet() *ChangeSet {
+	return &ChangeSet{Entries: []ChangeSetEntry{}}
+}
+
+// Add appends the given entry to the end of the slice.
+func (c *ChangeSet) Add(e ChangeSetEntry) {
+	c.Entries = append(c.Entries, e)
+}
+
+// Append adds the given ChangeSet entries to end of the slice.
+func (c *ChangeSet) Append(e []ChangeSetEntry) {
+	c.Entries = append(c.Entries, e...)
+}
+
+func (c *ChangeSet) String() string {
+	var b strings.Builder
+	for _, entry := range c.Entries {
+		b.WriteString(entry.String() + "\n")
+	}
+	return strings.TrimSuffix(b.String(), "\n")
+}
+
+func (c *ChangeSet) ToMap() map[string]string {
+	res := make(map[string]string)
+	for _, entry := range c.Entries {
+		res[entry.Subject] = entry.Action
+	}
+	return res
+}
+
+// ChangeSetEntry defines the result of an action performed on an object.
+type ChangeSetEntry struct {
+	// Subject represents the Object ID in the format 'kind/namespace/name'.
+	Subject string
+	// Action represents the action type taken by the reconciler for this object.
+	Action string
+	// Diff contains the YAML diff resulting from server-side apply dry-run.
+	Diff string
+}
+
+func (e ChangeSetEntry) String() string {
+	return fmt.Sprintf("%s %s", e.Subject, e.Action)
+}
diff --git a/internal/ssa/doc.go b/internal/ssa/doc.go
new file mode 100644
index 00000000..64ac9fd4
--- /dev/null
+++ b/internal/ssa/doc.go
@@ -0,0 +1,20 @@
+/*
+Copyright 2021 Stefan Prodan
+Copyright 2021 The Flux authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Package ssa contains utilities for managing Kubernetes resources using sever-side apply.
+// Adapted from https://github.com/stefanprodan/kustomizer/tree/v1.1.0/pkg/manager
+package ssa
diff --git a/internal/ssa/main_test.go b/internal/ssa/main_test.go
new file mode 100644
index 00000000..90080c44
--- /dev/null
+++ b/internal/ssa/main_test.go
@@ -0,0 +1,107 @@
+package ssa
+
+import (
+	"fmt"
+	"os"
+	"strings"
+	"sync/atomic"
+	"testing"
+
+	"github.com/fluxcd/kustomize-controller/internal/objectutil"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"sigs.k8s.io/cli-utils/pkg/kstatus/polling"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+	"sigs.k8s.io/controller-runtime/pkg/client/apiutil"
+	"sigs.k8s.io/controller-runtime/pkg/envtest"
+)
+
+var manager *ResourceManager
+
+func TestMain(m *testing.M) {
+	testEnv := &envtest.Environment{}
+
+	cfg, err := testEnv.Start()
+	if err != nil {
+		panic(err)
+	}
+
+	restMapper, err := apiutil.NewDynamicRESTMapper(cfg)
+	if err != nil {
+		panic(err)
+	}
+
+	kubeClient, err := client.New(cfg, client.Options{
+		Mapper: restMapper,
+	})
+	if err != nil {
+		panic(err)
+	}
+
+	poller := polling.NewStatusPoller(kubeClient, restMapper)
+
+	manager = &ResourceManager{
+		client: kubeClient,
+		poller: poller,
+		owner: Owner{
+			Field: "resource-manager",
+			Group: "resource-manager.io",
+		},
+	}
+
+	code := m.Run()
+
+	testEnv.Stop()
+
+	os.Exit(code)
+}
+
+func readManifest(manifest, namespace string) ([]*unstructured.Unstructured, error) {
+	data, err := os.ReadFile(manifest)
+	if err != nil {
+		return nil, err
+	}
+	yml := fmt.Sprintf(string(data), namespace)
+
+	objects, err := objectutil.ReadObjects(strings.NewReader(yml))
+	if err != nil {
+		return nil, err
+	}
+
+	return objects, nil
+}
+
+func setNamespace(objects []*unstructured.Unstructured, namespace string) {
+	for _, object := range objects {
+		object.SetNamespace(namespace)
+	}
+
+	u := &unstructured.Unstructured{}
+	u.SetGroupVersionKind(schema.GroupVersionKind{
+		Group:   "",
+		Kind:    "Namespace",
+		Version: "v1",
+	})
+	u.SetName(namespace)
+	objects = append(objects, u)
+}
+
+var nextNameId int64
+
+func generateName(prefix string) string {
+	id := atomic.AddInt64(&nextNameId, 1)
+	return fmt.Sprintf("%s-%d", prefix, id)
+}
+
+func getFirstObject(objects []*unstructured.Unstructured, kind, name string) (string, *unstructured.Unstructured) {
+	for _, object := range objects {
+		if object.GetKind() == kind && object.GetName() == name {
+			return objectutil.FmtUnstructured(object), object
+		}
+	}
+	return "", nil
+}
+
+func removeObject(s []*unstructured.Unstructured, index int) []*unstructured.Unstructured {
+	return append(s[:index], s[index+1:]...)
+}
diff --git a/internal/ssa/manager.go b/internal/ssa/manager.go
new file mode 100644
index 00000000..4fde20c5
--- /dev/null
+++ b/internal/ssa/manager.go
@@ -0,0 +1,69 @@
+/*
+Copyright 2021 Stefan Prodan
+Copyright 2021 The Flux authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package ssa
+
+import (
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"sigs.k8s.io/cli-utils/pkg/kstatus/polling"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+
+	"github.com/fluxcd/kustomize-controller/internal/objectutil"
+)
+
+// ResourceManager reconciles Kubernetes resources onto the target cluster using server-side apply.
+type ResourceManager struct {
+	client client.Client
+	poller *polling.StatusPoller
+	owner  Owner
+}
+
+// NewResourceManager creates a ResourceManager for the given Kubernetes client.
+func NewResourceManager(client client.Client, poller *polling.StatusPoller, owner Owner) *ResourceManager {
+	return &ResourceManager{
+		client: client,
+		poller: poller,
+		owner:  owner,
+	}
+}
+
+// Client returns the underlying controller-runtime client.
+func (m *ResourceManager) Client() client.Client {
+	return m.client
+}
+
+// SetOwnerLabels adds the ownership labels to the given objects.
+// The ownership labels are in the format:
+// 	<owner.group>/name: <name>
+// 	<owner.group>/namespace: <namespace>
+func (m *ResourceManager) SetOwnerLabels(objects []*unstructured.Unstructured, name, namespace string) {
+	for _, object := range objects {
+		labels := object.GetLabels()
+		if labels == nil {
+			labels = make(map[string]string)
+		}
+
+		labels[m.owner.Group+"/name"] = name
+		labels[m.owner.Group+"/namespace"] = namespace
+
+		object.SetLabels(labels)
+	}
+}
+
+func (m *ResourceManager) changeSetEntry(object *unstructured.Unstructured, action Action) *ChangeSetEntry {
+	return &ChangeSetEntry{Subject: objectutil.FmtUnstructured(object), Action: string(action)}
+}
diff --git a/internal/ssa/manager_apply.go b/internal/ssa/manager_apply.go
new file mode 100644
index 00000000..bf7d1ef9
--- /dev/null
+++ b/internal/ssa/manager_apply.go
@@ -0,0 +1,181 @@
+/*
+Copyright 2021 Stefan Prodan
+Copyright 2021 The Flux authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package ssa
+
+import (
+	"context"
+	"fmt"
+	"sort"
+	"strings"
+	"time"
+
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+
+	"github.com/fluxcd/kustomize-controller/internal/objectutil"
+)
+
+// Apply performs a server-side apply of the given object if the matching in-cluster object is different or if it doesn't exist.
+// Drift detection is performed by comparing the server-side dry-run result with the existing object.
+// When immutable field changes are detected, the object is recreated if 'force' is set to 'true'.
+func (m *ResourceManager) Apply(ctx context.Context, object *unstructured.Unstructured, force bool) (*ChangeSetEntry, error) {
+	existingObject := object.DeepCopy()
+	_ = m.client.Get(ctx, client.ObjectKeyFromObject(object), existingObject)
+
+	dryRunObject := object.DeepCopy()
+	if err := m.dryRunApply(ctx, dryRunObject); err != nil {
+		if force && strings.Contains(err.Error(), "immutable") {
+			if err := m.client.Delete(ctx, existingObject); err != nil {
+				return nil, fmt.Errorf("%s immutable field detected, failed to delete object, error: %w",
+					objectutil.FmtUnstructured(dryRunObject), err)
+			}
+			return m.Apply(ctx, object, force)
+		}
+
+		return nil, m.validationError(dryRunObject, err)
+	}
+
+	// do not apply objects that have not drifted to avoid bumping the resource version
+	if !m.hasDrifted(existingObject, dryRunObject) {
+		return m.changeSetEntry(object, UnchangedAction), nil
+	}
+
+	appliedObject := object.DeepCopy()
+	if err := m.apply(ctx, appliedObject); err != nil {
+		return nil, fmt.Errorf("%s apply failed, error: %w", objectutil.FmtUnstructured(appliedObject), err)
+	}
+
+	if dryRunObject.GetResourceVersion() == "" {
+		return m.changeSetEntry(appliedObject, CreatedAction), nil
+	}
+
+	return m.changeSetEntry(appliedObject, ConfiguredAction), nil
+}
+
+// ApplyAll performs a server-side dry-run of the given objects, and based on the diff result,
+// it applies the objects that are new or modified.
+func (m *ResourceManager) ApplyAll(ctx context.Context, objects []*unstructured.Unstructured, force bool) (*ChangeSet, error) {
+	sort.Sort(objectutil.SortableUnstructureds(objects))
+	changeSet := NewChangeSet()
+	var toApply []*unstructured.Unstructured
+	for _, object := range objects {
+		existingObject := object.DeepCopy()
+		_ = m.client.Get(ctx, client.ObjectKeyFromObject(object), existingObject)
+
+		dryRunObject := object.DeepCopy()
+		if err := m.dryRunApply(ctx, dryRunObject); err != nil {
+			if force && strings.Contains(err.Error(), "immutable") {
+				if err := m.client.Delete(ctx, existingObject); err != nil {
+					return nil, fmt.Errorf("%s immutable field detected, failed to delete object, error: %w",
+						objectutil.FmtUnstructured(dryRunObject), err)
+				}
+				return m.ApplyAll(ctx, objects, force)
+			}
+
+			return nil, m.validationError(dryRunObject, err)
+		}
+
+		if m.hasDrifted(existingObject, dryRunObject) {
+			toApply = append(toApply, object)
+			if dryRunObject.GetResourceVersion() == "" {
+				changeSet.Add(*m.changeSetEntry(dryRunObject, CreatedAction))
+			} else {
+				changeSet.Add(*m.changeSetEntry(dryRunObject, ConfiguredAction))
+			}
+		} else {
+			changeSet.Add(*m.changeSetEntry(dryRunObject, UnchangedAction))
+		}
+	}
+
+	for _, object := range toApply {
+		appliedObject := object.DeepCopy()
+		if err := m.apply(ctx, appliedObject); err != nil {
+			return nil, fmt.Errorf("%s apply failed, error: %w", objectutil.FmtUnstructured(appliedObject), err)
+		}
+	}
+
+	return changeSet, nil
+}
+
+// ApplyAllStaged extracts the CRDs and Namespaces, applies them with ApplyAll,
+// waits for CRDs and Namespaces to become ready, then is applies all the other objects.
+// This function should be used when the given objects have a mix of custom resource definition and custom resources,
+// or a mix of namespace definitions with namespaced objects.
+func (m *ResourceManager) ApplyAllStaged(ctx context.Context, objects []*unstructured.Unstructured, force bool, wait time.Duration) (*ChangeSet, error) {
+	changeSet := NewChangeSet()
+
+	// contains only CRDs and Namespaces
+	var stageOne []*unstructured.Unstructured
+
+	// contains all objects except for CRDs and Namespaces
+	var stageTwo []*unstructured.Unstructured
+
+	for _, u := range objects {
+		if m.IsClusterDefinition(u.GetKind()) {
+			stageOne = append(stageOne, u)
+		} else {
+			stageTwo = append(stageTwo, u)
+		}
+	}
+
+	if len(stageOne) > 0 {
+		cs, err := m.ApplyAll(ctx, stageOne, force)
+		if err != nil {
+			return nil, err
+		}
+		changeSet.Append(cs.Entries)
+
+		if err := m.Wait(stageOne, 2*time.Second, wait); err != nil {
+			return nil, err
+		}
+	}
+
+	cs, err := m.ApplyAll(ctx, stageTwo, force)
+	if err != nil {
+		return nil, err
+	}
+	changeSet.Append(cs.Entries)
+
+	return changeSet, nil
+}
+
+func (m *ResourceManager) dryRunApply(ctx context.Context, object *unstructured.Unstructured) error {
+	opts := []client.PatchOption{
+		client.DryRunAll,
+		client.ForceOwnership,
+		client.FieldOwner(m.owner.Field),
+	}
+	return m.client.Patch(ctx, object, client.Apply, opts...)
+}
+
+func (m *ResourceManager) apply(ctx context.Context, object *unstructured.Unstructured) error {
+	opts := []client.PatchOption{
+		client.ForceOwnership,
+		client.FieldOwner(m.owner.Field),
+	}
+	return m.client.Patch(ctx, object, client.Apply, opts...)
+}
+
+func (m *ResourceManager) IsClusterDefinition(kind string) bool {
+	switch strings.ToLower(kind) {
+	case "customresourcedefinition":
+	case "namespace":
+		return true
+	}
+	return false
+}
diff --git a/internal/ssa/manager_apply_test.go b/internal/ssa/manager_apply_test.go
new file mode 100644
index 00000000..4074c586
--- /dev/null
+++ b/internal/ssa/manager_apply_test.go
@@ -0,0 +1,183 @@
+package ssa
+
+import (
+	"context"
+	"encoding/base64"
+	"fmt"
+	"sort"
+	"testing"
+	"time"
+
+	"github.com/fluxcd/kustomize-controller/internal/objectutil"
+
+	"github.com/google/go-cmp/cmp"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+)
+
+func TestApply(t *testing.T) {
+	timeout := 10 * time.Second
+	ctx, cancel := context.WithTimeout(context.Background(), timeout)
+	defer cancel()
+
+	id := generateName("apply")
+	objects, err := readManifest("testdata/test1.yaml", id)
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	manager.SetOwnerLabels(objects, "app1", "default")
+
+	configMapName, configMap := getFirstObject(objects, "ConfigMap", id)
+	secretName, secret := getFirstObject(objects, "Secret", id)
+
+	t.Run("creates objects in order", func(t *testing.T) {
+		// create objects
+		changeSet, err := manager.ApplyAllStaged(ctx, objects, false, timeout)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		// expected created order
+		sort.Sort(objectutil.SortableUnstructureds(objects))
+		var expected []string
+		for _, object := range objects {
+			expected = append(expected, objectutil.FmtUnstructured(object))
+		}
+
+		// verify the change set contains only created actions
+		var output []string
+		for _, entry := range changeSet.Entries {
+			if diff := cmp.Diff(entry.Action, string(CreatedAction)); diff != "" {
+				t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+			}
+			output = append(output, entry.Subject)
+		}
+
+		// verify the change set contains all objects in the right order
+		if diff := cmp.Diff(expected, output); diff != "" {
+			t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+		}
+	})
+
+	t.Run("does not apply unchanged objects", func(t *testing.T) {
+		// no-op apply
+		changeSet, err := manager.ApplyAllStaged(ctx, objects, false, timeout)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		// verify the change set contains only unchanged actions
+		var output []string
+		for _, entry := range changeSet.Entries {
+			if diff := cmp.Diff(string(UnchangedAction), entry.Action); diff != "" {
+				t.Errorf("Mismatch from expected value (-want +got):\n%s\n%v", diff, changeSet)
+			}
+			output = append(output, entry.Subject)
+		}
+	})
+
+	t.Run("applies only changed objects", func(t *testing.T) {
+		// update a value in the configmap
+		err = unstructured.SetNestedField(configMap.Object, "val", "data", "key")
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		// apply changes
+		changeSet, err := manager.ApplyAllStaged(ctx, objects, false, timeout)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		// verify the change set contains the configured action only for the configmap
+		for _, entry := range changeSet.Entries {
+			if entry.Subject == configMapName {
+				if diff := cmp.Diff(string(ConfiguredAction), entry.Action); diff != "" {
+					t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+				}
+			} else {
+				if diff := cmp.Diff(string(UnchangedAction), entry.Action); diff != "" {
+					t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+				}
+			}
+		}
+
+		// get the configmap from cluster
+		configMapClone := configMap.DeepCopy()
+		err = manager.client.Get(ctx, client.ObjectKeyFromObject(configMapClone), configMapClone)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		// get data value from the in-cluster configmap
+		val, _, err := unstructured.NestedFieldCopy(configMapClone.Object, "data", "key")
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		// verify the configmap was updated in cluster with the right data value
+		if diff := cmp.Diff(val, "val"); diff != "" {
+			t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+		}
+	})
+
+	t.Run("fails to apply immutable secret", func(t *testing.T) {
+		// update a value in the secret
+		err = unstructured.SetNestedField(secret.Object, "val-secret", "stringData", "key")
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		// apply and expect to fail
+		_, err := manager.ApplyAllStaged(ctx, objects, false, timeout)
+		if err == nil {
+			t.Fatal("Expected error got none")
+		}
+
+		// verify that the error message does not contain sensitive information
+		expectedErr := fmt.Sprintf("%s invalid, error: secret is immutable", objectutil.FmtUnstructured(secret))
+		if diff := cmp.Diff(expectedErr, err.Error()); diff != "" {
+			t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+		}
+	})
+
+	t.Run("force applies immutable secret", func(t *testing.T) {
+		// force apply
+		changeSet, err := manager.ApplyAllStaged(ctx, objects, true, timeout)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		// verify the secret was recreated
+		for _, entry := range changeSet.Entries {
+			if entry.Subject == secretName {
+				if diff := cmp.Diff(string(CreatedAction), entry.Action); diff != "" {
+					t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+				}
+			} else {
+				if diff := cmp.Diff(string(UnchangedAction), entry.Action); diff != "" {
+					t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+				}
+			}
+		}
+
+		// get the secret from cluster
+		secretClone := secret.DeepCopy()
+		err = manager.client.Get(ctx, client.ObjectKeyFromObject(secretClone), secretClone)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		// get data value from the in-cluster secret
+		val, _, err := unstructured.NestedFieldCopy(secretClone.Object, "data", "key")
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		// verify the secret was updated in cluster with the right data value
+		if diff := cmp.Diff(val, base64.StdEncoding.EncodeToString([]byte("val-secret"))); diff != "" {
+			t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+		}
+	})
+}
diff --git a/internal/ssa/manager_delete.go b/internal/ssa/manager_delete.go
new file mode 100644
index 00000000..ff3bfb52
--- /dev/null
+++ b/internal/ssa/manager_delete.go
@@ -0,0 +1,79 @@
+/*
+Copyright 2021 Stefan Prodan
+Copyright 2021 The Flux authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package ssa
+
+import (
+	"context"
+	"fmt"
+	"sort"
+
+	"github.com/fluxcd/kustomize-controller/internal/objectutil"
+
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+)
+
+// Delete deletes the given object (not found errors are ignored).
+func (m *ResourceManager) Delete(ctx context.Context, object *unstructured.Unstructured, skipFor map[string]string) (*ChangeSetEntry, error) {
+	existingObject := object.DeepCopy()
+	err := m.client.Get(ctx, client.ObjectKeyFromObject(object), existingObject)
+	if err != nil {
+		if !apierrors.IsNotFound(err) {
+			return m.changeSetEntry(object, UnknownAction),
+				fmt.Errorf("%s query failed, error: %w", objectutil.FmtUnstructured(object), err)
+		}
+		return m.changeSetEntry(object, DeletedAction), nil
+	}
+
+	for n, s := range skipFor {
+		if existingObject.GetLabels()[n] == s || existingObject.GetAnnotations()[n] == s {
+			return m.changeSetEntry(object, UnchangedAction), nil
+		}
+	}
+
+	if err := m.client.Delete(ctx, existingObject); err != nil {
+		return m.changeSetEntry(object, UnknownAction),
+			fmt.Errorf("%s delete failed, error: %w", objectutil.FmtUnstructured(object), err)
+	}
+
+	return m.changeSetEntry(object, DeletedAction), nil
+}
+
+// DeleteAll deletes the given set of objects (not found errors are ignored).
+func (m *ResourceManager) DeleteAll(ctx context.Context, objects []*unstructured.Unstructured, skipFor map[string]string) (*ChangeSet, error) {
+	sort.Sort(sort.Reverse(objectutil.SortableUnstructureds(objects)))
+	changeSet := NewChangeSet()
+
+	var errors string
+	for _, object := range objects {
+		cse, err := m.Delete(ctx, object, skipFor)
+		if cse != nil {
+			changeSet.Add(*cse)
+		}
+		if err != nil {
+			errors += err.Error() + ";"
+		}
+	}
+
+	if errors != "" {
+		return changeSet, fmt.Errorf("delete failed, errors: %s", errors)
+	}
+
+	return changeSet, nil
+}
diff --git a/internal/ssa/manager_delete_test.go b/internal/ssa/manager_delete_test.go
new file mode 100644
index 00000000..eae66e7b
--- /dev/null
+++ b/internal/ssa/manager_delete_test.go
@@ -0,0 +1,85 @@
+package ssa
+
+import (
+	"context"
+	"github.com/fluxcd/kustomize-controller/internal/objectutil"
+	"strings"
+	"testing"
+	"time"
+
+	"github.com/google/go-cmp/cmp"
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+)
+
+func TestDelete(t *testing.T) {
+	timeout := 10 * time.Second
+	ctx, cancel := context.WithTimeout(context.Background(), timeout)
+	defer cancel()
+
+	id := generateName("delete")
+	objects, err := readManifest("testdata/test1.yaml", id)
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	_, configMap := getFirstObject(objects, "ConfigMap", id)
+	_, role := getFirstObject(objects, "ClusterRole", id)
+
+	if _, err = manager.ApplyAllStaged(ctx, objects, false, timeout); err != nil {
+		t.Fatal(err)
+	}
+
+	t.Run("deletes objects in order", func(t *testing.T) {
+		changeSet, err := manager.DeleteAll(ctx, objects, nil)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		// expected deleted order
+		var expected []string
+		for _, object := range objects {
+			expected = append(expected, objectutil.FmtUnstructured(object))
+		}
+
+		// verify the change set contains only created actions
+		var output []string
+		for _, entry := range changeSet.Entries {
+			if diff := cmp.Diff(entry.Action, string(DeletedAction)); diff != "" {
+				t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+			}
+			output = append(output, entry.Subject)
+		}
+
+		// verify the change set contains all objects in the right order
+		if diff := cmp.Diff(expected, output); diff != "" {
+			t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+		}
+
+		configMapClone := configMap.DeepCopy()
+		err = manager.client.Get(ctx, client.ObjectKeyFromObject(configMapClone), configMapClone)
+		if !apierrors.IsNotFound(err) {
+			t.Error(err)
+		}
+
+		roleClone := role.DeepCopy()
+		err = manager.client.Get(ctx, client.ObjectKeyFromObject(roleClone), roleClone)
+		if !apierrors.IsNotFound(err) {
+			t.Error(err)
+		}
+	})
+
+	t.Run("waits for objects termination", func(t *testing.T) {
+		_, err := manager.DeleteAll(ctx, objects, nil)
+		if err != nil {
+			t.Error(err)
+		}
+
+		if err := manager.WaitForTermination(objects, time.Second, 5*time.Second); err != nil {
+			// workaround for https://github.com/kubernetes-sigs/controller-runtime/issues/880
+			if !strings.Contains(err.Error(), "Namespace/") {
+				t.Error(err)
+			}
+		}
+	})
+}
diff --git a/internal/ssa/manager_diff.go b/internal/ssa/manager_diff.go
new file mode 100644
index 00000000..bd201759
--- /dev/null
+++ b/internal/ssa/manager_diff.go
@@ -0,0 +1,136 @@
+/*
+Copyright 2021 Stefan Prodan
+Copyright 2021 The Flux authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package ssa
+
+import (
+	"context"
+	"fmt"
+	"strings"
+
+	"github.com/fluxcd/kustomize-controller/internal/objectutil"
+	"github.com/google/go-cmp/cmp"
+	apiequality "k8s.io/apimachinery/pkg/api/equality"
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+	"sigs.k8s.io/yaml"
+)
+
+// Diff performs a server-side apply dry-un and returns the fields that changed in YAML format.
+// If the diff contains Kubernetes Secrets, the data values are masked.
+func (m *ResourceManager) Diff(ctx context.Context, object *unstructured.Unstructured) (*ChangeSetEntry, error) {
+	existingObject := object.DeepCopy()
+	_ = m.client.Get(ctx, client.ObjectKeyFromObject(object), existingObject)
+
+	dryRunObject := object.DeepCopy()
+	if err := m.dryRunApply(ctx, dryRunObject); err != nil {
+		return nil, m.validationError(dryRunObject, err)
+	}
+
+	if dryRunObject.GetResourceVersion() == "" {
+		return m.changeSetEntry(dryRunObject, CreatedAction), nil
+	}
+
+	if m.hasDrifted(existingObject, dryRunObject) {
+		cse := m.changeSetEntry(object, ConfiguredAction)
+
+		unstructured.RemoveNestedField(dryRunObject.Object, "metadata", "managedFields")
+		unstructured.RemoveNestedField(existingObject.Object, "metadata", "managedFields")
+
+		if dryRunObject.GetKind() == "Secret" {
+			d, err := objectutil.MaskSecret(dryRunObject, "******")
+			if err != nil {
+				return nil, fmt.Errorf("masking secret data failed, error: %w", err)
+			}
+			dryRunObject = d
+			ex, err := objectutil.MaskSecret(existingObject, "*****")
+			if err != nil {
+				return nil, fmt.Errorf("masking secret data failed, error: %w", err)
+			}
+			existingObject = ex
+		}
+
+		d, _ := yaml.Marshal(dryRunObject)
+		e, _ := yaml.Marshal(existingObject)
+		cse.Diff = cmp.Diff(string(e), string(d))
+
+		return cse, nil
+	}
+
+	return m.changeSetEntry(dryRunObject, UnchangedAction), nil
+}
+
+// hasDrifted detects changes to metadata labels, metadata annotations, spec and webhooks.
+func (m *ResourceManager) hasDrifted(existingObject, dryRunObject *unstructured.Unstructured) bool {
+	if dryRunObject.GetResourceVersion() == "" {
+		return true
+	}
+
+	if !apiequality.Semantic.DeepDerivative(dryRunObject.GetLabels(), existingObject.GetLabels()) {
+		return true
+
+	}
+
+	if !apiequality.Semantic.DeepDerivative(dryRunObject.GetAnnotations(), existingObject.GetAnnotations()) {
+		return true
+	}
+
+	if _, ok := existingObject.Object["spec"]; ok {
+		if !apiequality.Semantic.DeepDerivative(dryRunObject.Object["spec"], existingObject.Object["spec"]) {
+			return true
+		}
+	} else if _, ok := existingObject.Object["webhooks"]; ok {
+		if !apiequality.Semantic.DeepDerivative(dryRunObject.Object["webhooks"], existingObject.Object["webhooks"]) {
+			return true
+		}
+	} else {
+		if !apiequality.Semantic.DeepDerivative(dryRunObject.Object, existingObject.Object) {
+			return true
+		}
+	}
+
+	return false
+}
+
+// validationError formats the given error and hides sensitive data
+// if the error was caused by an invalid Kubernetes secrets.
+func (m *ResourceManager) validationError(object *unstructured.Unstructured, err error) error {
+	if apierrors.IsNotFound(err) {
+		return fmt.Errorf("%s namespace not specified, error: %w", objectutil.FmtUnstructured(object), err)
+	}
+
+	reason := fmt.Sprintf("%v", apierrors.ReasonForError(err))
+
+	if object.GetKind() == "Secret" {
+		msg := "data values must be of type string"
+		if strings.Contains(err.Error(), "immutable") {
+			msg = "secret is immutable"
+		}
+		return fmt.Errorf("%s %s, error: %s", objectutil.FmtUnstructured(object), strings.ToLower(reason), msg)
+	}
+
+	// detect managed field conflict
+	if status, ok := apierrors.StatusCause(err, metav1.CauseTypeFieldManagerConflict); ok {
+		reason = fmt.Sprintf("%v", status.Type)
+	}
+
+	return fmt.Errorf("%s dry-run falied, reason: %s, error: %w",
+		objectutil.FmtUnstructured(object), reason, err)
+
+}
diff --git a/internal/ssa/manager_diff_test.go b/internal/ssa/manager_diff_test.go
new file mode 100644
index 00000000..1769841d
--- /dev/null
+++ b/internal/ssa/manager_diff_test.go
@@ -0,0 +1,100 @@
+package ssa
+
+import (
+	"context"
+	"strings"
+	"testing"
+	"time"
+
+	"github.com/google/go-cmp/cmp"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+)
+
+func TestDiff(t *testing.T) {
+	timeout := 10 * time.Second
+	ctx, cancel := context.WithTimeout(context.Background(), timeout)
+	defer cancel()
+
+	id := generateName("diff")
+	objects, err := readManifest("testdata/test1.yaml", id)
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	configMapName, configMap := getFirstObject(objects, "ConfigMap", id)
+	secretName, secret := getFirstObject(objects, "Secret", id)
+
+	if err := unstructured.SetNestedField(secret.Object, false, "immutable"); err != nil {
+		t.Fatal(err)
+	}
+	if _, err = manager.ApplyAllStaged(ctx, objects, false, timeout); err != nil {
+		t.Fatal(err)
+	}
+
+	t.Run("generates empty diff for unchanged object", func(t *testing.T) {
+		changeSetEntry, err := manager.Diff(ctx, configMap)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		if diff := cmp.Diff(configMapName, changeSetEntry.Subject); diff != "" {
+			t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+		}
+
+		if diff := cmp.Diff(string(UnchangedAction), changeSetEntry.Action); diff != "" {
+			t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+		}
+	})
+
+	t.Run("generates diff for changed object", func(t *testing.T) {
+		newVal := "diff-test"
+		err = unstructured.SetNestedField(configMap.Object, newVal, "data", "key")
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		changeSetEntry, err := manager.Diff(ctx, configMap)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		if diff := cmp.Diff(string(ConfiguredAction), changeSetEntry.Action); diff != "" {
+			t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+		}
+
+		if !strings.Contains(changeSetEntry.Diff, newVal) {
+			t.Errorf("Mismatch from expected value, want %s", newVal)
+		}
+	})
+
+	t.Run("masks secret values", func(t *testing.T) {
+		newVal := "diff-test"
+		err = unstructured.SetNestedField(secret.Object, newVal, "stringData", "key")
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		newKey := "key.new"
+		err = unstructured.SetNestedField(secret.Object, newVal, "stringData", newKey)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		changeSetEntry, err := manager.Diff(ctx, secret)
+		if err != nil {
+			t.Fatal(err)
+		}
+
+		if diff := cmp.Diff(secretName, changeSetEntry.Subject); diff != "" {
+			t.Errorf("Mismatch from expected value (-want +got):\n%s", diff)
+		}
+
+		if !strings.Contains(changeSetEntry.Diff, newKey) {
+			t.Errorf("Mismatch from expected value, got %s", changeSetEntry.Diff)
+		}
+
+		if strings.Contains(changeSetEntry.Diff, newVal) {
+			t.Errorf("Mismatch from expected value, got %s", changeSetEntry.Diff)
+		}
+	})
+}
diff --git a/internal/ssa/manager_wait.go b/internal/ssa/manager_wait.go
new file mode 100644
index 00000000..7b25c7f4
--- /dev/null
+++ b/internal/ssa/manager_wait.go
@@ -0,0 +1,128 @@
+/*
+Copyright 2021 Stefan Prodan
+Copyright 2021 The Flux authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package ssa
+
+import (
+	"context"
+	"fmt"
+	"strings"
+	"time"
+
+	"github.com/fluxcd/kustomize-controller/internal/objectutil"
+
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"k8s.io/apimachinery/pkg/util/wait"
+	"sigs.k8s.io/cli-utils/pkg/kstatus/polling"
+	"sigs.k8s.io/cli-utils/pkg/kstatus/polling/aggregator"
+	"sigs.k8s.io/cli-utils/pkg/kstatus/polling/collector"
+	"sigs.k8s.io/cli-utils/pkg/kstatus/polling/event"
+	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
+	"sigs.k8s.io/cli-utils/pkg/object"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+)
+
+// Wait checks if the given set of objects has been fully reconciled.
+func (m *ResourceManager) Wait(objects []*unstructured.Unstructured, interval, timeout time.Duration) error {
+	objectsMeta := object.UnstructuredsToObjMetas(objects)
+	statusCollector := collector.NewResourceStatusCollector(objectsMeta)
+
+	ctx, cancel := context.WithTimeout(context.Background(), timeout)
+	defer cancel()
+
+	opts := polling.Options{
+		PollInterval: interval,
+		UseCache:     true,
+	}
+	eventsChan := m.poller.Poll(ctx, objectsMeta, opts)
+
+	lastStatus := make(map[object.ObjMetadata]*event.ResourceStatus)
+
+	done := statusCollector.ListenWithObserver(eventsChan, collector.ObserverFunc(
+		func(statusCollector *collector.ResourceStatusCollector, e event.Event) {
+			var rss []*event.ResourceStatus
+			for _, rs := range statusCollector.ResourceStatuses {
+				if rs == nil {
+					continue
+				}
+				if rs.Error == nil {
+					lastStatus[rs.Identifier] = rs
+				}
+				rss = append(rss, rs)
+			}
+			desired := status.CurrentStatus
+			aggStatus := aggregator.AggregateStatus(rss, desired)
+			if aggStatus == desired {
+				cancel()
+				return
+			}
+		}),
+	)
+
+	<-done
+
+	if statusCollector.Error != nil {
+		return statusCollector.Error
+	}
+
+	if ctx.Err() == context.DeadlineExceeded {
+		var errors = []string{}
+		for id, rs := range statusCollector.ResourceStatuses {
+			if rs == nil {
+				errors = append(errors, fmt.Sprintf("can't determine status for %s", objectutil.FmtObjMetadata(id)))
+				continue
+			}
+			if lastStatus[id].Status != status.CurrentStatus {
+				var builder strings.Builder
+				builder.WriteString(fmt.Sprintf("%s status: '%s'",
+					objectutil.FmtObjMetadata(rs.Identifier), lastStatus[id].Status))
+				if rs.Error != nil {
+					builder.WriteString(fmt.Sprintf(": %s", rs.Error))
+				}
+				errors = append(errors, builder.String())
+			}
+		}
+		return fmt.Errorf("timeout waiting for: [%s]", strings.Join(errors, ", "))
+	}
+
+	return nil
+}
+
+// WaitForTermination waits for the given objects to be deleted from the cluster.
+func (m *ResourceManager) WaitForTermination(objects []*unstructured.Unstructured, interval, timeout time.Duration) error {
+	ctx, cancel := context.WithTimeout(context.Background(), timeout)
+	defer cancel()
+
+	for _, object := range objects {
+		if err := wait.PollImmediate(interval, timeout, m.isDeleted(ctx, object)); err != nil {
+			return fmt.Errorf("%s termination timeout, error: %w", objectutil.FmtUnstructured(object), err)
+		}
+	}
+	return nil
+}
+
+func (m *ResourceManager) isDeleted(ctx context.Context, object *unstructured.Unstructured) wait.ConditionFunc {
+	return func() (bool, error) {
+		obj := object.DeepCopy()
+		err := m.client.Get(ctx, client.ObjectKeyFromObject(obj), obj)
+		if apierrors.IsNotFound(err) {
+			return true, nil
+		}
+		return false, err
+	}
+}
diff --git a/internal/ssa/owner.go b/internal/ssa/owner.go
new file mode 100644
index 00000000..c3357625
--- /dev/null
+++ b/internal/ssa/owner.go
@@ -0,0 +1,27 @@
+/*
+Copyright 2021 Stefan Prodan
+Copyright 2021 The Flux authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package ssa
+
+// Owner contains options for setting the field manager and ownership labels group.
+type Owner struct {
+	// Field sets the field manager name for the given server-side apply patch.
+	Field string
+
+	// Group sets the owner label key prefix.
+	Group string
+}
diff --git a/internal/ssa/testdata/test1.yaml b/internal/ssa/testdata/test1.yaml
new file mode 100644
index 00000000..f9c60b2a
--- /dev/null
+++ b/internal/ssa/testdata/test1.yaml
@@ -0,0 +1,53 @@
+apiVersion: v1
+kind: ServiceAccount
+metadata:
+  name: "%[1]s"
+  namespace: "%[1]s"
+---
+apiVersion: v1
+kind: Secret
+metadata:
+  name: "%[1]s"
+  namespace: "%[1]s"
+immutable: true
+stringData:
+  key: "private-key"
+---
+apiVersion: v1
+kind: ConfigMap
+metadata:
+  name: "%[1]s"
+  namespace: "%[1]s"
+data:
+  key: "public-key"
+---
+apiVersion: v1
+kind: Namespace
+metadata:
+  name: "%[1]s"
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: ClusterRole
+metadata:
+  name: "%[1]s"
+rules:
+  - apiGroups:
+      - apps
+    resources: ["*"]
+    verbs:
+      - get
+      - list
+      - watch
+---
+apiVersion: rbac.authorization.k8s.io/v1
+kind: ClusterRoleBinding
+metadata:
+  name: "%[1]s"
+roleRef:
+  apiGroup: rbac.authorization.k8s.io
+  kind: ClusterRole
+  name: "%[1]s"
+subjects:
+  - kind: ServiceAccount
+    name: "%[1]s"
+    namespace: "%[1]s"
