From 69069c3ab30d2de6150733d853de0b3f887ed9b1 Mon Sep 17 00:00:00 2001
From: Stefan Prodan <stefan.prodan@gmail.com>
Date: Sun, 12 Sep 2021 12:16:28 +0300
Subject: [PATCH] Refactor reconciliation into actions

Signed-off-by: Stefan Prodan <stefan.prodan@gmail.com>
---
 api/v1beta2/kustomization_types.go      |   2 +-
 controllers/kustomization_controller.go | 265 +++++++++++++-----------
 controllers/kustomization_wait_test.go  |  42 +++-
 controllers/suite_test.go               |  32 ++-
 4 files changed, 205 insertions(+), 136 deletions(-)

diff --git a/api/v1beta2/kustomization_types.go b/api/v1beta2/kustomization_types.go
index c1198380..54b52081 100644
--- a/api/v1beta2/kustomization_types.go
+++ b/api/v1beta2/kustomization_types.go
@@ -262,7 +262,7 @@ func KustomizationNotReady(k Kustomization, revision, reason, message string) Ku
 // KustomizationNotReadyInventory registers a failed apply attempt of the given Kustomization.
 func KustomizationNotReadyInventory(k Kustomization, inventory *Inventory, revision, reason, message string) Kustomization {
 	SetKustomizationReadiness(&k, metav1.ConditionFalse, reason, trimString(message, MaxConditionMessageLength), revision)
-	SetKustomizationHealthiness(&k, metav1.ConditionTrue, reason, reason)
+	SetKustomizationHealthiness(&k, metav1.ConditionFalse, reason, reason)
 	if revision != "" {
 		k.Status.LastAttemptedRevision = revision
 	}
diff --git a/controllers/kustomization_controller.go b/controllers/kustomization_controller.go
index 792efd45..cb8f98cb 100644
--- a/controllers/kustomization_controller.go
+++ b/controllers/kustomization_controller.go
@@ -274,7 +274,7 @@ func (r *KustomizationReconciler) reconcile(
 		kustomization.Status.SetLastHandledReconcileRequest(v)
 	}
 
-	log := logr.FromContext(ctx)
+	revision := source.GetArtifact().Revision
 
 	// create tmp dir
 	tmpDir, err := ioutil.TempDir("", kustomization.Name)
@@ -282,7 +282,7 @@ func (r *KustomizationReconciler) reconcile(
 		err = fmt.Errorf("tmp dir error: %w", err)
 		return kustomizev1.KustomizationNotReady(
 			kustomization,
-			source.GetArtifact().Revision,
+			revision,
 			sourcev1.StorageOperationFailedReason,
 			err.Error(),
 		), err
@@ -294,7 +294,7 @@ func (r *KustomizationReconciler) reconcile(
 	if err != nil {
 		return kustomizev1.KustomizationNotReady(
 			kustomization,
-			source.GetArtifact().Revision,
+			revision,
 			kustomizev1.ArtifactFailedReason,
 			err.Error(),
 		), err
@@ -305,7 +305,7 @@ func (r *KustomizationReconciler) reconcile(
 	if err != nil {
 		return kustomizev1.KustomizationNotReady(
 			kustomization,
-			source.GetArtifact().Revision,
+			revision,
 			kustomizev1.ArtifactFailedReason,
 			err.Error(),
 		), err
@@ -314,7 +314,7 @@ func (r *KustomizationReconciler) reconcile(
 		err = fmt.Errorf("kustomization path not found: %w", err)
 		return kustomizev1.KustomizationNotReady(
 			kustomization,
-			source.GetArtifact().Revision,
+			revision,
 			kustomizev1.ArtifactFailedReason,
 			err.Error(),
 		), err
@@ -326,7 +326,7 @@ func (r *KustomizationReconciler) reconcile(
 	if err != nil {
 		return kustomizev1.KustomizationNotReady(
 			kustomization,
-			source.GetArtifact().Revision,
+			revision,
 			meta.ReconciliationFailedReason,
 			err.Error(),
 		), fmt.Errorf("failed to build kube client: %w", err)
@@ -337,7 +337,7 @@ func (r *KustomizationReconciler) reconcile(
 	if err != nil {
 		return kustomizev1.KustomizationNotReady(
 			kustomization,
-			source.GetArtifact().Revision,
+			revision,
 			kustomizev1.BuildFailedReason,
 			err.Error(),
 		), err
@@ -348,7 +348,7 @@ func (r *KustomizationReconciler) reconcile(
 	if err != nil {
 		return kustomizev1.KustomizationNotReady(
 			kustomization,
-			source.GetArtifact().Revision,
+			revision,
 			kustomizev1.BuildFailedReason,
 			err.Error(),
 		), err
@@ -358,7 +358,7 @@ func (r *KustomizationReconciler) reconcile(
 	if err != nil {
 		return kustomizev1.KustomizationNotReady(
 			kustomization,
-			source.GetArtifact().Revision,
+			revision,
 			kustomizev1.BuildFailedReason,
 			err.Error(),
 		), err
@@ -376,7 +376,7 @@ func (r *KustomizationReconciler) reconcile(
 	if err != nil {
 		return kustomizev1.KustomizationNotReady(
 			kustomization,
-			source.GetArtifact().Revision,
+			revision,
 			kustomizev1.BuildFailedReason,
 			err.Error(),
 		), err
@@ -390,122 +390,41 @@ func (r *KustomizationReconciler) reconcile(
 		if err != nil {
 			return kustomizev1.KustomizationNotReady(
 				kustomization,
-				source.GetArtifact().Revision,
-				kustomizev1.BuildFailedReason,
-				err.Error(),
-			), err
-		}
-	}
-
-	// contains only CRDs and Namespaces
-	var stageOne []*unstructured.Unstructured
-
-	// contains all objects except for CRDs and Namespaces
-	var stageTwo []*unstructured.Unstructured
-
-	for _, u := range objects {
-		if resourceManager.IsClusterDefinition(u.GetKind()) {
-			stageOne = append(stageOne, u)
-		} else {
-			stageTwo = append(stageTwo, u)
-		}
-	}
-
-	var changeSetLog strings.Builder
-
-	// validate, apply and wait for CRDs and Namespaces to register
-	if len(stageOne) > 0 {
-		changeSet, err := resourceManager.ApplyAll(ctx, stageOne, kustomization.Spec.Force)
-		if err != nil {
-			return kustomizev1.KustomizationNotReady(
-				kustomization,
-				source.GetArtifact().Revision,
+				revision,
 				meta.ReconciliationFailedReason,
 				err.Error(),
 			), err
 		}
-
-		if changeSet != nil && len(changeSet.Entries) > 0 {
-			log.Info("server-side apply completed", "output", changeSet.ToMap())
-			for _, change := range changeSet.Entries {
-				if change.Action != string(ssa.UnchangedAction) {
-					changeSetLog.WriteString(change.String() + "\n")
-				}
-			}
-		}
-
-		if err := resourceManager.Wait(stageOne, 2*time.Second, kustomization.GetTimeout()); err != nil {
-			return kustomizev1.KustomizationNotReady(
-				kustomization,
-				source.GetArtifact().Revision,
-				meta.ReconciliationFailedReason,
-				err.Error(),
-			), err
-		}
-	}
-
-	// sort by kind, validate and apply all the others objects
-	sort.Sort(objectutil.SortableUnstructureds(stageTwo))
-	if len(stageTwo) > 0 {
-		changeSet, err := resourceManager.ApplyAll(ctx, stageTwo, kustomization.Spec.Force)
-		if err != nil {
-			return kustomizev1.KustomizationNotReady(
-				kustomization,
-				source.GetArtifact().Revision,
-				meta.ReconciliationFailedReason,
-				err.Error(),
-			), err
-		}
-
-		if changeSet != nil && len(changeSet.Entries) > 0 {
-			log.Info("server-side apply completed", "output", changeSet.ToMap())
-			for _, change := range changeSet.Entries {
-				if change.Action != string(ssa.UnchangedAction) {
-					changeSetLog.WriteString(change.String() + "\n")
-				}
-			}
-		}
 	}
 
-	// emit event only if the server-side apply resulted in changes
-	applyLog := strings.TrimSuffix(changeSetLog.String(), "\n")
-	if applyLog == "" {
-		log.Info("server-side apply dry-run completed: no drift detected")
-	} else {
-		r.event(ctx, kustomization, source.GetArtifact().Revision, events.EventSeverityInfo, applyLog, nil)
+	// validate and apply resources in stages
+	drifted, err := r.apply(ctx, resourceManager, kustomization, revision, objects)
+	if err != nil {
+		return kustomizev1.KustomizationNotReady(
+			kustomization,
+			revision,
+			meta.ReconciliationFailedReason,
+			err.Error(),
+		), err
 	}
 
 	// run garbage collection for stale objects that do not have pruning disabled
-	if kustomization.Spec.Prune {
-		changeSet, err := resourceManager.DeleteAll(ctx, staleObjects,
-			map[string]string{
-				fmt.Sprintf("%s/prune", kustomizev1.GroupVersion.Group): kustomizev1.DisabledValue,
-			},
-		)
-		if err != nil {
-			return kustomizev1.KustomizationNotReadyInventory(
-				kustomization,
-				newInventory,
-				source.GetArtifact().Revision,
-				kustomizev1.PruneFailedReason,
-				err.Error(),
-			), err
-		}
-
-		// emit event only if the prune operation resulted in changes
-		if changeSet != nil && len(changeSet.Entries) > 0 {
-			log.Info(fmt.Sprintf("garbage collection completed: %s", changeSet.String()))
-			r.event(ctx, kustomization, source.GetArtifact().Revision, events.EventSeverityInfo, changeSet.String(), nil)
-		}
+	if _, err := r.prune(ctx, resourceManager, kustomization, revision, staleObjects); err != nil {
+		return kustomizev1.KustomizationNotReadyInventory(
+			kustomization,
+			newInventory,
+			revision,
+			kustomizev1.PruneFailedReason,
+			err.Error(),
+		), err
 	}
 
 	// health assessment
-	err = r.checkHealth(ctx, resourceManager, kustomization, source.GetArtifact().Revision, applyLog != "")
-	if err != nil {
+	if err := r.checkHealth(ctx, resourceManager, kustomization, revision, drifted); err != nil {
 		return kustomizev1.KustomizationNotReadyInventory(
 			kustomization,
 			newInventory,
-			source.GetArtifact().Revision,
+			revision,
 			kustomizev1.HealthCheckFailedReason,
 			err.Error(),
 		), err
@@ -514,9 +433,9 @@ func (r *KustomizationReconciler) reconcile(
 	return kustomizev1.KustomizationReadyInventory(
 		kustomization,
 		newInventory,
-		source.GetArtifact().Revision,
+		revision,
 		meta.ReconciliationSucceededReason,
-		"Applied revision: "+source.GetArtifact().Revision,
+		fmt.Sprintf("Applied revision: %s", revision),
 	), nil
 }
 
@@ -683,38 +602,134 @@ func (r *KustomizationReconciler) build(ctx context.Context, kustomization kusto
 	return resources, nil
 }
 
-func (r *KustomizationReconciler) checkHealth(ctx context.Context, man *ssa.ResourceManager, kustomization kustomizev1.Kustomization, revision string, changed bool) error {
+func (r *KustomizationReconciler) apply(ctx context.Context, manager *ssa.ResourceManager, kustomization kustomizev1.Kustomization, revision string, objects []*unstructured.Unstructured) (bool, error) {
+	log := logr.FromContext(ctx)
+
+	// contains only CRDs and Namespaces
+	var stageOne []*unstructured.Unstructured
+
+	// contains all objects except for CRDs and Namespaces
+	var stageTwo []*unstructured.Unstructured
+
+	for _, u := range objects {
+		if manager.IsClusterDefinition(u.GetKind()) {
+			stageOne = append(stageOne, u)
+		} else {
+			stageTwo = append(stageTwo, u)
+		}
+	}
+
+	var changeSetLog strings.Builder
+
+	// validate, apply and wait for CRDs and Namespaces to register
+	if len(stageOne) > 0 {
+		changeSet, err := manager.ApplyAll(ctx, stageOne, kustomization.Spec.Force)
+		if err != nil {
+			return false, err
+		}
+
+		if changeSet != nil && len(changeSet.Entries) > 0 {
+			log.Info("server-side apply completed", "output", changeSet.ToMap())
+			for _, change := range changeSet.Entries {
+				if change.Action != string(ssa.UnchangedAction) {
+					changeSetLog.WriteString(change.String() + "\n")
+				}
+			}
+		}
+
+		if err := manager.Wait(stageOne, 2*time.Second, kustomization.GetTimeout()); err != nil {
+			return false, err
+		}
+	}
+
+	// sort by kind, validate and apply all the others objects
+	sort.Sort(objectutil.SortableUnstructureds(stageTwo))
+	if len(stageTwo) > 0 {
+		changeSet, err := manager.ApplyAll(ctx, stageTwo, kustomization.Spec.Force)
+		if err != nil {
+			return false, err
+		}
+
+		if changeSet != nil && len(changeSet.Entries) > 0 {
+			log.Info("server-side apply completed", "output", changeSet.ToMap())
+			for _, change := range changeSet.Entries {
+				if change.Action != string(ssa.UnchangedAction) {
+					changeSetLog.WriteString(change.String() + "\n")
+				}
+			}
+		}
+	}
+
+	// emit event only if the server-side apply resulted in changes
+	applyLog := strings.TrimSuffix(changeSetLog.String(), "\n")
+	if applyLog != "" {
+		r.event(ctx, kustomization, revision, events.EventSeverityInfo, applyLog, nil)
+	}
+
+	return applyLog != "", nil
+}
+
+func (r *KustomizationReconciler) checkHealth(ctx context.Context, manager *ssa.ResourceManager, kustomization kustomizev1.Kustomization, revision string, drifted bool) error {
 	if len(kustomization.Spec.HealthChecks) == 0 {
 		return nil
 	}
 
+	checkStart := time.Now()
 	objects, err := referenceToUnstructured(kustomization.Spec.HealthChecks)
 	if err != nil {
 		return err
 	}
 
+	// find the previous health check result
+	wasHealthy := apimeta.IsStatusConditionTrue(kustomization.Status.Conditions, kustomizev1.HealthyCondition)
+
 	// set the Healthy and Ready conditions to progressing
 	message := fmt.Sprintf("running health checks with a timeout of %d", kustomization.GetTimeout())
-	kustomization = kustomizev1.KustomizationProgressing(kustomization, message)
-	kustomizev1.SetKustomizationHealthiness(&kustomization, metav1.ConditionUnknown, meta.ProgressingReason, message)
-	if err := r.patchStatus(ctx, reconcile.Request{NamespacedName: client.ObjectKeyFromObject(&kustomization)}, kustomization.Status); err != nil {
-		return fmt.Errorf("unable to update status to progressing, error: %w", err)
+	k := kustomizev1.KustomizationProgressing(kustomization, message)
+	kustomizev1.SetKustomizationHealthiness(&k, metav1.ConditionUnknown, meta.ProgressingReason, message)
+	if err := r.patchStatus(ctx, reconcile.Request{NamespacedName: client.ObjectKeyFromObject(&kustomization)}, k.Status); err != nil {
+		return fmt.Errorf("unable to update the healthy status to progressing, error: %w", err)
 	}
 
 	// check the health with a default timeout of 30sec shorter than the reconciliation interval
-	if err := man.Wait(objects, time.Second, kustomization.GetTimeout()); err != nil {
-		return err
+	if err := manager.Wait(objects, time.Second, kustomization.GetTimeout()); err != nil {
+		return fmt.Errorf("Health check failed after %s, %w", time.Now().Sub(checkStart).String(), err)
 	}
 
-	// emit event if the previous health check result differs
-	healthiness := apimeta.FindStatusCondition(kustomization.Status.Conditions, kustomizev1.HealthyCondition)
-	healthy := healthiness != nil && healthiness.Status == metav1.ConditionTrue
-	if !healthy || (kustomization.Status.LastAppliedRevision != revision && changed) {
-		r.event(ctx, kustomization, revision, events.EventSeverityInfo, "Health check passed", nil)
+	// emit event if the previous health check failed
+	if !wasHealthy || (kustomization.Status.LastAppliedRevision != revision && drifted) {
+		r.event(ctx, kustomization, revision, events.EventSeverityInfo,
+			fmt.Sprintf("Health check passed in %s", time.Now().Sub(checkStart).String()), nil)
 	}
+
 	return nil
 }
 
+func (r *KustomizationReconciler) prune(ctx context.Context, manager *ssa.ResourceManager, kustomization kustomizev1.Kustomization, revision string, objects []*unstructured.Unstructured) (bool, error) {
+	if !kustomization.Spec.Prune {
+		return false, nil
+	}
+
+	log := logr.FromContext(ctx)
+	changeSet, err := manager.DeleteAll(ctx, objects,
+		map[string]string{
+			fmt.Sprintf("%s/prune", kustomizev1.GroupVersion.Group): kustomizev1.DisabledValue,
+		},
+	)
+	if err != nil {
+		return false, err
+	}
+
+	// emit event only if the prune operation resulted in changes
+	if changeSet != nil && len(changeSet.Entries) > 0 {
+		log.Info(fmt.Sprintf("garbage collection completed: %s", changeSet.String()))
+		r.event(ctx, kustomization, revision, events.EventSeverityInfo, changeSet.String(), nil)
+		return true, nil
+	}
+
+	return false, nil
+}
+
 func (r *KustomizationReconciler) finalize(ctx context.Context, kustomization kustomizev1.Kustomization) (ctrl.Result, error) {
 	log := logr.FromContext(ctx)
 	if kustomization.Spec.Prune && !kustomization.Spec.Suspend {
diff --git a/controllers/kustomization_wait_test.go b/controllers/kustomization_wait_test.go
index eaec26da..b779f83a 100644
--- a/controllers/kustomization_wait_test.go
+++ b/controllers/kustomization_wait_test.go
@@ -129,8 +129,12 @@ data:
 	})
 
 	t.Run("reports unhealthy status", func(t *testing.T) {
+		reconcileRequestAt := metav1.Now().String()
 		g.Eventually(func() error {
 			_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+			resultK.SetAnnotations(map[string]string{
+				meta.ReconcileRequestAnnotation: reconcileRequestAt,
+			})
 			resultK.Spec.HealthChecks = []meta.NamespacedObjectKindReference{
 				{
 					APIVersion: "v1",
@@ -148,7 +152,7 @@ data:
 			_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
 			readyCondition = apimeta.FindStatusCondition(resultK.Status.Conditions, meta.ReadyCondition)
 			healthyCondition = apimeta.FindStatusCondition(resultK.Status.Conditions, kustomizev1.HealthyCondition)
-			return readyCondition.Reason == meta.ProgressingReason
+			return healthyCondition.Reason == meta.ProgressingReason
 		}, timeout, time.Second).Should(BeTrue())
 
 		expectedMessage := "running health checks"
@@ -159,9 +163,15 @@ data:
 
 		g.Eventually(func() bool {
 			_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+			readyCondition = apimeta.FindStatusCondition(resultK.Status.Conditions, meta.ReadyCondition)
 			healthyCondition = apimeta.FindStatusCondition(resultK.Status.Conditions, kustomizev1.HealthyCondition)
 			return healthyCondition.Reason == kustomizev1.HealthCheckFailedReason
 		}, time.Minute, time.Second).Should(BeTrue())
+
+		g.Expect(resultK.Status.LastHandledReconcileAt).To(BeIdenticalTo(reconcileRequestAt))
+		g.Expect(readyCondition.Status).To(BeIdenticalTo(metav1.ConditionFalse))
+		g.Expect(healthyCondition.Status).To(BeIdenticalTo(metav1.ConditionFalse))
+		g.Expect(healthyCondition.Message).To(BeIdenticalTo(kustomizev1.HealthCheckFailedReason))
 	})
 
 	t.Run("emits unhealthy event", func(t *testing.T) {
@@ -170,4 +180,34 @@ data:
 		g.Expect(events[len(events)-1].Type).To(BeIdenticalTo("Warning"))
 		g.Expect(events[len(events)-1].Message).To(ContainSubstring("NotFound"))
 	})
+
+	t.Run("recovers and reports healthy status", func(t *testing.T) {
+		g.Eventually(func() error {
+			_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+			resultK.Spec.HealthChecks = []meta.NamespacedObjectKindReference{
+				{
+					APIVersion: "v1",
+					Kind:       "ConfigMap",
+					Name:       id,
+					Namespace:  id,
+				},
+			}
+			return k8sClient.Update(context.Background(), resultK)
+		}, timeout, time.Second).Should(BeNil())
+
+		g.Eventually(func() bool {
+			_ = k8sClient.Get(context.Background(), client.ObjectKeyFromObject(kustomization), resultK)
+			ready := apimeta.IsStatusConditionTrue(resultK.Status.Conditions, meta.ReadyCondition)
+			healthy := apimeta.IsStatusConditionTrue(resultK.Status.Conditions, kustomizev1.HealthyCondition)
+			return ready && healthy
+		}, timeout, time.Second).Should(BeTrue())
+	})
+
+	t.Run("emits recovery event", func(t *testing.T) {
+		expectedMessage := "Health check passed"
+		events := getEvents(resultK.GetName(), map[string]string{"kustomize.toolkit.fluxcd.io/revision": revision})
+		g.Expect(len(events) > 1).To(BeTrue())
+		g.Expect(events[len(events)-2].Type).To(BeIdenticalTo("Normal"))
+		g.Expect(events[len(events)-2].Message).To(ContainSubstring(expectedMessage))
+	})
 }
diff --git a/controllers/suite_test.go b/controllers/suite_test.go
index dea65b61..f6b6a1d2 100644
--- a/controllers/suite_test.go
+++ b/controllers/suite_test.go
@@ -27,6 +27,7 @@ import (
 	"os"
 	"path/filepath"
 	"strings"
+	"syscall"
 	"testing"
 	"time"
 
@@ -43,6 +44,8 @@ import (
 	ctrl "sigs.k8s.io/controller-runtime"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/envtest"
+	controllerLog "sigs.k8s.io/controller-runtime/pkg/log"
+	"sigs.k8s.io/controller-runtime/pkg/log/zap"
 )
 
 func init() {
@@ -64,6 +67,7 @@ var (
 	testMetricsH controller.Metrics
 	ctx          = ctrl.SetupSignalHandler()
 	kubeConfig   []byte
+	debugMode    = os.Getenv("DEBUG_TEST") != ""
 )
 
 // TODO: port this to github.com/fluxcd/pkg/runtime/testenv once testenv can generate kubeconfigs for admin users
@@ -72,6 +76,10 @@ func TestMain(m *testing.M) {
 	utilruntime.Must(sourcev1.AddToScheme(scheme.Scheme))
 	utilruntime.Must(kustomizev1.AddToScheme(scheme.Scheme))
 
+	if debugMode {
+		controllerLog.SetLogger(zap.New(zap.WriteTo(os.Stderr), zap.UseDevMode(false)))
+	}
+
 	testEnv = &envtest.Environment{
 		CRDDirectoryPaths: []string{filepath.Join("..", "config", "crd", "bases")},
 	}
@@ -107,12 +115,13 @@ func TestMain(m *testing.M) {
 
 	testEventsH = controller.MakeEvents(k8sManager, "kustomize-controller-test", nil)
 	testMetricsH = controller.MustMakeMetrics(k8sManager)
-
-	if err := (&KustomizationReconciler{
+	reconciler := &KustomizationReconciler{
 		Client:          k8sManager.GetClient(),
 		EventRecorder:   testEventsH.EventRecorder,
 		MetricsRecorder: testMetricsH.MetricsRecorder,
-	}).SetupWithManager(k8sManager, KustomizationReconcilerOptions{MaxConcurrentReconciles: 1}); err != nil {
+	}
+
+	if err := (reconciler).SetupWithManager(k8sManager, KustomizationReconcilerOptions{MaxConcurrentReconciles: 4}); err != nil {
 		panic(fmt.Sprintf("Failed to start GitRepositoryReconciler: %v", err))
 	}
 
@@ -126,14 +135,19 @@ func TestMain(m *testing.M) {
 
 	code := m.Run()
 
-	events := &corev1.EventList{}
-	_ = k8sClient.List(ctx, events)
-	for _, event := range events.Items {
-		fmt.Println(fmt.Sprintf("%s %s \n%s\n",
-			event.InvolvedObject.Name, event.GetAnnotations()["kustomize.toolkit.fluxcd.io/revision"],
-			event.Message))
+	if debugMode {
+		events := &corev1.EventList{}
+		_ = k8sClient.List(ctx, events)
+		for _, event := range events.Items {
+			fmt.Println(fmt.Sprintf("%s %s \n%s\n",
+				event.InvolvedObject.Name, event.GetAnnotations()["kustomize.toolkit.fluxcd.io/revision"],
+				event.Message))
+		}
 	}
 
+	fmt.Println("Stopping the controller")
+	syscall.Kill(syscall.Getpid(), syscall.SIGINT)
+
 	fmt.Println("Stopping the file server")
 	testServer.Stop()
 	if err := os.RemoveAll(testServer.Root()); err != nil {
