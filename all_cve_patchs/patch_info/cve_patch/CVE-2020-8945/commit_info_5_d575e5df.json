{
  "index": 5,
  "original_url": "https://github.com/proglottis/gpgme/commit/d575e5df6a8359a0ad12f59a8377d362c3eb6afd",
  "patch_url": "https://github.com/proglottis/gpgme/commit/d575e5df6a8359a0ad12f59a8377d362c3eb6afd.patch",
  "commit_info": {
    "type": "pr_commit",
    "hash": "d575e5df6a8359a0ad12f59a8377d362c3eb6afd",
    "url": "https://github.com/proglottis/gpgme/commit/d575e5df6a8359a0ad12f59a8377d362c3eb6afd",
    "pr_url": "https://github.com/proglottis/gpgme/pull/23",
    "pr_number": "23",
    "owner": "proglottis",
    "repo": "gpgme",
    "message": "Ensure Key is not dellocated while C code is still using it\n\nAs far as Go is concerned, Key.k is just a value, so it is\nOK to implement\n> cgo_call(k.k)\nas\n> tmp := k.k\n> dropReferenceTo(k)\n> // k's finalizer can be called at any point from now on, possibly deallocating k.k\n> cgo_call(tmp) // possibly using free memory\n\nTo fix this, explicitly extend the lifetime of Key:\n> cgo_call(k.k)\n> runtime.KeepAlive(k)\nbecomes\n> tmp := k.k\n> cgo_call(tmp) // k.k is certainly still valid\n> dropReferenceTo(k)\n> // k's finalizer can be called from now on, possibly deallocating k.k\n\nSigned-off-by: Miloslav Trmač <mitr@redhat.com>",
    "author": "Miloslav Trmač",
    "date": "2020-01-10T16:50:31Z"
  },
  "patch_stats": {
    "files_modified": 1,
    "lines_added": 65,
    "lines_removed": 23,
    "total_changes": 88,
    "file_list": [
      "gpgme.go"
    ],
    "file_extensions": [
      "go"
    ],
    "binary_files": 0
  }
}