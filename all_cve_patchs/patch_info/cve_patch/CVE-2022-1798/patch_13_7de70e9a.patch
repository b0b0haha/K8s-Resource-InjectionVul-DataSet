From 7de70e9a17eb0ce951a9ef05d526752aa2aeb88c Mon Sep 17 00:00:00 2001
From: Roman Mohr <rmohr@google.com>
Date: Tue, 19 Jul 2022 11:04:44 +0200
Subject: [PATCH] Move isolation detection code over to safepath

Signed-off-by: Roman Mohr <rmohr@google.com>
---
 pkg/virt-handler/isolation/BUILD.bazel        |  4 +
 pkg/virt-handler/isolation/detector_test.go   |  5 +-
 .../isolation/generated_mock_isolation.go     |  9 +-
 pkg/virt-handler/isolation/isolation.go       | 82 +++++++++++++------
 pkg/virt-handler/isolation/isolation_test.go  | 70 +++++++---------
 pkg/virt-handler/isolation/validation.go      | 11 ---
 6 files changed, 101 insertions(+), 80 deletions(-)

diff --git a/pkg/virt-handler/isolation/BUILD.bazel b/pkg/virt-handler/isolation/BUILD.bazel
index 09c01594aa7f..8f4d270fa29c 100644
--- a/pkg/virt-handler/isolation/BUILD.bazel
+++ b/pkg/virt-handler/isolation/BUILD.bazel
@@ -14,6 +14,8 @@ go_library(
     visibility = ["//visibility:public"],
     deps = [
         "//pkg/container-disk:go_default_library",
+        "//pkg/safepath:go_default_library",
+        "//pkg/unsafepath:go_default_library",
         "//pkg/util:go_default_library",
         "//pkg/virt-controller/services:go_default_library",
         "//pkg/virt-handler/cmd-client:go_default_library",
@@ -39,6 +41,8 @@ go_test(
     data = glob(["testdata/**"]),
     embed = [":go_default_library"],
     deps = [
+        "//pkg/safepath:go_default_library",
+        "//pkg/unsafepath:go_default_library",
         "//pkg/util:go_default_library",
         "//pkg/virt-handler/cmd-client:go_default_library",
         "//staging/src/kubevirt.io/api/core/v1:go_default_library",
diff --git a/pkg/virt-handler/isolation/detector_test.go b/pkg/virt-handler/isolation/detector_test.go
index a3f54e8d6568..ea27f6f1f35a 100644
--- a/pkg/virt-handler/isolation/detector_test.go
+++ b/pkg/virt-handler/isolation/detector_test.go
@@ -36,6 +36,7 @@ import (
 
 	v1 "kubevirt.io/api/core/v1"
 
+	"kubevirt.io/kubevirt/pkg/unsafepath"
 	cmdclient "kubevirt.io/kubevirt/pkg/virt-handler/cmd-client"
 )
 
@@ -114,7 +115,9 @@ var _ = Describe("Isolation Detector", func() {
 		It("Should detect the Mount root of the test suite", func() {
 			result, err := NewSocketBasedIsolationDetector(tmpDir).Allowlist([]string{"devices"}).Detect(vm)
 			Expect(err).ToNot(HaveOccurred())
-			Expect(result.MountRoot()).To(Equal(fmt.Sprintf("/proc/%d/root", os.Getpid())))
+			root, err := result.MountRoot()
+			Expect(err).ToNot(HaveOccurred())
+			Expect(unsafepath.UnsafeAbsolute(root.Raw())).To(Equal(fmt.Sprintf("/proc/%d/root", os.Getpid())))
 		})
 	})
 })
diff --git a/pkg/virt-handler/isolation/generated_mock_isolation.go b/pkg/virt-handler/isolation/generated_mock_isolation.go
index a97358648c89..0f788fe7185c 100644
--- a/pkg/virt-handler/isolation/generated_mock_isolation.go
+++ b/pkg/virt-handler/isolation/generated_mock_isolation.go
@@ -6,6 +6,8 @@ package isolation
 import (
 	gomock "github.com/golang/mock/gomock"
 	mountinfo "github.com/moby/sys/mountinfo"
+
+	safepath "kubevirt.io/kubevirt/pkg/safepath"
 )
 
 // Mock of IsolationResult interface
@@ -59,10 +61,11 @@ func (_mr *_MockIsolationResultRecorder) PIDNamespace() *gomock.Call {
 	return _mr.mock.ctrl.RecordCall(_mr.mock, "PIDNamespace")
 }
 
-func (_m *MockIsolationResult) MountRoot() string {
+func (_m *MockIsolationResult) MountRoot() (*safepath.Path, error) {
 	ret := _m.ctrl.Call(_m, "MountRoot")
-	ret0, _ := ret[0].(string)
-	return ret0
+	ret0, _ := ret[0].(*safepath.Path)
+	ret1, _ := ret[1].(error)
+	return ret0, ret1
 }
 
 func (_mr *_MockIsolationResultRecorder) MountRoot() *gomock.Call {
diff --git a/pkg/virt-handler/isolation/isolation.go b/pkg/virt-handler/isolation/isolation.go
index 8a910338fe19..e7434c5f5a08 100644
--- a/pkg/virt-handler/isolation/isolation.go
+++ b/pkg/virt-handler/isolation/isolation.go
@@ -28,12 +28,15 @@ package isolation
 import (
 	"fmt"
 	"os"
-	"path/filepath"
 	"sort"
 	"strings"
 
+	"kubevirt.io/kubevirt/pkg/unsafepath"
+
 	mount "github.com/moby/sys/mountinfo"
 
+	"kubevirt.io/kubevirt/pkg/safepath"
+
 	"kubevirt.io/client-go/log"
 
 	"kubevirt.io/kubevirt/pkg/util"
@@ -48,7 +51,7 @@ type IsolationResult interface {
 	// full path to the process namespace
 	PIDNamespace() string
 	// full path to the process root mount
-	MountRoot() string
+	MountRoot() (*safepath.Path, error)
 	// full path to the mount namespace
 	MountNamespace() string
 	// mounts for the process
@@ -72,27 +75,33 @@ func (r *RealIsolationResult) MountNamespace() string {
 	return fmt.Sprintf("/proc/%d/ns/mnt", r.pid)
 }
 
-// IsMounted checks if the given path is a mount point or not. Works with symlinks.
-func (r *RealIsolationResult) IsMounted(mountPoint string) (isMounted bool, err error) {
-	mountPoint, err = filepath.Abs(mountPoint)
+// IsMounted checks if the given path is a mount point or not.
+func IsMounted(mountPoint *safepath.Path) (isMounted bool, err error) {
+	// Ensure that the path is still a valid absolute path without symlinks
+	f, err := safepath.OpenAtNoFollow(mountPoint)
 	if err != nil {
-		return false, fmt.Errorf("failed to resolve %v to an absolute path: %v", mountPoint, err)
+		// treat os.IsNotExist() as error too
+		// since the inherent property of a safepath.Path is that the path must
+		// have existed at the point of object creation
+		return false, err
 	}
-	mountPoint, err = filepath.EvalSymlinks(mountPoint)
-	if err != nil {
-		if os.IsNotExist(err) {
-			return false, nil
-		}
-		return false, fmt.Errorf("could not resolve symlinks in path %v: %v", mountPoint, err)
+	defer f.Close()
+	if mountPoint.IsRoot() {
+		// mount.Mounted has purely string matching based special logic on how to treat "/".
+		// Emulating this for safepath here without ever having to call an unsafe method on our
+		// safepath.
+		return true, nil
+	} else {
+		// TODO: Unsafe full path is required, and not a fd, since otherwise mount table lookups and such would not work.
+		return mount.Mounted(unsafepath.UnsafeAbsolute(mountPoint.Raw()))
 	}
-	return mount.Mounted(mountPoint)
 }
 
 // AreMounted checks if given paths are mounted by calling IsMounted.
 // If error occurs, the first error is returned.
-func (r *RealIsolationResult) AreMounted(mountPoints ...string) (isMounted bool, err error) {
+func (r *RealIsolationResult) AreMounted(mountPoints ...*safepath.Path) (isMounted bool, err error) {
 	for _, mountPoint := range mountPoints {
-		isMounted, err = r.IsMounted(mountPoint)
+		isMounted, err = IsMounted(mountPoint)
 		if !isMounted || err != nil {
 			return
 		}
@@ -102,19 +111,27 @@ func (r *RealIsolationResult) AreMounted(mountPoints ...string) (isMounted bool,
 }
 
 // IsBlockDevice checks if the given path is a block device or not.
-func (r *RealIsolationResult) IsBlockDevice(path string) (bool, error) {
-	fileInfo, err := os.Stat(path)
+func IsBlockDevice(path *safepath.Path) (bool, error) {
+	fileInfo, err := safepath.StatAtNoFollow(path)
 	if err != nil {
 		return false, fmt.Errorf("error checking for block device: %v", err)
 	}
 	if fileInfo.IsDir() || (fileInfo.Mode()&os.ModeDevice) == 0 {
-		return false, fmt.Errorf("found %v, but it's not a block device", path)
+		return false, nil
 	}
 	return true, nil
 }
 
-func (r *RealIsolationResult) MountRoot() string {
-	return fmt.Sprintf("/proc/%d/root", r.pid)
+func (r *RealIsolationResult) MountRoot() (*safepath.Path, error) {
+	return safepath.JoinAndResolveWithRelativeRoot(fmt.Sprintf("/proc/%d/root", r.pid))
+}
+
+func (r *RealIsolationResult) MountRootRelative(relativePath string) (*safepath.Path, error) {
+	mountRoot, err := r.MountRoot()
+	if err != nil {
+		return nil, err
+	}
+	return mountRoot.AppendAndResolveWithRelativeRoot(relativePath)
 }
 
 func (r *RealIsolationResult) Pid() int {
@@ -178,14 +195,31 @@ func parentMountInfoFor(parent IsolationResult, mountInfo *mount.Info) (*mount.I
 
 // ParentPathForRootMount takes a container (child) and composes a path to
 // the root mount point in the context of the parent.
-func ParentPathForRootMount(parent IsolationResult, child IsolationResult) (string, error) {
+func ParentPathForRootMount(parent IsolationResult, child IsolationResult) (*safepath.Path, error) {
 	childRootMountInfo, err := MountInfoRoot(child)
 	if err != nil {
-		return "", err
+		return nil, err
 	}
 	parentMountInfo, err := parentMountInfoFor(parent, childRootMountInfo)
 	if err != nil {
-		return "", err
+		return nil, err
+	}
+	parentMountRoot, err := parent.MountRoot()
+	if err != nil {
+		return nil, err
+	}
+	path := parentMountRoot
+	path, err = path.AppendAndResolveWithRelativeRoot(parentMountInfo.Mountpoint)
+	if err != nil {
+		return nil, err
+	}
+	return path.AppendAndResolveWithRelativeRoot(strings.TrimPrefix(childRootMountInfo.Root, parentMountInfo.Root))
+}
+
+func SafeJoin(res IsolationResult, elems ...string) (*safepath.Path, error) {
+	mountRoot, err := res.MountRoot()
+	if err != nil {
+		return nil, err
 	}
-	return filepath.Join(parent.MountRoot(), parentMountInfo.Mountpoint, strings.TrimPrefix(childRootMountInfo.Root, parentMountInfo.Root)), nil
+	return mountRoot.AppendAndResolveWithRelativeRoot(elems...)
 }
diff --git a/pkg/virt-handler/isolation/isolation_test.go b/pkg/virt-handler/isolation/isolation_test.go
index 34005404773e..6e15311f7eec 100644
--- a/pkg/virt-handler/isolation/isolation_test.go
+++ b/pkg/virt-handler/isolation/isolation_test.go
@@ -2,7 +2,6 @@ package isolation
 
 import (
 	"fmt"
-	"io/ioutil"
 	"os"
 	"path/filepath"
 
@@ -11,6 +10,9 @@ import (
 	. "github.com/onsi/ginkgo/v2"
 	. "github.com/onsi/gomega"
 
+	"kubevirt.io/kubevirt/pkg/safepath"
+	"kubevirt.io/kubevirt/pkg/unsafepath"
+
 	"kubevirt.io/kubevirt/pkg/util"
 )
 
@@ -27,41 +29,12 @@ var _ = Describe("IsolationResult", func() {
 		})
 
 		It("Should have root mounted", func() {
-			mounted, err := isolationResult.IsMounted("/")
+			root, err := safepath.NewPathNoFollow("/")
 			Expect(err).ToNot(HaveOccurred())
-			Expect(mounted).To(BeTrue())
-		})
-
-		It("Should resolve absolute paths with relative navigation", func() {
-			mounted, err := isolationResult.IsMounted("/var/..")
+			mounted, err := IsMounted(root)
 			Expect(err).ToNot(HaveOccurred())
 			Expect(mounted).To(BeTrue())
 		})
-
-		It("Should resolve relative paths", func() {
-			_, err := isolationResult.IsMounted(".")
-			Expect(err).ToNot(HaveOccurred())
-		})
-
-		It("Should resolve symlinks", func() {
-			tmpDir, err := ioutil.TempDir("", "kubevirt")
-			Expect(err).ToNot(HaveOccurred())
-			defer os.RemoveAll(tmpDir)
-
-			symlinkPath := filepath.Join(tmpDir, "mysymlink")
-			err = os.Symlink("/", symlinkPath)
-			Expect(err).ToNot(HaveOccurred())
-
-			mounted, err := isolationResult.IsMounted(symlinkPath)
-			Expect(err).ToNot(HaveOccurred())
-			Expect(mounted).To(BeTrue())
-		})
-
-		It("Should regard a non-existent path as not mounted, not as an error", func() {
-			mounted, err := isolationResult.IsMounted("/aasdfjhk")
-			Expect(err).ToNot(HaveOccurred())
-			Expect(mounted).To(BeFalse())
-		})
 	})
 
 	Context("Container IsolationResult", func() {
@@ -80,9 +53,13 @@ var _ = Describe("IsolationResult", func() {
 		var ctrl *gomock.Controller
 		var mockIsolationResultNode *MockIsolationResult
 		var mockIsolationResultContainer *MockIsolationResult
+		var tmpDir string
 
 		BeforeEach(func() {
 			ctrl = gomock.NewController(GinkgoT())
+			tmpDir = GinkgoT().TempDir()
+			root, err := safepath.JoinAndResolveWithRelativeRoot(filepath.Join("/proc/self/root", tmpDir))
+			Expect(err).ToNot(HaveOccurred())
 
 			mockIsolationResultNode = NewMockIsolationResult(ctrl)
 			mockIsolationResultNode.EXPECT().
@@ -91,7 +68,7 @@ var _ = Describe("IsolationResult", func() {
 				AnyTimes()
 			mockIsolationResultNode.EXPECT().
 				MountRoot().
-				Return("/proc/1/root").
+				Return(root, nil).
 				AnyTimes()
 
 			mockIsolationResultContainer = NewMockIsolationResult(ctrl)
@@ -115,17 +92,17 @@ var _ = Describe("IsolationResult", func() {
 					mountDriver:              "overlay",
 					hostMountInfoFile:        "overlay_host",
 					launcherMountInfoFile:    "overlay_launcher",
-					expectedPathToRootOnNode: "/proc/1/root/var/lib/docker/overlay2/f15d9ce07df72e80d809aa99ab4a171f2f3636f65f0653e75db8ca0befd8ae02/merged",
+					expectedPathToRootOnNode: "/var/lib/docker/overlay2/f15d9ce07df72e80d809aa99ab4a171f2f3636f65f0653e75db8ca0befd8ae02/merged",
 				}, {
 					mountDriver:              "devicemapper",
 					hostMountInfoFile:        "devicemapper_host",
 					launcherMountInfoFile:    "devicemapper_launcher",
-					expectedPathToRootOnNode: "/proc/1/root/var/lib/docker/devicemapper/mnt/d0990551ba8254871a449b2ff0d9063061ae96a2c195d7a850b62f030eae1710/rootfs",
+					expectedPathToRootOnNode: "/var/lib/docker/devicemapper/mnt/d0990551ba8254871a449b2ff0d9063061ae96a2c195d7a850b62f030eae1710/rootfs",
 				}, {
 					mountDriver:              "btrfs",
 					hostMountInfoFile:        "btrfs_host",
 					launcherMountInfoFile:    "btrfs_launcher",
-					expectedPathToRootOnNode: "/proc/1/root/var/lib/containers/storage/btrfs/subvolumes/e9a94e2cde75c54834378d4835d4eda6bebb56b02068b9254780de6f9344ad0e",
+					expectedPathToRootOnNode: "/var/lib/containers/storage/btrfs/subvolumes/e9a94e2cde75c54834378d4835d4eda6bebb56b02068b9254780de6f9344ad0e",
 				},
 			}
 
@@ -144,6 +121,7 @@ var _ = Describe("IsolationResult", func() {
 				Context(fmt.Sprintf("Using storage driver %v", dataset.mountDriver), func() {
 
 					BeforeEach(func() {
+						Expect(os.MkdirAll(filepath.Join(tmpDir, dataset.expectedPathToRootOnNode), os.ModePerm)).To(Succeed())
 						mockIsolationResultNode.EXPECT().
 							Mounts(gomock.Any()).
 							DoAndReturn(func(f mount.FilterFunc) ([]*mount.Info, error) {
@@ -168,7 +146,7 @@ var _ = Describe("IsolationResult", func() {
 					It("Should detect the full path to the root mount point of a container on the node", func() {
 						path, err := ParentPathForRootMount(mockIsolationResultNode, mockIsolationResultContainer)
 						Expect(err).ToNot(HaveOccurred())
-						Expect(path).To(Equal(dataset.expectedPathToRootOnNode))
+						Expect(unsafepath.UnsafeAbsolute(path.Raw())).To(Equal(filepath.Join("/proc/self/root", tmpDir, dataset.expectedPathToRootOnNode)))
 					})
 				})
 			}
@@ -219,6 +197,9 @@ var _ = Describe("IsolationResult", func() {
 			})
 
 			It("Should match the correct device", func() {
+				Expect(os.MkdirAll(filepath.Join(tmpDir, "/12"), os.ModePerm)).To(Succeed())
+				Expect(os.MkdirAll(filepath.Join(tmpDir, "/21"), os.ModePerm)).To(Succeed())
+				Expect(os.MkdirAll(filepath.Join(tmpDir, "/11"), os.ModePerm)).To(Succeed())
 				initMountsMock(mockIsolationResultContainer, []*mount.Info{rootMountPoint})
 				initMountsMock(mockIsolationResultNode, []*mount.Info{
 					{
@@ -241,10 +222,12 @@ var _ = Describe("IsolationResult", func() {
 
 				path, err := ParentPathForRootMount(mockIsolationResultNode, mockIsolationResultContainer)
 				Expect(err).ToNot(HaveOccurred())
-				Expect(path).To(Equal("/proc/1/root/11"))
+				Expect(unsafepath.UnsafeAbsolute(path.Raw())).To(Equal(filepath.Join("/proc/self/root", tmpDir, "/11")))
 			})
 
 			It("Should construct a valid path when the node mountpoint does not match the filesystem path", func() {
+				Expect(os.MkdirAll(filepath.Join(tmpDir, "/some/path"), os.ModePerm)).To(Succeed())
+				Expect(os.MkdirAll(filepath.Join(tmpDir, "/other/location"), os.ModePerm)).To(Succeed())
 				initMountsMock(mockIsolationResultContainer, []*mount.Info{
 					{
 						Major:      1,
@@ -264,10 +247,12 @@ var _ = Describe("IsolationResult", func() {
 
 				path, err := ParentPathForRootMount(mockIsolationResultNode, mockIsolationResultContainer)
 				Expect(err).ToNot(HaveOccurred())
-				Expect(path).To(Equal("/proc/1/root/other/location"))
+				Expect(unsafepath.UnsafeAbsolute(path.Raw())).To(Equal(filepath.Join("/proc/self/root", tmpDir, "/other/location")))
 			})
 
 			It("Should find the longest match for a filesystem path", func() {
+				Expect(os.MkdirAll(filepath.Join(tmpDir, "/some/path/quite/deeply/located/on/the/filesystem"), os.ModePerm)).To(Succeed())
+				Expect(os.MkdirAll(filepath.Join(tmpDir, "/long/filesystem"), os.ModePerm)).To(Succeed())
 				initMountsMock(mockIsolationResultContainer, []*mount.Info{
 					{
 						Major:      1,
@@ -297,7 +282,7 @@ var _ = Describe("IsolationResult", func() {
 
 				path, err := ParentPathForRootMount(mockIsolationResultNode, mockIsolationResultContainer)
 				Expect(err).ToNot(HaveOccurred())
-				Expect(path).To(Equal("/proc/1/root/long/filesystem"))
+				Expect(unsafepath.UnsafeAbsolute(path.Raw())).To(Equal(filepath.Join("/proc/self/root/", tmpDir, "long/filesystem")))
 			})
 
 			It("Should fail when the device does not exist", func() {
@@ -316,6 +301,7 @@ var _ = Describe("IsolationResult", func() {
 			})
 
 			It("Should fail if the target filesystem path is not mounted", func() {
+				Expect(os.MkdirAll(filepath.Join(tmpDir, "/other/path"), os.ModePerm)).To(Succeed())
 				initMountsMock(mockIsolationResultContainer, []*mount.Info{rootMountPoint})
 				initMountsMock(mockIsolationResultNode, []*mount.Info{
 					{
@@ -331,6 +317,8 @@ var _ = Describe("IsolationResult", func() {
 			})
 
 			It("Should not fail for duplicate mountpoints", func() {
+				Expect(os.MkdirAll(filepath.Join(tmpDir, "/mymounts/first"), os.ModePerm)).To(Succeed())
+				Expect(os.MkdirAll(filepath.Join(tmpDir, "/mymounts/second"), os.ModePerm)).To(Succeed())
 				initMountsMock(mockIsolationResultContainer, []*mount.Info{rootMountPoint})
 
 				initMountsMock(mockIsolationResultNode, []*mount.Info{
@@ -349,7 +337,7 @@ var _ = Describe("IsolationResult", func() {
 
 				path, err := ParentPathForRootMount(mockIsolationResultNode, mockIsolationResultContainer)
 				Expect(err).ToNot(HaveOccurred())
-				Expect(path).To(HavePrefix("/proc/1/root/mymounts/"))
+				Expect(unsafepath.UnsafeAbsolute(path.Raw())).To(HavePrefix(filepath.Join("/proc/self/root", tmpDir, "/mymounts/")))
 			})
 		})
 	})
diff --git a/pkg/virt-handler/isolation/validation.go b/pkg/virt-handler/isolation/validation.go
index 47cce570ef5f..7c2728c848d4 100644
--- a/pkg/virt-handler/isolation/validation.go
+++ b/pkg/virt-handler/isolation/validation.go
@@ -3,9 +3,7 @@ package isolation
 import (
 	"encoding/json"
 	"fmt"
-	"os"
 	"os/exec"
-	"path/filepath"
 
 	v1 "kubevirt.io/api/core/v1"
 	"kubevirt.io/client-go/log"
@@ -45,12 +43,3 @@ func GetImageInfo(imagePath string, context IsolationResult, config *v1.DiskVeri
 	}
 	return info, err
 }
-
-func GetFileSize(imagePath string, context IsolationResult) (int64, error) {
-	path := filepath.Join(context.MountRoot(), imagePath)
-	info, err := os.Stat(path)
-	if err != nil {
-		return -1, err
-	}
-	return info.Size(), nil
-}
