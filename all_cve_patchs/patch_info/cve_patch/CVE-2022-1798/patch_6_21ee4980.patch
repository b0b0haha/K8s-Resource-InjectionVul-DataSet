From 21ee498079cfee9cacc646ac91340a3384e60ce2 Mon Sep 17 00:00:00 2001
From: Roman Mohr <rmohr@google.com>
Date: Tue, 19 Jul 2022 11:19:45 +0200
Subject: [PATCH] Move virt-chroot over to safepath usage

Pass fully resolved paths to virt-chroot and ensure that virt-chroot
will re-create safepath.Paths out of the input before trying to use it,
to ensure no path escapes.

Signed-off-by: Roman Mohr <rmohr@google.com>
---
 cmd/virt-chroot/BUILD.bazel                 |  1 +
 cmd/virt-chroot/main.go                     | 40 +++++++++++++++++++--
 cmd/virt-chroot/selinux.go                  | 40 +++++++++++++++++++--
 pkg/virt-handler/selinux/BUILD.bazel        |  2 ++
 pkg/virt-handler/selinux/labels.go          |  6 ++--
 pkg/virt-handler/virt-chroot/BUILD.bazel    |  4 +++
 pkg/virt-handler/virt-chroot/virt-chroot.go | 28 +++++++++++++--
 7 files changed, 111 insertions(+), 10 deletions(-)

diff --git a/cmd/virt-chroot/BUILD.bazel b/cmd/virt-chroot/BUILD.bazel
index 29cdc81b31fb..fd26041a0e84 100644
--- a/cmd/virt-chroot/BUILD.bazel
+++ b/cmd/virt-chroot/BUILD.bazel
@@ -12,6 +12,7 @@ go_library(
     importpath = "kubevirt.io/kubevirt/cmd/virt-chroot",
     visibility = ["//visibility:private"],
     deps = [
+        "//pkg/safepath:go_default_library",
         "//pkg/virt-handler/cgroup:go_default_library",
         "//vendor/github.com/opencontainers/runc/libcontainer/cgroups/fs:go_default_library",
         "//vendor/github.com/opencontainers/runc/libcontainer/cgroups/fs2:go_default_library",
diff --git a/cmd/virt-chroot/main.go b/cmd/virt-chroot/main.go
index e934420a29c4..e28daa07c78c 100644
--- a/cmd/virt-chroot/main.go
+++ b/cmd/virt-chroot/main.go
@@ -11,6 +11,8 @@ import (
 
 	"github.com/spf13/cobra"
 	"golang.org/x/sys/unix"
+
+	"kubevirt.io/kubevirt/pkg/safepath"
 )
 
 var (
@@ -149,7 +151,25 @@ func main() {
 				}
 			}
 
-			return syscall.Mount(args[0], args[1], fsType, uintptr(mntOpts), "")
+			// Ensure that sourceFile is a real path. It will be kept open until used
+			// by the syscall via the file descriptor path in proc (SafePath) to ensure
+			// that no symlink injection can happen after the check.
+			sourceFile, err := safepath.NewFileNoFollow(args[0])
+			if err != nil {
+				return fmt.Errorf("mount source invalid: %v", err)
+			}
+			defer sourceFile.Close()
+
+			// Ensure that targetFile is a real path. It will be kept open until used
+			// by the syscall via the file descriptor path in proc (SafePath) to ensure
+			// that no symlink injection can happen after the check.
+			targetFile, err := safepath.NewFileNoFollow(args[1])
+			if err != nil {
+				return fmt.Errorf("mount target invalid: %v", err)
+			}
+			defer targetFile.Close()
+
+			return syscall.Mount(sourceFile.SafePath(), targetFile.SafePath(), fsType, uintptr(mntOpts), "")
 		},
 	}
 	mntCmd.Flags().StringP("options", "o", "", "comma separated list of mount options")
@@ -160,7 +180,23 @@ func main() {
 		Short: "unmount in a specific mount namespace",
 		Args:  cobra.MinimumNArgs(1),
 		RunE: func(cmd *cobra.Command, args []string) error {
-			return syscall.Unmount(args[0], 0)
+			// Ensure that targetFile is a real path. It will be kept open until used
+			// by the syscall via the file descriptor path in proc (SafePath) to ensure
+			// that no symlink injection can happen after the check.
+			targetFile, err := safepath.NewPathNoFollow(args[0])
+			if err != nil {
+				return fmt.Errorf("mount target invalid: %v", err)
+			}
+			err = targetFile.ExecuteNoFollow(func(safePath string) error {
+				// we actively hold an open reference to the mount point,
+				// we have to lazy unmount, to not block ourselves
+				// with the active file-descriptor.
+				return syscall.Unmount(safePath, unix.MNT_DETACH)
+			})
+			if err != nil {
+				return fmt.Errorf("umount failed: %v", err)
+			}
+			return nil
 		},
 	}
 
diff --git a/cmd/virt-chroot/selinux.go b/cmd/virt-chroot/selinux.go
index af9174c1a20e..29cc03712ed0 100644
--- a/cmd/virt-chroot/selinux.go
+++ b/cmd/virt-chroot/selinux.go
@@ -4,11 +4,20 @@ import (
 	"bytes"
 	"fmt"
 	"io/ioutil"
+	"os"
+	"path/filepath"
 
 	"github.com/opencontainers/selinux/go-selinux"
 	"github.com/spf13/cobra"
+	"golang.org/x/sys/unix"
+
+	"kubevirt.io/kubevirt/pkg/safepath"
 )
 
+const xattrNameSelinux = "security.selinux"
+
+var root string
+
 // NewGetEnforceCommand determines if selinux is enabled in the kernel (enforced or permissive)
 func NewGetEnforceCommand() *cobra.Command {
 	cmd := &cobra.Command{
@@ -31,7 +40,7 @@ func NewGetEnforceCommand() *cobra.Command {
 }
 
 func RelabelCommand() *cobra.Command {
-	return &cobra.Command{
+	relabelCommad := &cobra.Command{
 		Use:       "relabel",
 		Short:     "relabel a file with the given selinux label, if the path is not labeled like this already",
 		Example:   "virt-chroot selinux relabel <new-label> <file-path>",
@@ -39,15 +48,38 @@ func RelabelCommand() *cobra.Command {
 		Args:      cobra.ExactArgs(2),
 		RunE: func(cmd *cobra.Command, args []string) error {
 			label := args[0]
-			filePath := args[1]
+			if root == "" {
+				root = "/"
+			}
+
+			rootPath, err := safepath.JoinAndResolveWithRelativeRoot(root)
+			if err != nil {
+				return fmt.Errorf("failed to open root path %v: %v", rootPath, err)
+			}
+			safePath, err := safepath.JoinNoFollow(rootPath, args[1])
+			if err != nil {
+				return fmt.Errorf("failed to open final path %v: %v", filepath.Join(root, args[1]), err)
+			}
+			fd, err := safepath.OpenAtNoFollow(safePath)
+			if err != nil {
+				return fmt.Errorf("could not open file %v. Reason: %v", safePath, err)
+			}
 
+			defer fd.Close()
+			filePath := fd.SafePath()
 			currentFileLabel, err := selinux.FileLabel(filePath)
 			if err != nil {
 				return fmt.Errorf("could not retrieve label of file %s. Reason: %v", filePath, err)
 			}
 
+			writeableFD, err := os.OpenFile(filePath, os.O_APPEND|unix.S_IWRITE, os.ModePerm)
+			if err != nil {
+				return fmt.Errorf("error reopening file %s to write label %s. Reason: %v", filePath, label, err)
+			}
+			defer writeableFD.Close()
+
 			if currentFileLabel != label {
-				if err := selinux.Chcon(filePath, label, false); err != nil {
+				if err := unix.Fsetxattr(int(writeableFD.Fd()), xattrNameSelinux, []byte(label), 0); err != nil {
 					return fmt.Errorf("error relabeling file %s with label %s. Reason: %v", filePath, label, err)
 				}
 			}
@@ -55,4 +87,6 @@ func RelabelCommand() *cobra.Command {
 			return nil
 		},
 	}
+	relabelCommad.Flags().StringVar(&root, "root", "/", "safe root path which will be prepended to passed in files")
+	return relabelCommad
 }
diff --git a/pkg/virt-handler/selinux/BUILD.bazel b/pkg/virt-handler/selinux/BUILD.bazel
index e7c0fd083663..3872f4e3f0a0 100644
--- a/pkg/virt-handler/selinux/BUILD.bazel
+++ b/pkg/virt-handler/selinux/BUILD.bazel
@@ -11,6 +11,8 @@ go_library(
     importpath = "kubevirt.io/kubevirt/pkg/virt-handler/selinux",
     visibility = ["//visibility:public"],
     deps = [
+        "//pkg/safepath:go_default_library",
+        "//pkg/unsafepath:go_default_library",
         "//pkg/virt-handler/virt-chroot:go_default_library",
         "//staging/src/kubevirt.io/client-go/log:go_default_library",
         "//vendor/github.com/golang/mock/gomock:go_default_library",
diff --git a/pkg/virt-handler/selinux/labels.go b/pkg/virt-handler/selinux/labels.go
index 01f17db26a8f..36c02e066098 100644
--- a/pkg/virt-handler/selinux/labels.go
+++ b/pkg/virt-handler/selinux/labels.go
@@ -8,6 +8,8 @@ import (
 	"path/filepath"
 	"strings"
 
+	"kubevirt.io/kubevirt/pkg/safepath"
+	"kubevirt.io/kubevirt/pkg/unsafepath"
 	virt_chroot "kubevirt.io/kubevirt/pkg/virt-handler/virt-chroot"
 
 	"kubevirt.io/client-go/log"
@@ -164,10 +166,10 @@ type SELinux interface {
 	IsPermissive() bool
 }
 
-func RelabelFiles(newLabel string, continueOnError bool, files ...string) error {
+func RelabelFiles(newLabel string, continueOnError bool, files ...*safepath.Path) error {
 	relabelArgs := []string{"selinux", "relabel", newLabel}
 	for _, file := range files {
-		cmd := exec.Command("virt-chroot", append(relabelArgs, file)...)
+		cmd := exec.Command("virt-chroot", append(relabelArgs, "--root", unsafepath.UnsafeRoot(file.Raw()), unsafepath.UnsafeRelative(file.Raw()))...)
 		cmd.Stdout = os.Stdout
 		cmd.Stderr = os.Stderr
 		err := cmd.Run()
diff --git a/pkg/virt-handler/virt-chroot/BUILD.bazel b/pkg/virt-handler/virt-chroot/BUILD.bazel
index 776719e08fa6..1c59d345cc43 100644
--- a/pkg/virt-handler/virt-chroot/BUILD.bazel
+++ b/pkg/virt-handler/virt-chroot/BUILD.bazel
@@ -5,4 +5,8 @@ go_library(
     srcs = ["virt-chroot.go"],
     importpath = "kubevirt.io/kubevirt/pkg/virt-handler/virt-chroot",
     visibility = ["//visibility:public"],
+    deps = [
+        "//pkg/safepath:go_default_library",
+        "//pkg/unsafepath:go_default_library",
+    ],
 )
diff --git a/pkg/virt-handler/virt-chroot/virt-chroot.go b/pkg/virt-handler/virt-chroot/virt-chroot.go
index e00dbc54d793..4160212b7b44 100644
--- a/pkg/virt-handler/virt-chroot/virt-chroot.go
+++ b/pkg/virt-handler/virt-chroot/virt-chroot.go
@@ -19,7 +19,13 @@
 
 package virt_chroot
 
-import "os/exec"
+import (
+	"os/exec"
+	"strings"
+
+	"kubevirt.io/kubevirt/pkg/safepath"
+	"kubevirt.io/kubevirt/pkg/unsafepath"
+)
 
 const (
 	binaryPath     = "/usr/bin/virt-chroot"
@@ -38,7 +44,13 @@ func GetChrootMountNamespace() string {
 	return mountNamespace
 }
 
-func MountChroot(sourcePath, targetPath string, ro bool) *exec.Cmd {
+func MountChroot(sourcePath, targetPath *safepath.Path, ro bool) *exec.Cmd {
+	return UnsafeMountChroot(trimProcPrefix(sourcePath), trimProcPrefix(targetPath), ro)
+}
+
+// Deprecated: UnsafeMountChroot is used to connect to code which needs to be refactored
+// to handle mounts securely.
+func UnsafeMountChroot(sourcePath, targetPath string, ro bool) *exec.Cmd {
 	args := append(getBaseArgs(), "mount", "-o")
 	optionArgs := "bind"
 
@@ -50,7 +62,13 @@ func MountChroot(sourcePath, targetPath string, ro bool) *exec.Cmd {
 	return exec.Command(binaryPath, args...)
 }
 
-func UmountChroot(path string) *exec.Cmd {
+func UmountChroot(path *safepath.Path) *exec.Cmd {
+	return UnsafeUmountChroot(trimProcPrefix(path))
+}
+
+// Deprecated: UnsafeUmountChroot is used to connect to code which needs to be refactored
+// to handle mounts securely.
+func UnsafeUmountChroot(path string) *exec.Cmd {
 	args := append(getBaseArgs(), "umount", path)
 	return exec.Command(binaryPath, args...)
 }
@@ -71,3 +89,7 @@ func RemoveMDEVType(mdevUUID string) *exec.Cmd {
 func ExecChroot(args ...string) *exec.Cmd {
 	return exec.Command(binaryPath, args...)
 }
+
+func trimProcPrefix(path *safepath.Path) string {
+	return strings.TrimPrefix(unsafepath.UnsafeAbsolute(path.Raw()), "/proc/1/root")
+}
