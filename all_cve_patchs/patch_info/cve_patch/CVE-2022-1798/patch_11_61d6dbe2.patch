From 61d6dbe24d2808fa5c55ea0d83096c36729d91f9 Mon Sep 17 00:00:00 2001
From: Roman Mohr <rmohr@google.com>
Date: Tue, 19 Jul 2022 11:22:33 +0200
Subject: [PATCH] Don't change selinux labels on hostDisk mounts

When virt-launcher runs in non-root mode, don't change selinux labels on
the target disk to be accessible for the user. This task should be
performed as a preparation step by admins on selinux enabled nodes which
"allow" this path to be accessed by VMIs.

This way we avoid working against the selinux security intent.

Signed-off-by: Roman Mohr <rmohr@google.com>
---
 pkg/virt-handler/BUILD.bazel |  1 +
 pkg/virt-handler/non-root.go | 85 ++++++++++++++++++++++++------------
 2 files changed, 58 insertions(+), 28 deletions(-)

diff --git a/pkg/virt-handler/BUILD.bazel b/pkg/virt-handler/BUILD.bazel
index a9923c4ef7c2..0a0aefa3b4db 100644
--- a/pkg/virt-handler/BUILD.bazel
+++ b/pkg/virt-handler/BUILD.bazel
@@ -24,6 +24,7 @@ go_library(
         "//pkg/network/errors:go_default_library",
         "//pkg/network/setup:go_default_library",
         "//pkg/network/vmispec:go_default_library",
+        "//pkg/safepath:go_default_library",
         "//pkg/util:go_default_library",
         "//pkg/util/hardware:go_default_library",
         "//pkg/util/migrations:go_default_library",
diff --git a/pkg/virt-handler/non-root.go b/pkg/virt-handler/non-root.go
index b30aa6388864..1f0c8c97f721 100644
--- a/pkg/virt-handler/non-root.go
+++ b/pkg/virt-handler/non-root.go
@@ -14,9 +14,9 @@ import (
 
 	diskutils "kubevirt.io/kubevirt/pkg/ephemeral-disk-utils"
 	hostdisk "kubevirt.io/kubevirt/pkg/host-disk"
+	"kubevirt.io/kubevirt/pkg/safepath"
 	"kubevirt.io/kubevirt/pkg/util/types"
 	"kubevirt.io/kubevirt/pkg/virt-handler/isolation"
-	"kubevirt.io/kubevirt/pkg/virt-handler/selinux"
 )
 
 func changeOwnershipOfBlockDevices(vmi *v1.VirtualMachineInstance, res isolation.IsolationResult) error {
@@ -41,9 +41,11 @@ func changeOwnershipOfBlockDevices(vmi *v1.VirtualMachineInstance, res isolation
 		if !types.IsPVCBlock(volumeMode) {
 			continue
 		}
-
-		devPath := filepath.Join(string(filepath.Separator), "dev", volume.Name)
-		if err := diskutils.DefaultOwnershipManager.SetFileOwnership(filepath.Join(res.MountRoot(), devPath)); err != nil {
+		devPath, err := isolation.SafeJoin(res, string(filepath.Separator), "dev", vmi.Spec.Volumes[i].Name)
+		if err != nil {
+			return nil
+		}
+		if err := diskutils.DefaultOwnershipManager.SetFileOwnership(devPath); err != nil {
 			return err
 		}
 
@@ -51,22 +53,12 @@ func changeOwnershipOfBlockDevices(vmi *v1.VirtualMachineInstance, res isolation
 	return nil
 }
 
-func changeOwnershipAndRelabel(path string) error {
+func changeOwnership(path *safepath.Path) error {
 	err := diskutils.DefaultOwnershipManager.SetFileOwnership(path)
 	if err != nil {
 		return err
 	}
-
-	seLinux, selinuxEnabled, err := selinux.NewSELinux()
-	if err == nil && selinuxEnabled {
-		unprivilegedContainerSELinuxLabel := "system_u:object_r:container_file_t:s0"
-		err = selinux.RelabelFiles(unprivilegedContainerSELinuxLabel, seLinux.IsPermissive(), filepath.Join(path))
-		if err != nil {
-			return (fmt.Errorf("error relabeling %s: %v", path, err))
-		}
-
-	}
-	return err
+	return nil
 }
 
 // changeOwnershipOfHostDisks needs unmodified vmi (not passed to ReplacePVCByHostDisk function)
@@ -80,7 +72,11 @@ func changeOwnershipOfHostDisks(vmiWithAllPVCs *v1.VirtualMachineInstance, res i
 			if err != nil {
 				if os.IsNotExist(err) {
 					diskDir := hostdisk.GetMountedHostDiskDir(volumeName)
-					if err := changeOwnershipAndRelabel(filepath.Join(res.MountRoot(), diskDir)); err != nil {
+					path, err := isolation.SafeJoin(res, diskDir)
+					if err != nil {
+						return fmt.Errorf("Failed to change ownership of HostDisk dir %s, %s", volumeName, err)
+					}
+					if err := changeOwnership(path); err != nil {
 						return fmt.Errorf("Failed to change ownership of HostDisk dir %s, %s", volumeName, err)
 					}
 					continue
@@ -88,7 +84,11 @@ func changeOwnershipOfHostDisks(vmiWithAllPVCs *v1.VirtualMachineInstance, res i
 				return fmt.Errorf("Failed to recognize if hostdisk contains image, %s", err)
 			}
 
-			err = changeOwnershipAndRelabel(filepath.Join(res.MountRoot(), diskPath))
+			path, err := isolation.SafeJoin(res, diskPath)
+			if err != nil {
+				return fmt.Errorf("Failed to change ownership of HostDisk image: %s", err)
+			}
+			err = changeOwnership(path)
 			if err != nil {
 				return fmt.Errorf("Failed to change ownership of HostDisk image: %s", err)
 			}
@@ -126,18 +126,31 @@ func getTapDevices(vmi *v1.VirtualMachineInstance) []string {
 func (d *VirtualMachineController) prepareTap(vmi *v1.VirtualMachineInstance, res isolation.IsolationResult) error {
 	tapDevices := getTapDevices(vmi)
 	for _, tap := range tapDevices {
-		path := filepath.Join(res.MountRoot(), "sys", "class", "net", tap, "ifindex")
-		b, err := ioutil.ReadFile(path)
+		path, err := isolation.SafeJoin(res, "sys", "class", "net", tap, "ifindex")
 		if err != nil {
-			return fmt.Errorf("Failed to read if index, %v", err)
+			return err
 		}
+		index, err := func(path *safepath.Path) (int, error) {
+			df, err := safepath.OpenAtNoFollow(path)
+			if err != nil {
+				return 0, err
+			}
+			defer df.Close()
+			b, err := ioutil.ReadFile(df.SafePath())
+			if err != nil {
+				return 0, fmt.Errorf("Failed to read if index, %v", err)
+			}
 
-		index, err := strconv.Atoi(strings.TrimSpace(string(b)))
+			return strconv.Atoi(strings.TrimSpace(string(b)))
+		}(path)
 		if err != nil {
 			return err
 		}
 
-		pathToTap := filepath.Join(res.MountRoot(), "dev", fmt.Sprintf("tap%d", index))
+		pathToTap, err := isolation.SafeJoin(res, "dev", fmt.Sprintf("tap%d", index))
+		if err != nil {
+			return err
+		}
 
 		if err := diskutils.DefaultOwnershipManager.SetFileOwnership(pathToTap); err != nil {
 			return err
@@ -148,25 +161,41 @@ func (d *VirtualMachineController) prepareTap(vmi *v1.VirtualMachineInstance, re
 }
 
 func (*VirtualMachineController) prepareVFIO(vmi *v1.VirtualMachineInstance, res isolation.IsolationResult) error {
-	vfioPath := filepath.Join(res.MountRoot(), "dev", "vfio")
-	err := os.Chmod(filepath.Join(vfioPath, "vfio"), 0666)
+	vfioBasePath, err := isolation.SafeJoin(res, "dev", "vfio")
 	if err != nil {
 		if os.IsNotExist(err) {
 			return nil
 		}
+	}
+	vfioPath, err := safepath.JoinNoFollow(vfioBasePath, "vfio")
+	if err != nil {
+		if os.IsNotExist(err) {
+			return nil
+		}
+	}
+	err = safepath.ChmodAtNoFollow(vfioPath, 0666)
+	if err != nil {
 		return err
 	}
 
-	groups, err := ioutil.ReadDir(vfioPath)
+	var files []os.DirEntry
+	err = vfioBasePath.ExecuteNoFollow(func(safePath string) (err error) {
+		files, err = os.ReadDir(safePath)
+		return err
+	})
 	if err != nil {
 		return err
 	}
 
-	for _, group := range groups {
+	for _, group := range files {
 		if group.Name() == "vfio" {
 			continue
 		}
-		if err := diskutils.DefaultOwnershipManager.SetFileOwnership(filepath.Join(vfioPath, group.Name())); err != nil {
+		groupPath, err := safepath.JoinNoFollow(vfioBasePath, group.Name())
+		if err != nil {
+			return err
+		}
+		if err := diskutils.DefaultOwnershipManager.SetFileOwnership(groupPath); err != nil {
 			return err
 		}
 	}
