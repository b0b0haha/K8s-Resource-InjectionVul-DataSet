From ba30ed6a883d6801c3c79544d6282e5fd3ab0434 Mon Sep 17 00:00:00 2001
From: Roman Mohr <rmohr@google.com>
Date: Tue, 19 Jul 2022 11:00:03 +0200
Subject: [PATCH] Add a safepath package to encapsule path operations

Privileged virt-handler operations inside non-root virt-launcher pods
need extra precautions to ensure that symbolic links do not lead to
pointing to unintended locations.

The safepath package introduces path operations based on `*At` unit file
syscall (OpenAt, MkDirAt, ...) which have built-in support for not
following symlink and therefore allow atomic check- and modify
operations.

Signed-off-by: Roman Mohr <rmohr@google.com>
---
 pkg/safepath/BUILD.bazel            |  30 ++
 pkg/safepath/safepath.go            | 433 ++++++++++++++++++++++++++++
 pkg/safepath/safepath_linux.go      | 103 +++++++
 pkg/safepath/safepath_suite_test.go |  30 ++
 pkg/safepath/safepath_test.go       | 300 +++++++++++++++++++
 5 files changed, 896 insertions(+)
 create mode 100644 pkg/safepath/BUILD.bazel
 create mode 100644 pkg/safepath/safepath.go
 create mode 100644 pkg/safepath/safepath_linux.go
 create mode 100644 pkg/safepath/safepath_suite_test.go
 create mode 100644 pkg/safepath/safepath_test.go

diff --git a/pkg/safepath/BUILD.bazel b/pkg/safepath/BUILD.bazel
new file mode 100644
index 000000000000..c521acc9ba52
--- /dev/null
+++ b/pkg/safepath/BUILD.bazel
@@ -0,0 +1,30 @@
+load("@io_bazel_rules_go//go:def.bzl", "go_library", "go_test")
+
+go_library(
+    name = "go_default_library",
+    srcs = [
+        "safepath.go",
+        "safepath_linux.go",
+    ],
+    importpath = "kubevirt.io/kubevirt/pkg/safepath",
+    visibility = ["//visibility:public"],
+    deps = [
+        "//pkg/unsafepath:go_default_library",
+        "//vendor/golang.org/x/sys/unix:go_default_library",
+    ],
+)
+
+go_test(
+    name = "go_default_test",
+    srcs = [
+        "safepath_suite_test.go",
+        "safepath_test.go",
+    ],
+    embed = [":go_default_library"],
+    deps = [
+        "//pkg/unsafepath:go_default_library",
+        "//staging/src/kubevirt.io/client-go/testutils:go_default_library",
+        "//vendor/github.com/onsi/ginkgo/v2:go_default_library",
+        "//vendor/github.com/onsi/gomega:go_default_library",
+    ],
+)
diff --git a/pkg/safepath/safepath.go b/pkg/safepath/safepath.go
new file mode 100644
index 000000000000..99822067b134
--- /dev/null
+++ b/pkg/safepath/safepath.go
@@ -0,0 +1,433 @@
+package safepath
+
+import (
+	"container/list"
+	"fmt"
+	"net"
+	"os"
+	"path/filepath"
+	"strings"
+	"syscall"
+
+	"kubevirt.io/kubevirt/pkg/unsafepath"
+
+	"golang.org/x/sys/unix"
+)
+
+// JoinAndResolveWithRelativeRoot joins an absolute relativeRoot base path with
+// additional elements which have to be kept below the relativeRoot base.
+// Relative and absolute links will be resolved relative to the provided rootBase
+// and can not escape it.
+func JoinAndResolveWithRelativeRoot(rootBase string, elems ...string) (*Path, error) {
+	// ensure that rootBase is absolute
+	if !filepath.IsAbs(rootBase) {
+		return nil, fmt.Errorf("basepath is not absolute: %q", rootBase)
+	}
+
+	path := pathRoot
+	fifo := newLimitedFifo(256)
+	for i := len(elems) - 1; i >= 0; i-- {
+		if err := fifo.push(strings.Split(filepath.Clean(elems[i]), pathSeparator)); err != nil {
+			return nil, err
+		}
+	}
+
+	for !fifo.empty() {
+		child := fifo.pop()
+		var link string
+		var err error
+
+		path, link, err = advance(rootBase, path, child)
+		if err != nil {
+			return nil, err
+		}
+		if link != "" {
+			if err := fifo.push(strings.Split(link, pathSeparator)); err != nil {
+				return nil, err
+			}
+		}
+	}
+
+	// Assert that the result is indeed a clean path in the expected format
+	// at this point in time.
+	finalPath := newPath(rootBase, path)
+	fd, err := OpenAtNoFollow(finalPath)
+	if err != nil {
+		return nil, err
+	}
+	_ = fd.Close()
+
+	return finalPath, nil
+}
+
+type fifo struct {
+	ops    uint
+	store  *list.List
+	maxOps uint
+}
+
+func (f *fifo) push(pathElements []string) error {
+	for i := len(pathElements) - 1; i >= 0; i-- {
+		if f.ops > f.maxOps {
+			return fmt.Errorf("more than %v path elements evaluated", f.maxOps)
+		}
+		if pathElements[i] == "" {
+			continue
+		}
+		f.ops++
+		f.store.PushFront(pathElements[i])
+	}
+	return nil
+}
+
+func (f *fifo) pop() string {
+	if val := f.store.Front(); val != nil {
+		f.store.Remove(val)
+		return val.Value.(string)
+	}
+	return ""
+}
+
+func (f *fifo) empty() bool {
+	return f.store.Len() == 0
+}
+
+// newLimitedFifo creates a fifo with a maximum enqueue limit to
+// avoid abuse on filepath operations.
+func newLimitedFifo(maxOps uint) *fifo {
+	return &fifo{
+		store:  list.New(),
+		maxOps: maxOps,
+	}
+}
+
+// OpenAtNoFollow safely opens a filedescriptor to a path relative to
+// rootBase. Any symlink encountered will be treated as invalid and the operation will be aborted.
+// This works best together with a path first resolved with JoinAndResolveWithRelativeRoot
+// which can resolve relative paths and symlinks.
+func OpenAtNoFollow(path *Path) (file *File, err error) {
+	fd, err := open(path.rootBase)
+	if err != nil {
+		return nil, err
+	}
+	for _, child := range strings.Split(filepath.Clean(path.relativePath), pathSeparator) {
+		if child == "" {
+			continue
+		}
+		newfd, err := openat(fd, child)
+		_ = syscall.Close(fd) // always close the parent after the lookup
+		if err != nil {
+			return nil, err
+		}
+		fd = newfd
+	}
+	return &File{fd: fd, path: path}, nil
+}
+
+func ChmodAtNoFollow(path *Path, mode os.FileMode) error {
+	f, err := OpenAtNoFollow(path)
+	if err != nil {
+		return err
+	}
+	defer f.Close()
+	return os.Chmod(f.SafePath(), mode)
+}
+
+func ChownAtNoFollow(path *Path, uid, gid int) error {
+	f, err := OpenAtNoFollow(path)
+	if err != nil {
+		return err
+	}
+	defer f.Close()
+	return os.Chown(f.SafePath(), uid, gid)
+}
+
+func ChpermAtNoFollow(path *Path, uid, gid int, mode os.FileMode) error {
+	// first set the ownership, to avoid that someone may change back the file mode
+	// after we set it. This is necessary if the file got somehow created without
+	// the right owners, maybe with malicious intent.
+	if err := ChownAtNoFollow(path, uid, gid); err != nil {
+		return err
+	}
+	if err := ChmodAtNoFollow(path, mode); err != nil {
+		return err
+	}
+	return nil
+}
+
+func MkdirAtNoFollow(path *Path, dirName string, mode os.FileMode) error {
+	if err := isSingleElement(dirName); err != nil {
+		return err
+	}
+	f, err := OpenAtNoFollow(path)
+	if err != nil {
+		return err
+	}
+	defer f.Close()
+	if err := unix.Mkdirat(f.fd, dirName, uint32(mode)); err != nil {
+		return err
+	}
+	return nil
+}
+
+// TouchAtNoFollow safely touches a file relative to
+// rootBase. The additional elements form the relative path. Any symlink
+// encountered will be treated as invalid and the operation will be aborted.
+// This works best together with a path first resolved with JoinAndResolveWithRelativeRoot
+// which can resolve relative paths to their real path without symlinks.
+// If the target file exists already, the function will fail.
+func TouchAtNoFollow(path *Path, fileName string, mode os.FileMode) (err error) {
+	if err := isSingleElement(fileName); err != nil {
+		return err
+	}
+	parent, err := OpenAtNoFollow(path)
+	if err != nil {
+		return err
+	}
+	defer parent.Close()
+	fd, err := touchat(parent.fd, fileName, uint32(mode))
+	if err != nil {
+		return err
+	}
+	_ = syscall.Close(fd)
+	return nil
+}
+
+func MknodAtNoFollow(path *Path, fileName string, mode os.FileMode, dev uint64) (err error) {
+	if err := isSingleElement(fileName); err != nil {
+		return err
+	}
+	parent, err := OpenAtNoFollow(path)
+	if err != nil {
+		return err
+	}
+	defer parent.Close()
+	return mknodat(parent.fd, fileName, uint32(mode), dev)
+}
+
+func StatAtNoFollow(path *Path) (os.FileInfo, error) {
+	pathFd, err := OpenAtNoFollow(path)
+	if err != nil {
+		return nil, err
+	}
+	defer pathFd.Close()
+	return os.Stat(pathFd.SafePath())
+}
+
+type File struct {
+	fd   int
+	path *Path
+}
+
+func (f *File) Close() error {
+	return syscall.Close(f.fd)
+}
+
+func (f *File) String() string {
+	return f.Path().String()
+}
+
+// SafePath returns a path pointing to the associated file descriptor.
+// It is safe to reuse this path without additional checks. The kernel
+// will ensure that this path always points to the resolved file.
+// To operate on the file just use os.Open and related calls.
+func (f *File) SafePath() string {
+	return path(f.fd)
+}
+
+func (f *File) Path() *Path {
+	return f.path
+}
+
+// Path is a path which was at the time of creation a real path
+// re
+type Path struct {
+	rootBase     string
+	relativePath string
+}
+
+// Raw returns an "unsafe" path. It's properties are not safe to use without certain precautions.
+// It exposes no access functions. All access happens via functions in the "unsafepath" package.
+func (p *Path) Raw() *unsafepath.Path {
+	return unsafepath.New(p.rootBase, p.relativePath)
+}
+
+func (p *Path) IsRoot() bool {
+	return unsafepath.UnsafeAbsolute(p.Raw()) == pathRoot
+}
+
+// AppendAndResolveWithRelativeRoot returns a new path with the passed elements resolve relative
+// to the current absolute path.
+func (p *Path) AppendAndResolveWithRelativeRoot(relativeRootElems ...string) (*Path, error) {
+	tmpPath, err := JoinAndResolveWithRelativeRoot(unsafepath.UnsafeAbsolute(p.Raw()), relativeRootElems...)
+	if err != nil {
+		return nil, err
+	}
+
+	newPath := newPath(p.rootBase, filepath.Join(p.relativePath, tmpPath.relativePath))
+	fd, err := OpenAtNoFollow(newPath)
+	if err != nil {
+		return nil, err
+	}
+	_ = fd.Close()
+
+	return newPath, err
+}
+
+func (p *Path) String() string {
+	return fmt.Sprintf("root: %v, relative: %v", p.rootBase, p.relativePath)
+}
+
+// ExecuteNoFollow opens the file in question and provides the file descriptor path as safePath string.
+// This safePath string can be (re)opened with normal os.* operations. The file descriptor path is
+// managed by the kernel and there is no way to inject malicious symlinks.
+func (p *Path) ExecuteNoFollow(callback func(safePath string) error) error {
+	f, err := OpenAtNoFollow(p)
+	if err != nil {
+		return err
+	}
+	defer f.Close()
+	return callback(f.SafePath())
+}
+
+// DirNoFollow returns the parent directory of the safepath.Path as safepath.Path.
+func (p *Path) DirNoFollow() (*Path, error) {
+	if len(p.relativePath) == 0 {
+		return nil, fmt.Errorf("already at relative root, can't get parent")
+	}
+	newPath := newPath(p.rootBase, filepath.Dir(p.relativePath))
+	return newPath, nil
+}
+
+// Base returns the basename of the relative untrusted part of the safepath.
+func (p *Path) Base() (string, error) {
+	if len(p.relativePath) == 0 {
+		return "", fmt.Errorf("already at relative root, can't get parent")
+	}
+	return filepath.Base(p.relativePath), nil
+}
+
+func newPath(rootBase, relativePath string) *Path {
+	return &Path{
+		rootBase:     rootBase,
+		relativePath: filepath.Join("/", relativePath),
+	}
+}
+
+// NewFileNoFollow assumes that a real path to a file is given. It will validate that
+// the file is indeed absolute by doing the following checks:
+//   * ensure that the path is absolute
+//   * ensure that the path does not container relative path elements
+//   * ensure that no symlinks are provided
+// It will return the opened file which contains a link to a safe-to-use path
+// to the file, which can't be tampered with. To operate on the file just use os.Open and related calls.
+func NewFileNoFollow(path string) (*File, error) {
+	if filepath.Clean(path) != path || !filepath.IsAbs(path) {
+		return nil, fmt.Errorf("path %q must be absolute and must not contain relative elements", path)
+	}
+	p := newPath("/", path)
+	return OpenAtNoFollow(p)
+}
+
+// NewPathNoFollow is a convenience method to get out of a supposedly link-free path a safepath.Path.
+// If there is a symlink included the command will fail.
+func NewPathNoFollow(path string) (*Path, error) {
+	fd, err := NewFileNoFollow(path)
+	if err != nil {
+		return nil, err
+	}
+	defer fd.Close()
+	return fd.Path(), nil
+}
+
+// JoinNoFollow joins the root path with the given additional path.
+// If the additional path element is not a real path (like containing symlinks), it fails.
+func JoinNoFollow(rootPath *Path, path string) (*Path, error) {
+	if filepath.Clean(path) != path || path == "" {
+		return nil, fmt.Errorf("path %q must not contain relative elements and must not be empty", path)
+	}
+	p := newPath(unsafepath.UnsafeAbsolute(rootPath.Raw()), path)
+	f, err := OpenAtNoFollow(p)
+	if err != nil {
+		return nil, err
+	}
+	return f.Path(), f.Close()
+}
+
+func isSingleElement(path string) error {
+	cleanedPath := filepath.Clean(path)
+	if cleanedPath != path || strings.ContainsAny(path, pathSeparator) {
+		return fmt.Errorf("path %q must be a single non-relative path segment", path)
+	}
+	switch path {
+	case "", "..", ".":
+		return fmt.Errorf("path %q must be a single non-relative path segment", path)
+	default:
+		return nil
+	}
+}
+
+// UnlinkAtNoFollow allows deleting the specified file or directory (directory must be empty to succeed).
+func UnlinkAtNoFollow(path *Path) error {
+	parent, err := path.DirNoFollow()
+	if err != nil {
+		return err
+	}
+	basename, err := path.Base()
+	if err != nil {
+		return nil
+	}
+	info, err := StatAtNoFollow(path)
+	if err != nil {
+		return err
+	}
+	fd, err := OpenAtNoFollow(parent)
+	if err != nil {
+		return err
+	}
+	defer fd.Close()
+	if info.IsDir() {
+		// if dir is empty we can delete it with AT_REMOVEDIR
+		return unlinkat(fd.fd, basename, unix.AT_REMOVEDIR)
+	} else {
+		return unlinkat(fd.fd, basename, 0)
+	}
+}
+
+// ListenUnixNoFollow safely creates a socket in user-owned path
+// Since there exists no socketat on unix, first a safe delete is performed,
+// then the socket is created.
+func ListenUnixNoFollow(socketDir *Path, socketName string) (net.Listener, error) {
+	if err := isSingleElement(socketName); err != nil {
+		return nil, err
+	}
+
+	addr, err := net.ResolveUnixAddr("unix", filepath.Join(unsafepath.UnsafeAbsolute(socketDir.Raw()), socketName))
+	if err != nil {
+		return nil, err
+	}
+
+	socketPath, err := JoinNoFollow(socketDir, socketName)
+	if err == nil {
+		// This ensures that we don't allow unlinking arbitrary files
+		if err := UnlinkAtNoFollow(socketPath); err != nil {
+			return nil, err
+		}
+	} else if !os.IsNotExist(err) {
+		return nil, err
+	}
+
+	listener, err := net.ListenUnix("unix", addr)
+	if err != nil {
+		return nil, err
+	}
+
+	// Ensure that the socket path is a real path
+	// this does not 100% remove the chance of
+	// having a socket created at the wrong place, but it makes it unlikely
+	_, err = JoinNoFollow(socketDir, socketName)
+	if err != nil {
+		return nil, err
+	}
+	return listener, nil
+}
diff --git a/pkg/safepath/safepath_linux.go b/pkg/safepath/safepath_linux.go
new file mode 100644
index 000000000000..96bb3378f832
--- /dev/null
+++ b/pkg/safepath/safepath_linux.go
@@ -0,0 +1,103 @@
+//go:build linux
+
+package safepath
+
+import (
+	"fmt"
+	"io/fs"
+	"os"
+	"path/filepath"
+	"strings"
+	"syscall"
+
+	"golang.org/x/sys/unix"
+)
+
+const pathSeparator = string(os.PathSeparator)
+const pathRoot = string(os.PathSeparator)
+
+// advance will try to add the child to the parent. If it is a relative symlink it will resolve it
+// and return the parent with the new symlink. If it is an absolute symlink, parent will be reset to '/'
+// and returned together with the absolute symlink. If the joined result is no symlink, the joined result will
+// be returned as the new parent.
+func advance(rootBase string, parent string, child string) (string, string, error) {
+	// Ensure parent is absolute and never empty
+	parent = filepath.Clean(parent)
+	if !filepath.IsAbs(parent) {
+		return "", "", fmt.Errorf("parent path %v must be absolute", parent)
+	}
+
+	if strings.Contains(child, pathSeparator) {
+		return "", "", fmt.Errorf("child %q must not contain a path separator", child)
+	}
+
+	// Deal with relative path elements like '.', '//' and '..'
+	// Since parent is absolute, worst case we get '/' as result
+	path := filepath.Join(parent, child)
+
+	if path == rootBase {
+		// don't evaluate the root itself, since rootBase is allowed to be a symlink
+		return path, "", nil
+	}
+
+	fi, err := os.Lstat(filepath.Join(rootBase, path))
+	if err != nil {
+		return "", "", err
+	}
+
+	if fi.Mode()&fs.ModeSymlink == 0 {
+		// no symlink, we are done, return the joined result of parent and child
+		return filepath.Clean(path), "", nil
+	}
+
+	link, err := os.Readlink(filepath.Join(rootBase, path))
+	if err != nil {
+		return "", "", err
+	}
+
+	if filepath.IsAbs(link) {
+		// the link is absolute, let's reset the parent and the discovered link path
+		return pathRoot, filepath.Clean(link), nil
+	} else {
+		// on relative links, don't advance parent and return the link
+		return parent, filepath.Clean(link), nil
+	}
+}
+
+// openat helps traversing a path without following symlinks
+// to ensure safe path references on user-owned paths by privileged processes
+func openat(dirfd int, path string) (fd int, err error) {
+	if err := isSingleElement(path); err != nil {
+		return -1, err
+	}
+	return unix.Openat(dirfd, path, unix.O_NOFOLLOW|unix.O_PATH, 0)
+}
+
+func unlinkat(dirfd int, path string, flags int) error {
+	if err := isSingleElement(path); err != nil {
+		return err
+	}
+	return unix.Unlinkat(dirfd, path, flags)
+}
+
+func touchat(dirfd int, path string, mode uint32) (fd int, err error) {
+	if err := isSingleElement(path); err != nil {
+		return -1, err
+	}
+	return unix.Openat(dirfd, path, unix.O_NOFOLLOW|syscall.O_CREAT|syscall.O_EXCL, mode)
+}
+
+func mknodat(dirfd int, path string, mode uint32, dev uint64) (err error) {
+	if err := isSingleElement(path); err != nil {
+		return err
+	}
+	return unix.Mknodat(dirfd, path, mode, int(dev))
+}
+
+func open(path string) (fd int, err error) {
+	return syscall.Open(path, unix.O_PATH, 0)
+}
+
+func path(fd int) string {
+	return fmt.Sprintf("/proc/self/fd/%d", fd)
+}
diff --git a/pkg/safepath/safepath_suite_test.go b/pkg/safepath/safepath_suite_test.go
new file mode 100644
index 000000000000..92f1da11f670
--- /dev/null
+++ b/pkg/safepath/safepath_suite_test.go
@@ -0,0 +1,30 @@
+/*
+ * This file is part of the KubeVirt project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Copyright 2018 Red Hat, Inc.
+ *
+ */
+
+package safepath
+
+import (
+	"testing"
+
+	"kubevirt.io/client-go/testutils"
+)
+
+func TestSafePath(t *testing.T) {
+	testutils.KubeVirtTestSuiteSetup(t)
+}
diff --git a/pkg/safepath/safepath_test.go b/pkg/safepath/safepath_test.go
new file mode 100644
index 000000000000..bfaae7ea69d7
--- /dev/null
+++ b/pkg/safepath/safepath_test.go
@@ -0,0 +1,300 @@
+package safepath
+
+import (
+	"fmt"
+	"io/fs"
+	"os"
+	"os/user"
+	"path/filepath"
+	"strconv"
+	"syscall"
+
+	"kubevirt.io/kubevirt/pkg/unsafepath"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+)
+
+type pathBuilder struct {
+	segments     [][]string
+	relativeRoot string
+	systemRoot   string
+}
+
+// Path adds a new path segment to the final path to construct
+func (p *pathBuilder) Path(path string) *pathBuilder {
+	p.segments = append(p.segments, []string{path})
+	return p
+}
+
+// Link adds a path segemtn and a link location to the final path to construct.
+// The link target can be an absolute or a relative path.
+func (p *pathBuilder) Link(path string, target string) *pathBuilder {
+	p.segments = append(p.segments, []string{path, target})
+	return p
+}
+
+// new returns a new path builder with the given relative root prefix.
+func new(root string) *pathBuilder {
+	return &pathBuilder{segments: [][]string{}, relativeRoot: root}
+}
+
+// RelativeRoot returns the final full relative root path.
+// Must be called after Builder() to be valid.
+func (p *pathBuilder) RelativeRoot() string {
+	return filepath.Join(p.systemRoot, p.relativeRoot)
+}
+
+// SystemRoot returns the emulated system root path, where the
+// RelativeRoot path is a child of.
+// Must be called after Builder() to be valid.
+func (p *pathBuilder) SystemRoot() string {
+	return p.systemRoot
+}
+
+// Build the defined path. Absolute links are prefixed wit the SystemRoot which
+// will be the base of a ginkgo managed tmp directory.
+func (p *pathBuilder) Build() (string, error) {
+	p.systemRoot = GinkgoT().TempDir()
+	relativeRoot := filepath.Join(p.systemRoot, p.relativeRoot)
+	parent := relativeRoot
+	if err := os.MkdirAll(parent, os.ModePerm); err != nil {
+		return "", err
+	}
+	for _, elem := range p.segments {
+		parent = filepath.Join(parent, elem[0])
+		if len(elem) == 2 {
+			link := elem[1]
+			if err := os.Symlink(link, parent); err != nil {
+				return "", err
+			}
+		} else {
+			if err := os.MkdirAll(parent, os.ModePerm); err != nil {
+				return "", err
+			}
+		}
+	}
+
+	relativePath := ""
+	for _, elem := range p.segments {
+		relativePath = filepath.Join(relativePath, elem[0])
+	}
+
+	return relativePath, nil
+}
+
+var _ = Describe("safepath", func() {
+
+	DescribeTable("should prevent an escape via", func(builder *pathBuilder, expectedPath string) {
+		path, err := builder.Build()
+		Expect(err).ToNot(HaveOccurred())
+		constructedPath, err := JoinAndResolveWithRelativeRoot(builder.RelativeRoot(), path)
+		Expect(err).ToNot(HaveOccurred())
+		Expect(unsafepath.UnsafeAbsolute(constructedPath.Raw())).To(Equal(filepath.Join(builder.RelativeRoot(), expectedPath)))
+	},
+		Entry("an absolute link to root subdirectory", new("/var/lib/rel/root").Path("link/back/to").Link("link", "/link"),
+			"/link",
+		),
+		Entry("an absolute link to root", new("/var/lib/rel/root").Path("link/back/to").Link("link", "/"),
+			"/",
+		),
+		Entry("a relative link", new("/var/lib/rel/root").Path("link/back/to").Link("var", "../../../../../"),
+			"/",
+		),
+	)
+
+	DescribeTable("should be able to", func(builder *pathBuilder, expectedPath string) {
+		path, err := builder.Build()
+		Expect(err).ToNot(HaveOccurred())
+		constructedPath, err := JoinAndResolveWithRelativeRoot(builder.RelativeRoot(), path)
+		Expect(err).ToNot(HaveOccurred())
+		Expect(unsafepath.UnsafeAbsolute(constructedPath.Raw())).To(Equal(filepath.Join(builder.RelativeRoot(), expectedPath)))
+	},
+		Entry("handle relative paths by cutting off at the relative root", new("/var/lib/rel/root").Path("link/back/to").Path("../../../../../"),
+			`/`,
+		),
+		Entry("handle relative legitimate paths", new("/var/lib/rel/root").Path("link/back/to").Path("../../"),
+			`/link`,
+		),
+		Entry("handle legitimate paths with relative symlinks", new("/var/lib/rel/root").Path("link/back/to").Link("test", "../../"),
+			`/link`,
+		),
+		Entry("handle multiple legitimate symlink redirects", new("/var/lib/rel/root").Path("link/back/to").Link("test", "../../").Path("b/c").Link("yeah", "../"),
+			`/link/b`,
+		),
+	)
+
+	It("should detect self-referencing links", func() {
+		builder := new("/var/lib/rel/root").Path("link/back/to").Link("test", "../test")
+		path, err := builder.Build()
+		Expect(err).ToNot(HaveOccurred())
+		_, err = JoinAndResolveWithRelativeRoot(builder.RelativeRoot(), path)
+		Expect(err).To(HaveOccurred())
+	})
+
+	It("should follow a sequence of linked links", func() {
+		root := GinkgoT().TempDir()
+		relativeRoot := filepath.Join(root, "testroot")
+		path := "some/path/to/follow"
+		Expect(os.MkdirAll(filepath.Join(relativeRoot, path, "test3", "test4"), os.ModePerm))
+		Expect(os.Symlink("test3", filepath.Join(relativeRoot, path, "test2"))).To(Succeed())
+		Expect(os.Symlink("test2", filepath.Join(relativeRoot, path, "test1"))).To(Succeed())
+		// try to reach the test4 directory over the test1 link
+		pp, err := JoinAndResolveWithRelativeRoot(relativeRoot, path, "/test1/test4")
+		Expect(err).ToNot(HaveOccurred())
+		// don't use join to avoid any clean operations
+		Expect(unsafepath.UnsafeAbsolute(pp.Raw())).To(Equal(relativeRoot + "/some/path/to/follow/test3/test4"))
+	})
+
+	It("should detect too many redirects", func() {
+		root := GinkgoT().TempDir()
+		relativeRoot := filepath.Join(root, "testroot")
+		path := "some/path/to/follow"
+		Expect(os.MkdirAll(filepath.Join(relativeRoot, path, "test3", "test4"), os.ModePerm))
+		Expect(os.Symlink("test3", filepath.Join(relativeRoot, path, "test100"))).To(Succeed())
+		for i := 101; i < 401+50; i++ {
+			Expect(os.Symlink(fmt.Sprintf("test%d", i-1), filepath.Join(relativeRoot, path, fmt.Sprintf("test%d", i)))).To(Succeed())
+		}
+
+		// try to reach the test4 directory over the test1 link
+		_, err := JoinAndResolveWithRelativeRoot(relativeRoot, path, "/test435/test4")
+		Expect(err).To(HaveOccurred())
+		Expect(err.Error()).To(Equal("more than 256 path elements evaluated"))
+	})
+
+	It("should not resolve symlinks in the root path", func() {
+		root := GinkgoT().TempDir()
+		relativeRoot := filepath.Join(root, "testroot")
+		path := "some/path/to/follow"
+		Expect(os.MkdirAll(filepath.Join(relativeRoot, path, "test3", "test4"), os.ModePerm))
+		Expect(os.Symlink("test3", filepath.Join(relativeRoot, path, "test2"))).To(Succeed())
+		Expect(os.Symlink("test2", filepath.Join(relativeRoot, path, "test1"))).To(Succeed())
+		// include the symlink in the root path
+		pp, err := JoinAndResolveWithRelativeRoot(filepath.Join(relativeRoot, path, "test1"), "test4")
+		Expect(err).ToNot(HaveOccurred())
+		// don't use join to avoid any clean operations
+		Expect(unsafepath.UnsafeAbsolute(pp.Raw())).To(Equal(relativeRoot + "/some/path/to/follow/test1/test4"))
+	})
+
+	It("should create a socket repeatedly the safe way", func() {
+		root, err := JoinAndResolveWithRelativeRoot("/", GinkgoT().TempDir())
+		Expect(err).ToNot(HaveOccurred())
+		l, err := ListenUnixNoFollow(root, "my.sock")
+		Expect(err).ToNot(HaveOccurred())
+		l.Close()
+		l, err = ListenUnixNoFollow(root, "my.sock")
+		Expect(err).ToNot(HaveOccurred())
+		l.Close()
+	})
+
+	It("should open a safepath and provide its filedescriptor path with execute", func() {
+		root, err := JoinAndResolveWithRelativeRoot("/", GinkgoT().TempDir())
+		Expect(err).ToNot(HaveOccurred())
+		Expect(os.MkdirAll(filepath.Join(unsafepath.UnsafeAbsolute(root.Raw()), "test"), os.ModePerm)).To(Succeed())
+
+		Expect(root.ExecuteNoFollow(func(safePath string) error {
+			Expect(safePath).To(ContainSubstring("/proc/self/fd/"))
+			_, err := os.Stat(filepath.Join(safePath, "test"))
+			Expect(err).ToNot(HaveOccurred())
+			return nil
+		})).To(Succeed())
+	})
+
+	It("should create a child directory", func() {
+		root, err := JoinAndResolveWithRelativeRoot("/", GinkgoT().TempDir())
+		Expect(err).ToNot(HaveOccurred())
+		Expect(MkdirAtNoFollow(root, "test", os.ModePerm)).To(Succeed())
+		_, err = os.Stat(filepath.Join(unsafepath.UnsafeAbsolute(root.Raw()), "test"))
+		Expect(err).ToNot(HaveOccurred())
+	})
+
+	It("should set owner and file permissions", func() {
+		root, err := JoinAndResolveWithRelativeRoot("/", GinkgoT().TempDir())
+		Expect(err).ToNot(HaveOccurred())
+		u, err := user.Current()
+		Expect(err).ToNot(HaveOccurred())
+		uid, err := strconv.Atoi(u.Uid)
+		Expect(err).ToNot(HaveOccurred())
+		gid, err := strconv.Atoi(u.Gid)
+		Expect(err).ToNot(HaveOccurred())
+		Expect(ChpermAtNoFollow(root, uid, gid, 0777)).To(Succeed())
+		stat, err := StatAtNoFollow(root)
+		Expect(err).ToNot(HaveOccurred())
+		Expect(stat.Sys().(*syscall.Stat_t).Gid).To(Equal(uint32(gid)))
+		Expect(stat.Sys().(*syscall.Stat_t).Uid).To(Equal(uint32(uid)))
+		Expect(stat.Mode() & 0777).To(Equal(fs.FileMode(0777)))
+		Expect(ChpermAtNoFollow(root, uid, gid, 0770)).To(Succeed())
+		stat, err = StatAtNoFollow(root)
+		Expect(err).ToNot(HaveOccurred())
+		Expect(stat.Mode() & 0777).To(Equal(fs.FileMode(0770)))
+		Expect(stat.Sys().(*syscall.Stat_t).Gid).To(Equal(uint32(gid)))
+		Expect(stat.Sys().(*syscall.Stat_t).Uid).To(Equal(uint32(uid)))
+	})
+
+	It("should unlink files and directories", func() {
+		root, err := JoinAndResolveWithRelativeRoot("/", GinkgoT().TempDir())
+		Expect(err).ToNot(HaveOccurred())
+		Expect(TouchAtNoFollow(root, "test", os.ModePerm)).To(Succeed())
+		Expect(MkdirAtNoFollow(root, "testdir", os.ModePerm)).To(Succeed())
+		_, err = os.Stat(filepath.Join(unsafepath.UnsafeAbsolute(root.Raw()), "test"))
+		Expect(err).ToNot(HaveOccurred())
+		_, err = os.Stat(filepath.Join(unsafepath.UnsafeAbsolute(root.Raw()), "testdir"))
+		Expect(err).ToNot(HaveOccurred())
+		p, err := JoinNoFollow(root, "test")
+		Expect(err).ToNot(HaveOccurred())
+		dir, err := JoinNoFollow(root, "testdir")
+		Expect(err).ToNot(HaveOccurred())
+		Expect(UnlinkAtNoFollow(p)).To(Succeed())
+		Expect(UnlinkAtNoFollow(dir)).To(Succeed())
+		_, err = os.Stat(filepath.Join(unsafepath.UnsafeAbsolute(root.Raw()), "test"))
+		Expect(err).To(HaveOccurred())
+		_, err = os.Stat(filepath.Join(unsafepath.UnsafeAbsolute(root.Raw()), "testdir"))
+		Expect(err).To(HaveOccurred())
+	})
+
+	It("should return base and relative paths correctly", func() {
+		baseDir := GinkgoT().TempDir()
+		root, err := JoinAndResolveWithRelativeRoot(baseDir)
+		Expect(err).ToNot(HaveOccurred())
+		Expect(MkdirAtNoFollow(root, "test", os.ModePerm)).To(Succeed())
+		child, err := JoinNoFollow(root, "test")
+		Expect(err).ToNot(HaveOccurred())
+		Expect(unsafepath.UnsafeRoot(child.Raw())).To(Equal(baseDir))
+		Expect(unsafepath.UnsafeRelative(child.Raw())).To(Equal("/test"))
+	})
+
+	It("should append new relative root components to the relative path", func() {
+		baseDir := GinkgoT().TempDir()
+		root, err := JoinAndResolveWithRelativeRoot(baseDir)
+		Expect(err).ToNot(HaveOccurred())
+		Expect(MkdirAtNoFollow(root, "test", os.ModePerm)).To(Succeed())
+		child, err := root.AppendAndResolveWithRelativeRoot("test")
+		Expect(err).ToNot(HaveOccurred())
+		Expect(unsafepath.UnsafeRoot(child.Raw())).To(Equal(baseDir))
+		Expect(unsafepath.UnsafeRelative(child.Raw())).To(Equal("/test"))
+	})
+
+	It("should detect absolute root", func() {
+		p, err := NewPathNoFollow("/")
+		Expect(err).ToNot(HaveOccurred())
+		Expect(p.IsRoot()).To(BeTrue())
+		tmpDir, err := JoinAndResolveWithRelativeRoot("/", GinkgoT().TempDir())
+		Expect(err).ToNot(HaveOccurred())
+		Expect(tmpDir.IsRoot()).To(BeFalse())
+	})
+
+	It("should be possible to use os.ReadDir on a safepath", func() {
+		baseDir := GinkgoT().TempDir()
+		root, err := JoinAndResolveWithRelativeRoot(baseDir)
+		Expect(err).ToNot(HaveOccurred())
+
+		Expect(os.MkdirAll(filepath.Join(baseDir, "test"), os.ModePerm)).To(Succeed())
+
+		var files []os.DirEntry
+		Expect(root.ExecuteNoFollow(func(safePath string) (err error) {
+			files, err = os.ReadDir(safePath)
+			return err
+		})).To(Succeed())
+		Expect(files).To(HaveLen(1))
+	})
+})
