From fe187d33947cc1ed72c7c1b064a18e7169a1be25 Mon Sep 17 00:00:00 2001
From: Roman Mohr <rmohr@google.com>
Date: Thu, 21 Jul 2022 12:44:53 +0200
Subject: [PATCH] Temoprary fork the banncheck analyzer to allow embedding the
 analyzer config

Signed-off-by: Roman Mohr <rmohr@google.com>
---
 .../analyzers/banncheck/banncheck/BUILD.bazel |  12 ++
 .../banncheck/banncheck/banned_api.go         | 138 ++++++++++++++++++
 tools/analyzers/banncheck/config/BUILD.bazel  |   8 +
 tools/analyzers/banncheck/config/config.go    |  91 ++++++++++++
 4 files changed, 249 insertions(+)
 create mode 100644 tools/analyzers/banncheck/banncheck/BUILD.bazel
 create mode 100644 tools/analyzers/banncheck/banncheck/banned_api.go
 create mode 100644 tools/analyzers/banncheck/config/BUILD.bazel
 create mode 100644 tools/analyzers/banncheck/config/config.go

diff --git a/tools/analyzers/banncheck/banncheck/BUILD.bazel b/tools/analyzers/banncheck/banncheck/BUILD.bazel
new file mode 100644
index 000000000000..c5166c8e9219
--- /dev/null
+++ b/tools/analyzers/banncheck/banncheck/BUILD.bazel
@@ -0,0 +1,12 @@
+load("@io_bazel_rules_go//go:def.bzl", "go_library")
+
+go_library(
+    name = "go_default_library",
+    srcs = ["banned_api.go"],
+    importpath = "kubevirt.io/kubevirt/tools/analyzers/banncheck/banncheck",
+    visibility = ["//visibility:public"],
+    deps = [
+        "//tools/analyzers/banncheck/config:go_default_library",
+        "@org_golang_x_tools//go/analysis:go_default_library",
+    ],
+)
diff --git a/tools/analyzers/banncheck/banncheck/banned_api.go b/tools/analyzers/banncheck/banncheck/banned_api.go
new file mode 100644
index 000000000000..cd6b8af7c48f
--- /dev/null
+++ b/tools/analyzers/banncheck/banncheck/banned_api.go
@@ -0,0 +1,138 @@
+// Copyright 2020 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// 	https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package bannedapi provides the tools for doing static analysis
+// and checking for usage of banned APIs.
+
+// TODO: Temporary fork of banncheck from https://github.com/google/go-safeweb/tree/eb79df54b8bc1910ac3bc3fc3328da7c0fb016e1/cmd/bancheck
+package bannedapi
+
+import (
+	"errors"
+	"flag"
+	"fmt"
+	"go/token"
+	"go/types"
+	"path/filepath"
+	"strings"
+
+	"kubevirt.io/kubevirt/tools/analyzers/banncheck/config"
+
+	"golang.org/x/tools/go/analysis"
+)
+
+// NewAnalyzer returns an analyzer that checks for usage of banned APIs.
+func NewAnalyzer() *analysis.Analyzer {
+	fs := flag.NewFlagSet("", flag.ExitOnError)
+	fs.String("configs", "", "Config files with banned APIs separated by a comma")
+
+	a := &analysis.Analyzer{
+		Name:  "bannedAPI",
+		Doc:   "Checks for usage of banned APIs",
+		Run:   checkBannedAPIs,
+		Flags: *fs,
+	}
+
+	return a
+}
+
+func checkBannedAPIs(pass *analysis.Pass) (interface{}, error) {
+	cfgFiles := pass.Analyzer.Flags.Lookup("configs").Value.String()
+	if cfgFiles == "" {
+		return nil, errors.New("missing config files")
+	}
+
+	cfg, err := config.ReadConfigs(strings.Split(cfgFiles, ","))
+	if err != nil {
+		return nil, err
+	}
+
+	checkBannedImports(pass, bannedAPIMap(cfg.Imports))
+	checkBannedFunctions(pass, bannedAPIMap(cfg.Functions))
+
+	return nil, nil
+}
+
+func checkBannedImports(pass *analysis.Pass, bannedImports map[string][]config.BannedAPI) (interface{}, error) {
+	for _, f := range pass.Files {
+		for _, i := range f.Imports {
+			importName := strings.Trim(i.Path.Value, "\"")
+			err := reportIfBanned(importName, bannedImports, i.Pos(), pass)
+			if err != nil {
+				return false, err
+			}
+		}
+	}
+	return nil, nil
+}
+
+func checkBannedFunctions(pass *analysis.Pass, bannedFns map[string][]config.BannedAPI) (interface{}, error) {
+	for id, obj := range pass.TypesInfo.Uses {
+		fn, ok := obj.(*types.Func)
+		if !ok {
+			continue
+		}
+
+		fnName := fmt.Sprintf("%s.%s", fn.Pkg().Path(), fn.Name())
+		err := reportIfBanned(fnName, bannedFns, id.Pos(), pass)
+		if err != nil {
+			return false, err
+		}
+	}
+	return nil, nil
+}
+
+func reportIfBanned(apiName string, bannedAPIs map[string][]config.BannedAPI, position token.Pos, pass *analysis.Pass) error {
+	for _, banCfg := range bannedAPIs[apiName] {
+		if apiName != banCfg.Name {
+			return nil
+		}
+		pkgAllowed, err := isPkgAllowed(pass.Pkg, banCfg)
+		if err != nil {
+			return err
+		}
+		if pkgAllowed {
+			continue
+		}
+		pass.Report(analysis.Diagnostic{
+			Pos:     position,
+			Message: fmt.Sprintf("Banned API found %q. Additional info: %s", apiName, banCfg.Msg),
+		})
+	}
+	return nil
+}
+
+// isPkgAllowed checks if the Go package should be exempted from reporting banned API usages.
+func isPkgAllowed(pkg *types.Package, bannedAPI config.BannedAPI) (bool, error) {
+	for _, e := range bannedAPI.Exemptions {
+		match, err := filepath.Match(e.AllowedPkg, pkg.Path())
+		if err != nil {
+			return false, err
+		}
+		if match {
+			return true, nil
+		}
+	}
+	return false, nil
+}
+
+// bannedAPIMap builds a mapping of fully qualified API name to a list of
+// all its config.BannedAPI entries.
+func bannedAPIMap(bannedAPIs []config.BannedAPI) map[string][]config.BannedAPI {
+	m := make(map[string][]config.BannedAPI)
+	for _, API := range bannedAPIs {
+		m[API.Name] = append(m[API.Name], API)
+	}
+	return m
+}
diff --git a/tools/analyzers/banncheck/config/BUILD.bazel b/tools/analyzers/banncheck/config/BUILD.bazel
new file mode 100644
index 000000000000..8076cbb791d5
--- /dev/null
+++ b/tools/analyzers/banncheck/config/BUILD.bazel
@@ -0,0 +1,8 @@
+load("@io_bazel_rules_go//go:def.bzl", "go_library")
+
+go_library(
+    name = "go_default_library",
+    srcs = ["config.go"],
+    importpath = "kubevirt.io/kubevirt/tools/analyzers/banncheck/config",
+    visibility = ["//visibility:public"],
+)
diff --git a/tools/analyzers/banncheck/config/config.go b/tools/analyzers/banncheck/config/config.go
new file mode 100644
index 000000000000..366c1ad7b6f3
--- /dev/null
+++ b/tools/analyzers/banncheck/config/config.go
@@ -0,0 +1,91 @@
+// Copyright 2020 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// 	https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// TODO: Temporary fork of banncheck from https://github.com/google/go-safeweb/tree/eb79df54b8bc1910ac3bc3fc3328da7c0fb016e1/cmd/bancheck
+package config
+
+import (
+	"encoding/json"
+	"errors"
+	"os"
+)
+
+// Config represents a configuration passed to the linter.
+type Config struct {
+	Imports   []BannedAPI `json:"imports"`
+	Functions []BannedAPI `json:"functions"`
+}
+
+// BannedAPI represents an identifier (e.g. import, function call) that should not be used.
+type BannedAPI struct {
+	Name       string      `json:"name"` // fully qualified identifier name
+	Msg        string      `json:"msg"`  // additional information e.g. rationale for banning
+	Exemptions []Exemption `json:"exemptions"`
+}
+
+// Exemption represents a location that should be exempted from checking for banned APIs.
+type Exemption struct {
+	Justification string `json:"justification"`
+	AllowedPkg    string `json:"allowedPkg"` // Uses Go RegExp https://golang.org/pkg/regexp/syntax
+}
+
+// ReadConfigs reads banned APIs from all files.
+func ReadConfigs(files []string) (*Config, error) {
+	var imports []BannedAPI
+	var fns []BannedAPI
+
+	for _, file := range files {
+		config, err := readCfg(file)
+		if err != nil {
+			return nil, err
+		}
+
+		imports = append(imports, config.Imports...)
+		fns = append(fns, config.Functions...)
+	}
+
+	return &Config{Imports: imports, Functions: fns}, nil
+}
+
+func readCfg(filename string) (*Config, error) {
+	f, err := openFile(filename)
+	if err != nil {
+		return nil, err
+	}
+	defer f.Close()
+
+	return decodeCfg(f)
+}
+
+func openFile(filename string) (*os.File, error) {
+	info, err := os.Stat(filename)
+	if os.IsNotExist(err) {
+		return nil, errors.New("file does not exist")
+	}
+	if info.IsDir() {
+		return nil, errors.New("file is a directory")
+	}
+
+	return os.Open(filename)
+}
+
+func decodeCfg(f *os.File) (*Config, error) {
+	var cfg Config
+	err := json.NewDecoder(f).Decode(&cfg)
+	if err != nil {
+		return nil, err
+	}
+
+	return &cfg, nil
+}
