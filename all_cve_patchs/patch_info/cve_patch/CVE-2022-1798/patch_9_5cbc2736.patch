From 5cbc2736c8655c8f500b035fb37b08f54cec9aee Mon Sep 17 00:00:00 2001
From: Roman Mohr <rmohr@google.com>
Date: Mon, 25 Jul 2022 12:54:15 +0200
Subject: [PATCH] Ensure compatibility with old mount paths of old KubeVirt
 installs

virt-handler needs to detect if mount record files contain old records
which may not have been resolved yet. In that case it has to resolve
them once to ensure that that symlinks, which were valid until now,
would not break unmount operations on already running VMIs.

After an initial load and write, the paths are clean and safe to use.

Signed-off-by: Roman Mohr <rmohr@google.com>
---
 pkg/virt-handler/container-disk/mount.go    | 17 +++++++++++++++++
 pkg/virt-handler/hotplug-disk/mount.go      | 20 +++++++++++++++++++-
 pkg/virt-handler/hotplug-disk/mount_test.go |  4 +++-
 3 files changed, 39 insertions(+), 2 deletions(-)

diff --git a/pkg/virt-handler/container-disk/mount.go b/pkg/virt-handler/container-disk/mount.go
index bfb50496f4ee..e3b3e72090ea 100644
--- a/pkg/virt-handler/container-disk/mount.go
+++ b/pkg/virt-handler/container-disk/mount.go
@@ -59,6 +59,7 @@ type vmiMountTargetEntry struct {
 
 type vmiMountTargetRecord struct {
 	MountTargetEntries []vmiMountTargetEntry `json:"mountTargetEntries"`
+	UsesSafePaths      bool                  `json:"usesSafePaths"`
 }
 
 func NewMounter(isoDetector isolation.PodIsolationDetector, mountStateDir string, clusterConfig *virtconfig.ClusterConfig) Mounter {
@@ -143,6 +144,19 @@ func (m *mounter) getMountTargetRecord(vmi *v1.VirtualMachineInstance) (*vmiMoun
 			return nil, err
 		}
 
+		// XXX: backward compatibility for old unresolved paths, can be removed in July 2023
+		// After a one-time convert and persist, old records are safe too.
+		if !record.UsesSafePaths {
+			record.UsesSafePaths = true
+			for i, entry := range record.MountTargetEntries {
+				safePath, err := safepath.JoinAndResolveWithRelativeRoot("/", entry.TargetFile)
+				if err != nil {
+					return nil, fmt.Errorf("failed converting legacy path to safepath: %v", err)
+				}
+				record.MountTargetEntries[i].TargetFile = unsafepath.UnsafeAbsolute(safePath.Raw())
+			}
+		}
+
 		m.mountRecords[vmi.UID] = &record
 		return &record, nil
 	}
@@ -163,6 +177,9 @@ func (m *mounter) setAddMountTargetRecordHelper(vmi *v1.VirtualMachineInstance,
 	if string(vmi.UID) == "" {
 		return fmt.Errorf("unable to set container disk mounted directories for vmi without uid")
 	}
+	// XXX: backward compatibility for old unresolved paths, can be removed in July 2023
+	// After a one-time convert and persist, old records are safe too.
+	record.UsesSafePaths = true
 
 	recordFile := filepath.Join(m.mountStateDir, string(vmi.UID))
 	fileExists, err := diskutils.FileExists(recordFile)
diff --git a/pkg/virt-handler/hotplug-disk/mount.go b/pkg/virt-handler/hotplug-disk/mount.go
index b80bad03391c..a0a35f1d4772 100644
--- a/pkg/virt-handler/hotplug-disk/mount.go
+++ b/pkg/virt-handler/hotplug-disk/mount.go
@@ -155,6 +155,7 @@ type vmiMountTargetEntry struct {
 
 type vmiMountTargetRecord struct {
 	MountTargetEntries []vmiMountTargetEntry `json:"mountTargetEntries"`
+	UsesSafePaths      bool                  `json:"usesSafePaths"`
 }
 
 // NewVolumeMounter creates a new VolumeMounter
@@ -234,12 +235,25 @@ func (m *volumeMounter) getMountTargetRecord(vmi *v1.VirtualMachineInstance) (*v
 			return nil, err
 		}
 
+		// XXX: backward compatibility for old unresolved paths, can be removed in July 2023
+		// After a one-time convert and persist, old records are safe too.
+		if !record.UsesSafePaths {
+			for i, path := range record.MountTargetEntries {
+				record.UsesSafePaths = true
+				safePath, err := safepath.JoinAndResolveWithRelativeRoot("/", path.TargetFile)
+				if err != nil {
+					return nil, fmt.Errorf("failed converting legacy path to safepath: %v", err)
+				}
+				record.MountTargetEntries[i].TargetFile = unsafepath.UnsafeAbsolute(safePath.Raw())
+			}
+		}
+
 		m.mountRecords[vmi.UID] = &record
 		return &record, nil
 	}
 
 	// not found
-	return &vmiMountTargetRecord{}, nil
+	return &vmiMountTargetRecord{UsesSafePaths: true}, nil
 }
 
 func (m *volumeMounter) setMountTargetRecord(vmi *v1.VirtualMachineInstance, record *vmiMountTargetRecord) error {
@@ -247,6 +261,10 @@ func (m *volumeMounter) setMountTargetRecord(vmi *v1.VirtualMachineInstance, rec
 		return fmt.Errorf(unableFindHotplugMountedDir)
 	}
 
+	// XXX: backward compatibility for old unresolved paths, can be removed in July 2023
+	// After a one-time convert and persist, old records are safe too.
+	record.UsesSafePaths = true
+
 	recordFile := filepath.Join(m.mountStateDir, string(vmi.UID))
 
 	m.mountRecordsLock.Lock()
diff --git a/pkg/virt-handler/hotplug-disk/mount_test.go b/pkg/virt-handler/hotplug-disk/mount_test.go
index 696adce6ac8f..ec6fc93cd7ad 100644
--- a/pkg/virt-handler/hotplug-disk/mount_test.go
+++ b/pkg/virt-handler/hotplug-disk/mount_test.go
@@ -229,7 +229,7 @@ var _ = Describe("HotplugVolume", func() {
 			Expect(err).ToNot(HaveOccurred())
 			res, err := m.getMountTargetRecord(vmi)
 			Expect(err).ToNot(HaveOccurred())
-			Expect(res).To(Equal(&vmiMountTargetRecord{}))
+			Expect(res).To(Equal(&vmiMountTargetRecord{UsesSafePaths: true}))
 		})
 
 		It("deleteMountTargetRecord should remove both record file and entry file", func() {
@@ -879,6 +879,7 @@ var _ = Describe("HotplugVolume", func() {
 						TargetFile: blockVolume,
 					},
 				},
+				UsesSafePaths: true,
 			}
 			expectedBytes, err := json.Marshal(record)
 			Expect(err).ToNot(HaveOccurred())
@@ -1009,6 +1010,7 @@ var _ = Describe("HotplugVolume", func() {
 						TargetFile: blockVolume,
 					},
 				},
+				UsesSafePaths: true,
 			}
 			expectedBytes, err := json.Marshal(record)
 			Expect(err).ToNot(HaveOccurred())
