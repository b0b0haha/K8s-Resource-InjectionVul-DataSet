From b465bffbf7ea86cbc15dad68118eea0721c6af87 Mon Sep 17 00:00:00 2001
From: Roman Mohr <rmohr@google.com>
Date: Tue, 19 Jul 2022 11:11:45 +0200
Subject: [PATCH] Only accept absolute paths for containerdisks

Let virt-api reject relative paths on containerDisk, kernel or initrd
path fields. A relative path would not cause any harm due to the
safepath usage, but it is not clear what it means either.

Signed-off-by: Roman Mohr <rmohr@google.com>
---
 pkg/testutils/mock_config.go                  |  2 +-
 .../admitters/vmi-create-admitter.go          | 52 +++++++++++++++++--
 .../admitters/vmi-create-admitter_test.go     | 46 +++++++++++++++-
 3 files changed, 94 insertions(+), 6 deletions(-)

diff --git a/pkg/testutils/mock_config.go b/pkg/testutils/mock_config.go
index cad8b46f1c90..665b27d91649 100644
--- a/pkg/testutils/mock_config.go
+++ b/pkg/testutils/mock_config.go
@@ -56,7 +56,7 @@ func NewFakeContainerDiskSource() *KVv1.ContainerDiskSource {
 	return &KVv1.ContainerDiskSource{
 		Image:           "fake-image",
 		ImagePullSecret: "fake-pull-secret",
-		Path:            "fake-path",
+		Path:            "/fake-path",
 	}
 }
 
diff --git a/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-create-admitter.go b/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-create-admitter.go
index 6a19c0b28e73..d6c411497f78 100644
--- a/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-create-admitter.go
+++ b/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-create-admitter.go
@@ -23,6 +23,7 @@ import (
 	"encoding/base64"
 	"fmt"
 	"net"
+	"path/filepath"
 	"regexp"
 	"strings"
 
@@ -195,6 +196,7 @@ func ValidateVirtualMachineInstanceSpec(field *k8sfield.Path, spec *v1.VirtualMa
 
 	causes = append(causes, validateDomainSpec(field.Child("domain"), &spec.Domain)...)
 	causes = append(causes, validateVolumes(field.Child("volumes"), spec.Volumes, config)...)
+	causes = append(causes, validateContainerDisks(field, spec)...)
 
 	causes = append(causes, validateAccessCredentials(field.Child("accessCredentials"), spec.AccessCredentials, spec.Volumes)...)
 
@@ -1495,6 +1497,43 @@ func validateRealtime(field *k8sfield.Path, spec *v1.VirtualMachineInstanceSpec)
 	return causes
 }
 
+func validateContainerDisks(field *k8sfield.Path, spec *v1.VirtualMachineInstanceSpec) (causes []metav1.StatusCause) {
+	for idx, volume := range spec.Volumes {
+		if volume.ContainerDisk == nil || volume.ContainerDisk.Path == "" {
+			continue
+		}
+		causes = append(causes, validatePath(field.Child("volumes").Index(idx).Child("conatinerDisk"), volume.ContainerDisk.Path)...)
+	}
+	return causes
+}
+
+func validatePath(field *k8sfield.Path, path string) (causes []metav1.StatusCause) {
+	if path == "/" {
+		causes = append(causes, metav1.StatusCause{
+			Type: metav1.CauseTypeFieldValueInvalid,
+			Message: fmt.Sprintf("%s must not point to root",
+				field.String(),
+			),
+			Field: field.String(),
+		})
+	} else {
+		cleanedPath := filepath.Join("/", path)
+		providedPath := strings.TrimSuffix(path, "/") // Join trims suffix slashes
+
+		if cleanedPath != providedPath {
+			causes = append(causes, metav1.StatusCause{
+				Type: metav1.CauseTypeFieldValueInvalid,
+				Message: fmt.Sprintf("%s must be an absolute path to a file without relative components",
+					field.String(),
+				),
+				Field: field.String(),
+			})
+		}
+	}
+	return causes
+
+}
+
 func validateCPURealtime(field *k8sfield.Path, spec *v1.VirtualMachineInstanceSpec) (causes []metav1.StatusCause) {
 	if !spec.Domain.CPU.DedicatedCPUPlacement {
 		causes = append(causes, metav1.StatusCause{
@@ -2443,13 +2482,13 @@ func validateKernelBoot(field *k8sfield.Path, kernelBoot *v1.KernelBoot) (causes
 	}
 
 	container := kernelBoot.Container
-	containerField := field.Child("container").String()
+	containerField := field.Child("container")
 
 	if container.Image == "" {
 		causes = append(causes, metav1.StatusCause{
 			Type:    metav1.CauseTypeFieldValueRequired,
 			Message: fmt.Sprintf("%s must be defined with an image", containerField),
-			Field:   containerField,
+			Field:   containerField.Child("image").String(),
 		})
 	}
 
@@ -2457,10 +2496,17 @@ func validateKernelBoot(field *k8sfield.Path, kernelBoot *v1.KernelBoot) (causes
 		causes = append(causes, metav1.StatusCause{
 			Type:    metav1.CauseTypeFieldValueRequired,
 			Message: fmt.Sprintf("%s must be defined with at least one of the following: kernelPath, initrdPath", containerField),
-			Field:   containerField,
+			Field:   containerField.String(),
 		})
 	}
 
+	if container.KernelPath != "" {
+		causes = append(causes, validatePath(containerField.Child("kernelPath"), container.KernelPath)...)
+	}
+	if container.InitrdPath != "" {
+		causes = append(causes, validatePath(containerField.Child("initrdPath"), container.InitrdPath)...)
+	}
+
 	return
 }
 
diff --git a/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-create-admitter_test.go b/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-create-admitter_test.go
index 2cb6dc96a441..ddc4200f58f6 100644
--- a/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-create-admitter_test.go
+++ b/pkg/virt-api/webhooks/validating-webhook/admitters/vmi-create-admitter_test.go
@@ -137,6 +137,21 @@ var _ = Describe("Validating VMICreate Admitter", func() {
 		Expect(resp.Result.Message).To(ContainSubstring("no memory requested"))
 	})
 
+	DescribeTable("path validation should fail", func(path string) {
+		Expect(validatePath(k8sfield.NewPath("fake"), path)).To(HaveLen(1))
+	},
+		Entry("if path is not absolute", "a/b/c"),
+		Entry("if path contains relative elements", "/a/b/c/../d"),
+		Entry("if path is root", "/"),
+	)
+
+	DescribeTable("path validation should succeed", func(path string) {
+		Expect(validatePath(k8sfield.NewPath("fake"), path)).To(BeEmpty())
+	},
+		Entry("if path is absolute", "/a/b/c"),
+		Entry("if path is absolute and has trailing slash", "/a/b/c/"),
+	)
+
 	Context("tolerations with eviction policies given", func() {
 		var vmi *v1.VirtualMachineInstance
 		var policyMigrate = v1.EvictionStrategyLiveMigrate
@@ -2340,10 +2355,12 @@ var _ = Describe("Validating VMICreate Admitter", func() {
 				validImage   = "image"
 				withoutImage = ""
 
-				validInitrd   = "initrd"
+				invalidInitrd = "initrd"
+				validInitrd   = "/initrd"
 				withoutInitrd = ""
 
-				validKernel   = "kernel"
+				invalidKernel = "kernel"
+				validKernel   = "/kernel"
 				withoutKernel = ""
 			)
 
@@ -2371,10 +2388,35 @@ var _ = Describe("Validating VMICreate Admitter", func() {
 					createKernelBoot(validKernelArgs, validInitrd, withoutKernel, validImage), true),
 				Entry("with kernel args, with container that has only image defined - should reject",
 					createKernelBoot(validKernelArgs, withoutInitrd, withoutKernel, validImage), false),
+				Entry("with invalid kernel path - should reject",
+					createKernelBoot(validKernelArgs, validInitrd, invalidKernel, validImage), false),
+				Entry("with invalid initrd path - should reject",
+					createKernelBoot(validKernelArgs, invalidInitrd, validKernel, validImage), false),
 				Entry("with kernel args, with container that has initrd and kernel defined but without image - should reject",
 					createKernelBoot(validKernelArgs, validInitrd, validKernel, withoutImage), false),
 			)
 		})
+
+		It("should detect invalid containerDisk paths", func() {
+			spec := &v1.VirtualMachineInstanceSpec{}
+			disk := v1.Disk{
+				Name:   "testdisk",
+				Serial: "SN-1_a",
+			}
+			spec.Domain.Devices.Disks = []v1.Disk{disk}
+			volume := v1.Volume{
+				Name: "testdisk",
+				VolumeSource: v1.VolumeSource{
+					ContainerDisk: testutils.NewFakeContainerDiskSource(),
+				},
+			}
+			volume.ContainerDisk.Path = "invalid"
+
+			spec.Volumes = []v1.Volume{volume}
+			spec.Domain.Devices.Disks = []v1.Disk{disk}
+			causes := ValidateVirtualMachineInstanceSpec(k8sfield.NewPath("fake"), spec, config)
+			Expect(causes).To(HaveLen(1))
+		})
 	})
 
 	Context("with cpu pinning", func() {
