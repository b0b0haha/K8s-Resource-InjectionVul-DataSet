From 0f817a789cdbcb770a401a32b11af5653987d585 Mon Sep 17 00:00:00 2001
From: Roman Mohr <rmohr@google.com>
Date: Tue, 19 Jul 2022 11:26:47 +0200
Subject: [PATCH] Move containerdisk mount operations to safepath operations

Signed-off-by: Roman Mohr <rmohr@google.com>
---
 pkg/container-disk/BUILD.bazel              |   1 -
 pkg/container-disk/container-disk.go        |  11 +-
 pkg/virt-handler/container-disk/BUILD.bazel |   2 +
 pkg/virt-handler/container-disk/mount.go    | 170 +++++++++-----------
 4 files changed, 88 insertions(+), 96 deletions(-)

diff --git a/pkg/container-disk/BUILD.bazel b/pkg/container-disk/BUILD.bazel
index 138db3b701f9..2958637b40b6 100644
--- a/pkg/container-disk/BUILD.bazel
+++ b/pkg/container-disk/BUILD.bazel
@@ -12,7 +12,6 @@ go_library(
         "//pkg/ephemeral-disk:go_default_library",
         "//pkg/ephemeral-disk-utils:go_default_library",
         "//pkg/safepath:go_default_library",
-        "//pkg/unsafepath:go_default_library",
         "//pkg/util:go_default_library",
         "//staging/src/kubevirt.io/api/core/v1:go_default_library",
         "//staging/src/kubevirt.io/client-go/log:go_default_library",
diff --git a/pkg/container-disk/container-disk.go b/pkg/container-disk/container-disk.go
index 12bcbb8408ac..bc37c4bc0ff4 100644
--- a/pkg/container-disk/container-disk.go
+++ b/pkg/container-disk/container-disk.go
@@ -30,12 +30,11 @@ import (
 
 	"kubevirt.io/client-go/log"
 
-	"kubevirt.io/kubevirt/pkg/safepath"
-	"kubevirt.io/kubevirt/pkg/unsafepath"
-
 	kubev1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/api/resource"
 
+	"kubevirt.io/kubevirt/pkg/safepath"
+
 	ephemeraldisk "kubevirt.io/kubevirt/pkg/ephemeral-disk"
 
 	v1 "kubevirt.io/api/core/v1"
@@ -193,7 +192,11 @@ func GetImage(root *safepath.Path, imagePath string) (*safepath.Path, error) {
 		if err != nil {
 			return nil, fmt.Errorf("failed to determine default image path %v: %v", fallbackPath, err)
 		}
-		files, err := os.ReadDir(unsafepath.UnsafeAbsolute(fallbackPath.Raw()))
+		var files []os.DirEntry
+		err = fallbackPath.ExecuteNoFollow(func(safePath string) (err error) {
+			files, err = os.ReadDir(safePath)
+			return err
+		})
 		if err != nil {
 			return nil, fmt.Errorf("failed to check default image path %s: %v", fallbackPath, err)
 		}
diff --git a/pkg/virt-handler/container-disk/BUILD.bazel b/pkg/virt-handler/container-disk/BUILD.bazel
index ebc265c8378e..476389a08b35 100644
--- a/pkg/virt-handler/container-disk/BUILD.bazel
+++ b/pkg/virt-handler/container-disk/BUILD.bazel
@@ -11,6 +11,8 @@ go_library(
     deps = [
         "//pkg/container-disk:go_default_library",
         "//pkg/ephemeral-disk-utils:go_default_library",
+        "//pkg/safepath:go_default_library",
+        "//pkg/unsafepath:go_default_library",
         "//pkg/util:go_default_library",
         "//pkg/virt-config:go_default_library",
         "//pkg/virt-handler/isolation:go_default_library",
diff --git a/pkg/virt-handler/container-disk/mount.go b/pkg/virt-handler/container-disk/mount.go
index 0eee2cc3af83..bfb50496f4ee 100644
--- a/pkg/virt-handler/container-disk/mount.go
+++ b/pkg/virt-handler/container-disk/mount.go
@@ -9,6 +9,9 @@ import (
 	"sync"
 	"time"
 
+	"kubevirt.io/kubevirt/pkg/unsafepath"
+
+	"kubevirt.io/kubevirt/pkg/safepath"
 	"kubevirt.io/kubevirt/pkg/util"
 	virtconfig "kubevirt.io/kubevirt/pkg/virt-config"
 	virt_chroot "kubevirt.io/kubevirt/pkg/virt-handler/virt-chroot"
@@ -208,7 +211,18 @@ func (m *mounter) MountAndVerify(vmi *v1.VirtualMachineInstance) (map[string]*co
 
 	for i, volume := range vmi.Spec.Volumes {
 		if volume.ContainerDisk != nil {
-			targetFile, err := containerdisk.GetDiskTargetPathFromHostView(vmi, i)
+			diskTargetDir, err := containerdisk.GetDiskTargetDirFromHostView(vmi)
+			if err != nil {
+				return nil, err
+			}
+			diskName := containerdisk.GetDiskTargetName(i)
+			// If diskName is a symlink it will fail if the target exists.
+			if err := safepath.TouchAtNoFollow(diskTargetDir, diskName, os.ModePerm); err != nil {
+				if err != nil && !os.IsExist(err) {
+					return nil, fmt.Errorf("failed to create mount point target: %v", err)
+				}
+			}
+			targetFile, err := safepath.JoinNoFollow(diskTargetDir, diskName)
 			if err != nil {
 				return nil, err
 			}
@@ -219,7 +233,7 @@ func (m *mounter) MountAndVerify(vmi *v1.VirtualMachineInstance) (map[string]*co
 			}
 
 			record.MountTargetEntries = append(record.MountTargetEntries, vmiMountTargetEntry{
-				TargetFile: targetFile,
+				TargetFile: unsafepath.UnsafeAbsolute(targetFile.Raw()),
 				SocketFile: sock,
 			})
 		}
@@ -239,14 +253,19 @@ func (m *mounter) MountAndVerify(vmi *v1.VirtualMachineInstance) (map[string]*co
 
 	for i, volume := range vmi.Spec.Volumes {
 		if volume.ContainerDisk != nil {
-			targetFile, err := containerdisk.GetDiskTargetPathFromHostView(vmi, i)
+			diskTargetDir, err := containerdisk.GetDiskTargetDirFromHostView(vmi)
+			if err != nil {
+				return nil, err
+			}
+			diskName := containerdisk.GetDiskTargetName(i)
+			targetFile, err := safepath.JoinNoFollow(diskTargetDir, diskName)
 			if err != nil {
 				return nil, err
 			}
 
 			nodeRes := isolation.NodeIsolationResult()
 
-			if isMounted, err := nodeRes.IsMounted(targetFile); err != nil {
+			if isMounted, err := isolation.IsMounted(targetFile); err != nil {
 				return nil, fmt.Errorf("failed to determine if %s is already mounted: %v", targetFile, err)
 			} else if !isMounted {
 				sock, err := m.socketPathGetter(vmi, i)
@@ -266,14 +285,9 @@ func (m *mounter) MountAndVerify(vmi *v1.VirtualMachineInstance) (map[string]*co
 				if err != nil {
 					return nil, fmt.Errorf("failed to find a sourceFile in containerDisk %v: %v", volume.Name, err)
 				}
-				f, err := os.Create(targetFile)
-				if err != nil {
-					return nil, fmt.Errorf("failed to create mount point target %v: %v", targetFile, err)
-				}
-				f.Close()
 
-				log.DefaultLogger().Object(vmi).Infof("Bind mounting container disk at %s to %s", strings.TrimPrefix(sourceFile, nodeRes.MountRoot()), targetFile)
-				out, err := virt_chroot.MountChroot(strings.TrimPrefix(sourceFile, nodeRes.MountRoot()), targetFile, true).CombinedOutput()
+				log.DefaultLogger().Object(vmi).Infof("Bind mounting container disk at %s to %s", sourceFile, targetFile)
+				out, err := virt_chroot.MountChroot(sourceFile, targetFile, true).CombinedOutput()
 				if err != nil {
 					return nil, fmt.Errorf("failed to bindmount containerDisk %v: %v : %v", volume.Name, string(out), err)
 				}
@@ -297,40 +311,6 @@ func (m *mounter) MountAndVerify(vmi *v1.VirtualMachineInstance) (map[string]*co
 	return disksInfo, nil
 }
 
-// Legacy Unmount unmounts all container disks of a given VMI when the hold HostPath method was in use.
-// This exists for backwards compatibility for VMIs running before a KubeVirt update occurs.
-func (m *mounter) legacyUnmount(vmi *v1.VirtualMachineInstance) error {
-	mountDir := containerdisk.GetLegacyVolumeMountDirOnHost(vmi)
-
-	files, err := os.ReadDir(mountDir)
-	if err != nil && !os.IsNotExist(err) {
-		return fmt.Errorf("failed to list container disk mounts: %v", err)
-	}
-
-	if vmi.UID != "" {
-		for _, file := range files {
-			path := filepath.Join(mountDir, file.Name())
-			if strings.HasSuffix(path, ".sock") {
-				continue
-			}
-			if mounted, err := isolation.NodeIsolationResult().IsMounted(path); err != nil {
-				return fmt.Errorf(failedCheckMountPointFmt, path, err)
-			} else if mounted {
-				// #nosec No risk for attacket injection. Parameters are predefined strings
-				out, err := virt_chroot.UmountChroot(path).CombinedOutput()
-				if err != nil {
-					return fmt.Errorf(failedUnmountFmt, path, string(out), err)
-				}
-			}
-		}
-
-		if err := os.RemoveAll(mountDir); err != nil {
-			return fmt.Errorf("failed to remove containerDisk files: %v", err)
-		}
-	}
-	return nil
-}
-
 // Unmount unmounts all container disks of a given VMI.
 func (m *mounter) Unmount(vmi *v1.VirtualMachineInstance) error {
 	if vmi.UID == "" {
@@ -342,13 +322,6 @@ func (m *mounter) Unmount(vmi *v1.VirtualMachineInstance) error {
 		return fmt.Errorf("error unmounting kernel artifacts: %v", err)
 	}
 
-	// this will catch unmounting a vmi's container disk when
-	// an old VMI is left over after a KubeVirt update
-	err = m.legacyUnmount(vmi)
-	if err != nil {
-		return err
-	}
-
 	record, err := m.getMountTargetRecord(vmi)
 	if err != nil {
 		return err
@@ -361,19 +334,22 @@ func (m *mounter) Unmount(vmi *v1.VirtualMachineInstance) error {
 
 	log.DefaultLogger().Object(vmi).Infof("Found container disk mount entries")
 	for _, entry := range record.MountTargetEntries {
-		path := entry.TargetFile
-		log.DefaultLogger().Object(vmi).Infof("Looking to see if containerdisk is mounted at path %s", path)
-		if mounted, err := isolation.NodeIsolationResult().IsMounted(path); err != nil {
+		log.DefaultLogger().Object(vmi).Infof("Looking to see if containerdisk is mounted at path %s", entry.TargetFile)
+		path, err := safepath.NewFileNoFollow(entry.TargetFile)
+		if err != nil {
+			return fmt.Errorf(failedCheckMountPointFmt, path, err)
+		}
+		_ = path.Close()
+		if mounted, err := isolation.IsMounted(path.Path()); err != nil {
 			return fmt.Errorf(failedCheckMountPointFmt, path, err)
 		} else if mounted {
 			log.DefaultLogger().Object(vmi).Infof("unmounting container disk at path %s", path)
 			// #nosec No risk for attacket injection. Parameters are predefined strings
-			out, err := virt_chroot.UmountChroot(path).CombinedOutput()
+			out, err := virt_chroot.UmountChroot(path.Path()).CombinedOutput()
 			if err != nil {
 				return fmt.Errorf(failedUnmountFmt, path, string(out), err)
 			}
 		}
-
 	}
 	err = m.deleteMountTargetRecord(vmi)
 	if err != nil {
@@ -418,7 +394,19 @@ func (m *mounter) mountKernelArtifacts(vmi *v1.VirtualMachineInstance, verify bo
 	if err != nil {
 		return fmt.Errorf("failed to get disk target dir: %v", err)
 	}
-	targetDir = filepath.Join(targetDir, containerdisk.KernelBootName)
+	if err := safepath.MkdirAtNoFollow(targetDir, containerdisk.KernelBootName, 0755); err != nil {
+		if !os.IsExist(err) {
+			return err
+		}
+	}
+
+	targetDir, err = safepath.JoinNoFollow(targetDir, containerdisk.KernelBootName)
+	if err != nil {
+		return err
+	}
+	if err := safepath.ChpermAtNoFollow(targetDir, 0, 0, 0755); err != nil {
+		return err
+	}
 
 	socketFilePath, err := m.kernelBootSocketPathGetter(vmi)
 	if err != nil {
@@ -427,7 +415,7 @@ func (m *mounter) mountKernelArtifacts(vmi *v1.VirtualMachineInstance, verify bo
 
 	record := vmiMountTargetRecord{
 		MountTargetEntries: []vmiMountTargetEntry{{
-			TargetFile: targetDir,
+			TargetFile: unsafepath.UnsafeAbsolute(targetDir.Raw()),
 			SocketFile: socketFilePath,
 		}},
 	}
@@ -439,11 +427,23 @@ func (m *mounter) mountKernelArtifacts(vmi *v1.VirtualMachineInstance, verify bo
 
 	nodeRes := isolation.NodeIsolationResult()
 
-	targetInitrdPath := filepath.Join(targetDir, filepath.Base(kb.InitrdPath))
-	targetKernelPath := filepath.Join(targetDir, filepath.Base(kb.KernelPath))
+	if err := safepath.TouchAtNoFollow(targetDir, filepath.Base(kb.InitrdPath), 0655); err != nil && !os.IsExist(err) {
+		return err
+	}
+	if err := safepath.TouchAtNoFollow(targetDir, filepath.Base(kb.KernelPath), 0655); err != nil && !os.IsExist(err) {
+		return err
+	}
+	targetInitrdPath, err := safepath.JoinNoFollow(targetDir, filepath.Base(kb.InitrdPath))
+	if err != nil {
+		return err
+	}
+	targetKernelPath, err := safepath.JoinNoFollow(targetDir, filepath.Base(kb.KernelPath))
+	if err != nil {
+		return err
+	}
 
-	areKernelArtifactsMounted := func(artifactsDir string, artifactFiles ...string) (bool, error) {
-		if _, err = os.Stat(artifactsDir); os.IsNotExist(err) {
+	areKernelArtifactsMounted := func(artifactsDir *safepath.Path, artifactFiles ...*safepath.Path) (bool, error) {
+		if _, err = safepath.StatAtNoFollow(artifactsDir); os.IsNotExist(err) {
 			return false, nil
 		} else if err != nil {
 			return false, err
@@ -456,7 +456,7 @@ func (m *mounter) mountKernelArtifacts(vmi *v1.VirtualMachineInstance, verify bo
 	if isMounted, err := areKernelArtifactsMounted(targetDir, targetInitrdPath, targetKernelPath); err != nil {
 		return fmt.Errorf("failed to determine if %s is already mounted: %v", targetDir, err)
 	} else if !isMounted {
-		log.Log.Object(vmi).Infof("mounting kernel artifacts are not mounted - mounting...")
+		log.Log.Object(vmi).Infof("kernel artifacts are not mounted - mounting...")
 
 		res, err := m.podIsolationDetector.DetectForSocket(vmi, socketFilePath)
 		if err != nil {
@@ -467,27 +467,13 @@ func (m *mounter) mountKernelArtifacts(vmi *v1.VirtualMachineInstance, verify bo
 			return fmt.Errorf("failed to detect root mount point of %v on the node: %v", kernelBootName, err)
 		}
 
-		err = os.Mkdir(targetDir, 0755)
-		if err != nil {
-			return fmt.Errorf("failed to create mount point target %v: %v", targetDir, err)
-		}
-
-		mount := func(artifactPath, targetPath string) error {
-			if artifactPath == "" {
-				return nil
-			}
+		mount := func(artifactPath string, targetPath *safepath.Path) error {
 
 			sourcePath, err := containerdisk.GetImage(mountRootPath, artifactPath)
 			if err != nil {
 				return err
 			}
 
-			file, err := os.Create(targetPath)
-			if err != nil {
-				return err
-			}
-			file.Close()
-
 			out, err := virt_chroot.MountChroot(sourcePath, targetPath, true).CombinedOutput()
 			if err != nil {
 				return fmt.Errorf("failed to bindmount %v: %v : %v", kernelBootName, string(out), err)
@@ -533,14 +519,17 @@ func (m *mounter) unmountKernelArtifacts(vmi *v1.VirtualMachineInstance) error {
 		return nil
 	}
 
-	unmount := func(targetDir string, artifactPaths ...string) error {
+	unmount := func(targetDir *safepath.Path, artifactPaths ...string) error {
 		for _, artifactPath := range artifactPaths {
 			if artifactPath == "" {
 				continue
 			}
 
-			targetPath := filepath.Join(targetDir, filepath.Base(artifactPath))
-			if mounted, err := isolation.NodeIsolationResult().IsMounted(targetPath); err != nil {
+			targetPath, err := safepath.JoinNoFollow(targetDir, filepath.Base(artifactPath))
+			if err != nil {
+				return fmt.Errorf(failedCheckMountPointFmt, targetPath, err)
+			}
+			if mounted, err := isolation.IsMounted(targetPath); err != nil {
 				return fmt.Errorf(failedCheckMountPointFmt, targetPath, err)
 			} else if mounted {
 				log.DefaultLogger().Object(vmi).Infof("unmounting container disk at targetDir %s", targetPath)
@@ -555,23 +544,22 @@ func (m *mounter) unmountKernelArtifacts(vmi *v1.VirtualMachineInstance) error {
 	}
 
 	for idx, entry := range record.MountTargetEntries {
-		targetDir := entry.TargetFile
-		if !strings.Contains(targetDir, containerdisk.KernelBootName) {
+		if !strings.Contains(entry.TargetFile, containerdisk.KernelBootName) {
 			continue
 		}
-		log.DefaultLogger().Object(vmi).Infof("unmounting kernel artifacts in path: %s", targetDir)
+		targetDir, err := safepath.NewFileNoFollow(entry.TargetFile)
+		if err != nil {
+			return fmt.Errorf("failed to obtaining a reference to the target directory %q: %v", targetDir, err)
+		}
+		_ = targetDir.Close()
+		log.DefaultLogger().Object(vmi).Infof("unmounting kernel artifacts in path: %v", targetDir)
 
-		if err = unmount(targetDir, kb.InitrdPath, kb.KernelPath); err != nil {
+		if err = unmount(targetDir.Path(), kb.InitrdPath, kb.KernelPath); err != nil {
 			// Not returning here since even if unmount wasn't successful it's better to keep
 			// cleaning the mounted files.
 			log.Log.Object(vmi).Reason(err).Error("unable to unmount kernel artifacts")
 		}
 
-		err = os.RemoveAll(targetDir)
-		if err != nil {
-			log.DefaultLogger().Object(vmi).Infof("cannot delete dir %s. err: %v", targetDir, err)
-		}
-
 		removeSliceElement := func(s []vmiMountTargetEntry, idxToRemove int) []vmiMountTargetEntry {
 			// removes slice element efficiently
 			s[idxToRemove] = s[len(s)-1]
