From 59d54ee7f23d20ce17e6ec08b47458e78715811b Mon Sep 17 00:00:00 2001
From: Roman Mohr <rmohr@google.com>
Date: Tue, 19 Jul 2022 11:28:46 +0200
Subject: [PATCH] Move hotplug code over to safepath usage

Signed-off-by: Roman Mohr <rmohr@google.com>
---
 pkg/hotplug-disk/BUILD.bazel                  |   3 +-
 pkg/hotplug-disk/hotplug-disk.go              |  53 +-
 pkg/hotplug-disk/hotplug-disk_test.go         |   9 +-
 pkg/virt-handler/hotplug-disk/BUILD.bazel     |   8 +-
 .../hotplug-disk/hotplug-disk_suite_test.go   |   2 +-
 pkg/virt-handler/hotplug-disk/mount.go        | 437 ++++++++------
 pkg/virt-handler/hotplug-disk/mount_test.go   | 555 ++++++++++--------
 7 files changed, 591 insertions(+), 476 deletions(-)

diff --git a/pkg/hotplug-disk/BUILD.bazel b/pkg/hotplug-disk/BUILD.bazel
index 1a91a3cedf2c..af49b5ab2a15 100644
--- a/pkg/hotplug-disk/BUILD.bazel
+++ b/pkg/hotplug-disk/BUILD.bazel
@@ -6,7 +6,7 @@ go_library(
     importpath = "kubevirt.io/kubevirt/pkg/hotplug-disk",
     visibility = ["//visibility:public"],
     deps = [
-        "//pkg/ephemeral-disk-utils:go_default_library",
+        "//pkg/safepath:go_default_library",
         "//pkg/util:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/types:go_default_library",
     ],
@@ -21,6 +21,7 @@ go_test(
     embed = [":go_default_library"],
     deps = [
         "//pkg/ephemeral-disk-utils:go_default_library",
+        "//pkg/unsafepath:go_default_library",
         "//staging/src/kubevirt.io/client-go/testutils:go_default_library",
         "//vendor/github.com/onsi/ginkgo/v2:go_default_library",
         "//vendor/github.com/onsi/gomega:go_default_library",
diff --git a/pkg/hotplug-disk/hotplug-disk.go b/pkg/hotplug-disk/hotplug-disk.go
index 4e0749b70853..99a944bf0d18 100644
--- a/pkg/hotplug-disk/hotplug-disk.go
+++ b/pkg/hotplug-disk/hotplug-disk.go
@@ -26,7 +26,8 @@ import (
 
 	"k8s.io/apimachinery/pkg/types"
 
-	diskutils "kubevirt.io/kubevirt/pkg/ephemeral-disk-utils"
+	"kubevirt.io/kubevirt/pkg/safepath"
+
 	"kubevirt.io/kubevirt/pkg/util"
 )
 
@@ -44,9 +45,9 @@ var (
 )
 
 type HotplugDiskManagerInterface interface {
-	GetHotplugTargetPodPathOnHost(virtlauncherPodUID types.UID) (string, error)
-	GetFileSystemDiskTargetPathFromHostView(virtlauncherPodUID types.UID, volumeName string, create bool) (string, error)
-	GetFileSystemDirectoryTargetPathFromHostView(virtlauncherPodUID types.UID, volumeName string, create bool) (string, error)
+	GetHotplugTargetPodPathOnHost(virtlauncherPodUID types.UID) (*safepath.Path, error)
+	GetFileSystemDiskTargetPathFromHostView(virtlauncherPodUID types.UID, volumeName string, create bool) (*safepath.Path, error)
+	GetFileSystemDirectoryTargetPathFromHostView(virtlauncherPodUID types.UID, volumeName string, create bool) (*safepath.Path, error)
 }
 
 func NewHotplugDiskManager() *hotplugDiskManager {
@@ -69,51 +70,39 @@ type hotplugDiskManager struct {
 }
 
 // GetHotplugTargetPodPathOnHost retrieves the target pod (virt-launcher) path on the host.
-func (h *hotplugDiskManager) GetHotplugTargetPodPathOnHost(virtlauncherPodUID types.UID) (string, error) {
+func (h *hotplugDiskManager) GetHotplugTargetPodPathOnHost(virtlauncherPodUID types.UID) (*safepath.Path, error) {
 	podpath := TargetPodBasePath(h.podsBaseDir, virtlauncherPodUID)
-	exists, _ := diskutils.FileExists(podpath)
-	if exists {
-		return podpath, nil
-	}
-
-	return "", fmt.Errorf("Unable to locate target path: %s", podpath)
+	return safepath.JoinAndResolveWithRelativeRoot("/", podpath)
 }
 
 // GetFileSystemDirectoryTargetPathFromHostView gets the directory path in the target pod (virt-launcher) on the host.
-func (h *hotplugDiskManager) GetFileSystemDirectoryTargetPathFromHostView(virtlauncherPodUID types.UID, volumeName string, create bool) (string, error) {
+func (h *hotplugDiskManager) GetFileSystemDirectoryTargetPathFromHostView(virtlauncherPodUID types.UID, volumeName string, create bool) (*safepath.Path, error) {
 	targetPath, err := h.GetHotplugTargetPodPathOnHost(virtlauncherPodUID)
 	if err != nil {
-		return "", err
+		return nil, err
 	}
-	directoryPath := filepath.Join(targetPath, volumeName)
-	exists, err := diskutils.FileExists(directoryPath)
-	if err != nil {
-		return "", err
-	}
-	if !exists && create {
-		if err := os.Mkdir(directoryPath, 0750); err != nil {
-			return "", err
+	_, err = safepath.JoinNoFollow(targetPath, volumeName)
+	if os.IsNotExist(err) && create {
+		if err := safepath.MkdirAtNoFollow(targetPath, volumeName, 0750); err != nil {
+			return nil, err
 		}
+	} else if err != nil {
+		return nil, err
 	}
-	return directoryPath, nil
+	return safepath.JoinNoFollow(targetPath, volumeName)
 }
 
 // GetFileSystemDiskTargetPathFromHostView gets the disk image file in the target pod (virt-launcher) on the host.
-func (h *hotplugDiskManager) GetFileSystemDiskTargetPathFromHostView(virtlauncherPodUID types.UID, volumeName string, create bool) (string, error) {
+func (h *hotplugDiskManager) GetFileSystemDiskTargetPathFromHostView(virtlauncherPodUID types.UID, volumeName string, create bool) (*safepath.Path, error) {
 	targetPath, err := h.GetHotplugTargetPodPathOnHost(virtlauncherPodUID)
 	if err != nil {
 		return targetPath, err
 	}
-	diskFile := filepath.Join(targetPath, fmt.Sprintf("%s.img", volumeName))
-	exists, _ := diskutils.FileExists(diskFile)
-	if !exists && create {
-		file, err := os.Create(diskFile)
-		if err != nil {
-			return diskFile, err
-		}
-		defer file.Close()
+	diskName := fmt.Sprintf("%s.img", volumeName)
+	if err := safepath.TouchAtNoFollow(targetPath, diskName, 0666); err != nil && !os.IsExist(err) {
+		return nil, err
 	}
-	return diskFile, err
+	return safepath.JoinNoFollow(targetPath, diskName)
 }
 
 // SetLocalDirectory creates the base directory where disk images will be mounted when hotplugged. File system volumes will be in
diff --git a/pkg/hotplug-disk/hotplug-disk_test.go b/pkg/hotplug-disk/hotplug-disk_test.go
index 4af3ae5ee279..bbf96c23e558 100644
--- a/pkg/hotplug-disk/hotplug-disk_test.go
+++ b/pkg/hotplug-disk/hotplug-disk_test.go
@@ -29,6 +29,7 @@ import (
 	"k8s.io/apimachinery/pkg/types"
 
 	diskutils "kubevirt.io/kubevirt/pkg/ephemeral-disk-utils"
+	"kubevirt.io/kubevirt/pkg/unsafepath"
 )
 
 var _ = Describe("HotplugDisk", func() {
@@ -80,7 +81,7 @@ var _ = Describe("HotplugDisk", func() {
 		testPath := filepath.Join(TargetPodBasePath(podsBaseDir, testUID), "testvolume")
 		exists, _ := diskutils.FileExists(testPath)
 		Expect(exists).To(BeTrue())
-		Expect(res).To(Equal(testPath))
+		Expect(unsafepath.UnsafeAbsolute(res.Raw())).To(Equal(testPath))
 	})
 
 	It("GetFileSystemDirectoryTargetPathFromHostView should return the volume directory", func() {
@@ -90,7 +91,7 @@ var _ = Describe("HotplugDisk", func() {
 		err = os.MkdirAll(testPath, os.FileMode(0755))
 		res, err := hotplug.GetFileSystemDirectoryTargetPathFromHostView(testUID, "testvolume", false)
 		Expect(err).ToNot(HaveOccurred())
-		Expect(res).To(Equal(testPath))
+		Expect(unsafepath.UnsafeAbsolute(res.Raw())).To(Equal(testPath))
 	})
 
 	It("GetFileSystemDirectoryTargetPathFromHostView should fail on invalid UID", func() {
@@ -107,7 +108,7 @@ var _ = Describe("HotplugDisk", func() {
 		targetPath := filepath.Join(TargetPodBasePath(podsBaseDir, testUID), "testvolume.img")
 		exists, _ := diskutils.FileExists(targetPath)
 		Expect(exists).To(BeTrue())
-		Expect(res).To(Equal(targetPath))
+		Expect(unsafepath.UnsafeAbsolute(res.Raw())).To(Equal(targetPath))
 	})
 
 	It("GetFileSystemDiskTargetPathFromHostView should return the disk image file", func() {
@@ -117,7 +118,7 @@ var _ = Describe("HotplugDisk", func() {
 		err = os.MkdirAll(targetPath, os.FileMode(0755))
 		res, err := hotplug.GetFileSystemDiskTargetPathFromHostView(testUID, "testvolume", false)
 		Expect(err).ToNot(HaveOccurred())
-		Expect(res).To(Equal(targetPath))
+		Expect(unsafepath.UnsafeAbsolute(res.Raw())).To(Equal(targetPath))
 	})
 
 	It("GetFileSystemDiskTargetPathFromHostView should fail on invalid UID", func() {
diff --git a/pkg/virt-handler/hotplug-disk/BUILD.bazel b/pkg/virt-handler/hotplug-disk/BUILD.bazel
index 3bded527842c..450e66127471 100644
--- a/pkg/virt-handler/hotplug-disk/BUILD.bazel
+++ b/pkg/virt-handler/hotplug-disk/BUILD.bazel
@@ -12,7 +12,8 @@ go_library(
     deps = [
         "//pkg/ephemeral-disk-utils:go_default_library",
         "//pkg/hotplug-disk:go_default_library",
-        "//pkg/util:go_default_library",
+        "//pkg/safepath:go_default_library",
+        "//pkg/unsafepath:go_default_library",
         "//pkg/virt-handler/cgroup:go_default_library",
         "//pkg/virt-handler/isolation:go_default_library",
         "//pkg/virt-handler/virt-chroot:go_default_library",
@@ -22,6 +23,7 @@ go_library(
         "//vendor/github.com/opencontainers/runc/libcontainer/configs:go_default_library",
         "//vendor/github.com/opencontainers/runc/libcontainer/devices:go_default_library",
         "//vendor/github.com/pkg/errors:go_default_library",
+        "//vendor/golang.org/x/sys/unix:go_default_library",
         "//vendor/k8s.io/api/core/v1:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/types:go_default_library",
     ],
@@ -38,17 +40,19 @@ go_test(
     deps = [
         "//pkg/ephemeral-disk-utils:go_default_library",
         "//pkg/hotplug-disk:go_default_library",
+        "//pkg/safepath:go_default_library",
+        "//pkg/unsafepath:go_default_library",
         "//pkg/virt-handler/cgroup:go_default_library",
         "//pkg/virt-handler/isolation:go_default_library",
         "//staging/src/kubevirt.io/api/core/v1:go_default_library",
         "//staging/src/kubevirt.io/client-go/api:go_default_library",
-        "//staging/src/kubevirt.io/client-go/log:go_default_library",
         "//staging/src/kubevirt.io/client-go/testutils:go_default_library",
         "//vendor/github.com/golang/mock/gomock:go_default_library",
         "//vendor/github.com/onsi/ginkgo/v2:go_default_library",
         "//vendor/github.com/onsi/gomega:go_default_library",
         "//vendor/github.com/opencontainers/runc/libcontainer/configs:go_default_library",
         "//vendor/github.com/opencontainers/runc/libcontainer/devices:go_default_library",
+        "//vendor/golang.org/x/sys/unix:go_default_library",
         "//vendor/k8s.io/api/core/v1:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/api/equality:go_default_library",
         "//vendor/k8s.io/apimachinery/pkg/types:go_default_library",
diff --git a/pkg/virt-handler/hotplug-disk/hotplug-disk_suite_test.go b/pkg/virt-handler/hotplug-disk/hotplug-disk_suite_test.go
index 9c4b60760aa7..321195557b45 100644
--- a/pkg/virt-handler/hotplug-disk/hotplug-disk_suite_test.go
+++ b/pkg/virt-handler/hotplug-disk/hotplug-disk_suite_test.go
@@ -25,6 +25,6 @@ import (
 	"kubevirt.io/client-go/testutils"
 )
 
-func TestHostDisk(t *testing.T) {
+func TestHotplugDisk(t *testing.T) {
 	testutils.KubeVirtTestSuiteSetup(t)
 }
diff --git a/pkg/virt-handler/hotplug-disk/mount.go b/pkg/virt-handler/hotplug-disk/mount.go
index 56e1ec2a4498..b80bad03391c 100644
--- a/pkg/virt-handler/hotplug-disk/mount.go
+++ b/pkg/virt-handler/hotplug-disk/mount.go
@@ -3,20 +3,21 @@ package hotplug_volume
 import (
 	"encoding/json"
 	"fmt"
-	"io"
 	"io/ioutil"
 	"os"
-	"os/exec"
 	"path/filepath"
-	"strconv"
-	"strings"
 	"sync"
+	"syscall"
 
+	"kubevirt.io/kubevirt/pkg/unsafepath"
+
+	"golang.org/x/sys/unix"
+
+	"kubevirt.io/kubevirt/pkg/safepath"
 	virt_chroot "kubevirt.io/kubevirt/pkg/virt-handler/virt-chroot"
 
 	diskutils "kubevirt.io/kubevirt/pkg/ephemeral-disk-utils"
 	hotplugdisk "kubevirt.io/kubevirt/pkg/hotplug-disk"
-	"kubevirt.io/kubevirt/pkg/util"
 	"kubevirt.io/kubevirt/pkg/virt-handler/cgroup"
 	"kubevirt.io/kubevirt/pkg/virt-handler/isolation"
 
@@ -24,7 +25,6 @@ import (
 
 	"github.com/opencontainers/runc/libcontainer/devices"
 	k8sv1 "k8s.io/api/core/v1"
-
 	"k8s.io/apimachinery/pkg/types"
 
 	v1 "kubevirt.io/api/core/v1"
@@ -39,42 +39,83 @@ const (
 )
 
 var (
-	deviceBasePath = func(podUID types.UID) string {
-		return fmt.Sprintf("/proc/1/root/var/lib/kubelet/pods/%s/volumes/kubernetes.io~empty-dir/hotplug-disks", string(podUID))
+	nodeIsolationResult = func() isolation.IsolationResult {
+		return isolation.NodeIsolationResult()
+	}
+	deviceBasePath = func(podUID types.UID) (*safepath.Path, error) {
+		return safepath.JoinAndResolveWithRelativeRoot("/proc/1/root", fmt.Sprintf("/var/lib/kubelet/pods/%s/volumes/kubernetes.io~empty-dir/hotplug-disks", string(podUID)))
 	}
 
-	sourcePodBasePath = func(podUID types.UID) string {
-		return fmt.Sprintf("/proc/1/root/var/lib/kubelet/pods/%s/volumes", string(podUID))
+	sourcePodBasePath = func(podUID types.UID) (*safepath.Path, error) {
+		return safepath.JoinAndResolveWithRelativeRoot("/proc/1/root", fmt.Sprintf("root/var/lib/kubelet/pods/%s/volumes", string(podUID)))
 	}
 
 	socketPath = func(podUID types.UID) string {
 		return fmt.Sprintf("pods/%s/volumes/kubernetes.io~empty-dir/hotplug-disks/hp.sock", string(podUID))
 	}
 
-	statCommand = func(fileName string) ([]byte, error) {
-		return exec.Command("/usr/bin/stat", fileName, "-L", "-c%t,%T,%a,%F").CombinedOutput()
+	statDevice = func(fileName *safepath.Path) (os.FileInfo, error) {
+		info, err := safepath.StatAtNoFollow(fileName)
+		if err != nil {
+			return nil, err
+		}
+		if info.Mode()&os.ModeDevice == 0 {
+			return info, fmt.Errorf("%v is not a block device", fileName)
+		}
+		return info, nil
+	}
+
+	statSourceDevice = func(fileName *safepath.Path) (os.FileInfo, error) {
+		// we don't know the device name, we only know that it is the only
+		// device in a specific directory, let's look it up
+		var devName string
+		err := fileName.ExecuteNoFollow(func(safePath string) error {
+			entries, err := os.ReadDir(safePath)
+			if err != nil {
+				return err
+			}
+			for _, entry := range entries {
+				info, err := entry.Info()
+				if err != nil {
+					return err
+				}
+				if info.Mode()&os.ModeDevice == 0 {
+					// not a device
+					continue
+				}
+				devName = entry.Name()
+				return nil
+			}
+			return fmt.Errorf("no device in %v", fileName)
+		})
+		if err != nil {
+			return nil, err
+		}
+		devPath, err := safepath.JoinNoFollow(fileName, devName)
+		if err != nil {
+			return nil, err
+		}
+		return statDevice(devPath)
 	}
 
-	mknodCommand = func(deviceName string, major, minor int64, blockDevicePermissions string) ([]byte, error) {
-		output, err := exec.Command("/usr/bin/mknod", "--mode", fmt.Sprintf("0%s", blockDevicePermissions), deviceName, "b", strconv.FormatInt(major, 10), strconv.FormatInt(minor, 10)).CombinedOutput()
-		log.Log.V(3).Infof("running mknod. err: %v, output: %s", err, string(output))
-		return output, err
+	mknodCommand = func(basePath *safepath.Path, deviceName string, dev uint64, blockDevicePermissions os.FileMode) error {
+		return safepath.MknodAtNoFollow(basePath, deviceName, blockDevicePermissions|syscall.S_IFBLK, dev)
 	}
 
-	mountCommand = func(sourcePath, targetPath string) ([]byte, error) {
-		return virt_chroot.MountChroot(strings.TrimPrefix(sourcePath, isolation.NodeIsolationResult().MountRoot()), targetPath, false).CombinedOutput()
+	mountCommand = func(sourcePath, targetPath *safepath.Path) ([]byte, error) {
+		return virt_chroot.MountChroot(sourcePath, targetPath, false).CombinedOutput()
 	}
 
-	unmountCommand = func(diskPath string) ([]byte, error) {
+	unmountCommand = func(diskPath *safepath.Path) ([]byte, error) {
 		return virt_chroot.UmountChroot(diskPath).CombinedOutput()
 	}
 
-	isMounted = func(path string) (bool, error) {
-		return isolation.NodeIsolationResult().IsMounted(path)
+	isMounted = func(path *safepath.Path) (bool, error) {
+		return isolation.IsMounted(path)
 	}
 
-	isBlockDevice = func(path string) (bool, error) {
-		return isolation.NodeIsolationResult().IsBlockDevice(path)
+	isBlockDevice = func(path *safepath.Path) (bool, error) {
+		return isolation.IsBlockDevice(path)
 	}
 
 	isolationDetector = func(path string) isolation.PodIsolationDetector {
@@ -230,11 +271,9 @@ func (m *volumeMounter) setMountTargetRecord(vmi *v1.VirtualMachineInstance, rec
 }
 
 func (m *volumeMounter) writePathToMountRecord(path string, vmi *v1.VirtualMachineInstance, record *vmiMountTargetRecord) error {
-	if path != "" {
-		record.MountTargetEntries = append(record.MountTargetEntries, vmiMountTargetEntry{
-			TargetFile: path,
-		})
-	}
+	record.MountTargetEntries = append(record.MountTargetEntries, vmiMountTargetEntry{
+		TargetFile: path,
+	})
 	if err := m.setMountTargetRecord(vmi, record); err != nil {
 		return err
 	}
@@ -248,12 +287,12 @@ func (m *volumeMounter) mountHotplugVolume(vmi *v1.VirtualMachineInstance, volum
 		if m.isBlockVolume(&vmi.Status, volumeName) {
 			logger.V(4).Infof("Mounting block volume: %s", volumeName)
 			if err := m.mountBlockHotplugVolume(vmi, volumeName, sourceUID, record); err != nil {
-				return err
+				return fmt.Errorf("failed to mount block hotplug volume %s: %v", volumeName, err)
 			}
 		} else {
 			logger.V(4).Infof("Mounting file system volume: %s", volumeName)
 			if err := m.mountFileSystemHotplugVolume(vmi, volumeName, sourceUID, record, mountDirectory); err != nil {
-				return err
+				return fmt.Errorf("failed to mount filesystem hotplug volume %s: %v", volumeName, err)
 			}
 		}
 	}
@@ -335,41 +374,54 @@ func (m *volumeMounter) mountBlockHotplugVolume(vmi *v1.VirtualMachineInstance,
 		return err
 	}
 
-	deviceName := filepath.Join(targetPath, volume)
-
-	isMigrationInProgress := vmi.Status.MigrationState != nil && !vmi.Status.MigrationState.Completed
-
 	cgroupsManager, err := getCgroupManager(vmi)
 	if err != nil {
 		return fmt.Errorf(failedToCreateCgroupManagerErrTemplate, err)
 	}
 
-	if isBlockExists, _ := isBlockDevice(deviceName); !isBlockExists {
-		sourceMajor, sourceMinor, permissions, err := m.getSourceMajorMinor(sourceUID, volume)
+	if _, err := safepath.JoinNoFollow(targetPath, volume); os.IsNotExist(err) {
+		dev, permissions, err := m.getSourceMajorMinor(sourceUID, volume)
 		if err != nil {
 			return err
 		}
-		if err := m.writePathToMountRecord(deviceName, vmi, record); err != nil {
-			return err
-		}
-		// allow block devices
-		if err := m.allowBlockMajorMinor(sourceMajor, sourceMinor, cgroupsManager); err != nil {
+
+		if err := m.writePathToMountRecord(filepath.Join(unsafepath.UnsafeAbsolute(targetPath.Raw()), volume), vmi, record); err != nil {
 			return err
 		}
-		if _, err = m.createBlockDeviceFile(deviceName, sourceMajor, sourceMinor, permissions); err != nil {
+
+		if err := m.createBlockDeviceFile(targetPath, volume, dev, permissions); err != nil && !os.IsExist(err) {
 			return err
 		}
-	} else if isBlockExists && (!m.volumeStatusReady(volume, vmi) || isMigrationInProgress) {
-		// Block device exists already, but the volume is not ready yet, ensure that the device is allowed.
-		sourceMajor, sourceMinor, _, err := m.getSourceMajorMinor(sourceUID, volume)
+		log.DefaultLogger().V(1).Infof("successfully created block device %v", volume)
+	} else if err != nil {
+		return err
+	}
+
+	devicePath, err := safepath.JoinNoFollow(targetPath, volume)
+	if err != nil {
+		return err
+	}
+	if isBlockExists, err := isBlockDevice(devicePath); err != nil {
+		return err
+	} else if !isBlockExists {
+		return fmt.Errorf("target device %v exists but it is not a block device", devicePath)
+	}
+
+	isMigrationInProgress := vmi.Status.MigrationState != nil && !vmi.Status.MigrationState.Completed
+	volumeNotReady := !m.volumeStatusReady(volume, vmi)
+
+	if isMigrationInProgress || volumeNotReady {
+		dev, _, err := m.getSourceMajorMinor(sourceUID, volume)
 		if err != nil {
 			return err
 		}
-		if err := m.allowBlockMajorMinor(sourceMajor, sourceMinor, cgroupsManager); err != nil {
+		// allow block devices
+		if err := m.allowBlockMajorMinor(dev, cgroupsManager); err != nil {
 			return err
 		}
 	}
-	return m.ownershipManager.SetFileOwnership(deviceName)
+
+	return m.ownershipManager.SetFileOwnership(devicePath)
 }
 
 func (m *volumeMounter) volumeStatusReady(volumeName string, vmi *v1.VirtualMachineInstance) bool {
@@ -385,109 +437,42 @@ func (m *volumeMounter) volumeStatusReady(volumeName string, vmi *v1.VirtualMach
 	return true
 }
 
-func (m *volumeMounter) getSourceMajorMinor(sourceUID types.UID, volumeName string) (int64, int64, string, error) {
-	result := make([]int64, 2)
-	perms := ""
-	if sourceUID != types.UID("") {
-		basepath := filepath.Join(deviceBasePath(sourceUID), volumeName)
-		err := filepath.Walk(basepath, func(filePath string, info os.FileInfo, err error) error {
-			if info != nil && !info.IsDir() {
-				// Walk doesn't follow symlinks which is good because I need to massage symlinks
-				linkInfo, err := os.Lstat(filePath)
-				if err != nil {
-					return err
-				}
-				path := filePath
-				if linkInfo.Mode()&os.ModeSymlink != 0 {
-					// Its a symlink, follow it
-					link, err := os.Readlink(filePath)
-					if err != nil {
-						return err
-					}
-					if !strings.HasPrefix(link, util.HostRootMount) {
-						path = filepath.Join(util.HostRootMount, link)
-					} else {
-						path = link
-					}
-				}
-				if m.isBlockFile(path) {
-					result[0], result[1], perms, err = m.getBlockFileMajorMinor(path)
-					// Err != nil means not a block device or unable to determine major/minor, try next file
-					if err == nil {
-						// Successfully located
-						return io.EOF
-					}
-				}
-				return nil
-			}
-			return nil
-		})
-		if err != nil && err != io.EOF {
-			return -1, -1, "", err
-		}
-	}
-	if perms == "" {
-		return -1, -1, "", fmt.Errorf("Unable to find block device")
-	}
-	return result[0], result[1], perms, nil
-}
-
-func (m *volumeMounter) isBlockFile(fileName string) bool {
-	// Stat the file and see if there is no error
-	out, err := statCommand(fileName)
+func (m *volumeMounter) getSourceMajorMinor(sourceUID types.UID, volumeName string) (uint64, os.FileMode, error) {
+	basePath, err := deviceBasePath(sourceUID)
 	if err != nil {
-		// Not a block device skip to next file
-		return false
+		return 0, 0, err
 	}
-	split := strings.Split(string(out), ",")
-	// Verify I got 4 strings
-	if len(split) != 4 {
-		return false
+	devicePath, err := basePath.AppendAndResolveWithRelativeRoot(volumeName)
+	if err != nil {
+		return 0, 0, err
 	}
-	return strings.TrimSpace(split[3]) == "block special file"
+	return m.getBlockFileMajorMinor(devicePath, statSourceDevice)
 }
 
-func (m *volumeMounter) getBlockFileMajorMinor(fileName string) (int64, int64, string, error) {
-	result := make([]int, 2)
-	// Stat the file and see if there is no error
-	out, err := statCommand(fileName)
+func (m *volumeMounter) getBlockFileMajorMinor(devicePath *safepath.Path, getter func(fileName *safepath.Path) (os.FileInfo, error)) (uint64, os.FileMode, error) {
+	fileInfo, err := getter(devicePath)
 	if err != nil {
-		// Not a block device skip to next file
-		return -1, -1, "", err
-	}
-	split := strings.Split(string(out), ",")
-	// Verify I got 4 strings
-	if len(split) != 4 {
-		return -1, -1, "", fmt.Errorf("Output invalid")
+		return 0, 0, err
 	}
-	if strings.TrimSpace(split[3]) != "block special file" {
-		return -1, -1, "", fmt.Errorf("Not a block device")
-	}
-	// Verify that both values are ints.
-	for i := 0; i < 2; i++ {
-		val, err := strconv.ParseInt(split[i], 16, 32)
-		if err != nil {
-			return -1, -1, "", err
-		}
-		result[i] = int(val)
-	}
-	return int64(result[0]), int64(result[1]), split[2], nil
+	info := fileInfo.Sys().(*syscall.Stat_t)
+	return info.Rdev, fileInfo.Mode(), nil
 }
 
-func (m *volumeMounter) removeBlockMajorMinor(major, minor int64, manager cgroup.Manager) error {
-	return m.updateBlockMajorMinor(major, minor, false, manager)
+func (m *volumeMounter) removeBlockMajorMinor(dev uint64, manager cgroup.Manager) error {
+	return m.updateBlockMajorMinor(dev, false, manager)
 }
 
-func (m *volumeMounter) allowBlockMajorMinor(major, minor int64, manager cgroup.Manager) error {
-	return m.updateBlockMajorMinor(major, minor, true, manager)
+func (m *volumeMounter) allowBlockMajorMinor(dev uint64, manager cgroup.Manager) error {
+	return m.updateBlockMajorMinor(dev, true, manager)
 }
 
-func (m *volumeMounter) updateBlockMajorMinor(major, minor int64, allow bool, manager cgroup.Manager) error {
+func (m *volumeMounter) updateBlockMajorMinor(dev uint64, allow bool, manager cgroup.Manager) error {
+
 	var err error
 	deviceRule := &devices.Rule{
 		Type:        devices.BlockDevice,
-		Major:       major,
-		Minor:       minor,
+		Major:       int64(unix.Major(dev)),
+		Minor:       int64(unix.Minor(dev)),
 		Permissions: "rwm",
 		Allow:       allow,
 	}
@@ -505,19 +490,12 @@ func (m *volumeMounter) updateBlockMajorMinor(major, minor int64, allow bool, ma
 	return err
 }
 
-func (m *volumeMounter) createBlockDeviceFile(deviceName string, major, minor int64, blockDevicePermissions string) (string, error) {
-	exists, err := diskutils.FileExists(deviceName)
-	if err != nil {
-		return "", err
-	}
-	if !exists {
-		out, err := mknodCommand(deviceName, major, minor, blockDevicePermissions)
-		if err != nil {
-			log.DefaultLogger().Errorf("Error creating block device file: %s, %v", out, err)
-			return "", err
-		}
+func (m *volumeMounter) createBlockDeviceFile(basePath *safepath.Path, deviceName string, dev uint64, blockDevicePermissions os.FileMode) error {
+	if _, err := safepath.JoinNoFollow(basePath, deviceName); os.IsNotExist(err) {
+		return mknodCommand(basePath, deviceName, dev, blockDevicePermissions)
+	} else {
+		return err
 	}
-	return deviceName, nil
 }
 
 func (m *volumeMounter) mountFileSystemHotplugVolume(vmi *v1.VirtualMachineInstance, volume string, sourceUID types.UID, record *vmiMountTargetRecord, mountDirectory bool) error {
@@ -526,12 +504,12 @@ func (m *volumeMounter) mountFileSystemHotplugVolume(vmi *v1.VirtualMachineInsta
 		// This is not the node the pod is running on.
 		return nil
 	}
-	var target string
+	var target *safepath.Path
 	var err error
 	if mountDirectory {
-		target, err = m.hotplugDiskManager.GetFileSystemDirectoryTargetPathFromHostView(virtlauncherUID, volume, false)
+		target, err = m.hotplugDiskManager.GetFileSystemDirectoryTargetPathFromHostView(virtlauncherUID, volume, true)
 	} else {
-		target, err = m.hotplugDiskManager.GetFileSystemDiskTargetPathFromHostView(virtlauncherUID, volume, false)
+		target, err = m.hotplugDiskManager.GetFileSystemDiskTargetPathFromHostView(virtlauncherUID, volume, true)
 	}
 	if err != nil {
 		return err
@@ -547,7 +525,7 @@ func (m *volumeMounter) mountFileSystemHotplugVolume(vmi *v1.VirtualMachineInsta
 			// to get mounted on the node, and this will error until the volume is mounted.
 			return nil
 		}
-		if err := m.writePathToMountRecord(target, vmi, record); err != nil {
+		if err := m.writePathToMountRecord(unsafepath.UnsafeAbsolute(target.Raw()), vmi, record); err != nil {
 			return err
 		}
 		if mountDirectory {
@@ -563,11 +541,17 @@ func (m *volumeMounter) mountFileSystemHotplugVolume(vmi *v1.VirtualMachineInsta
 			if err != nil {
 				return err
 			}
-			if out, err := mountCommand(filepath.Join(sourcePath, "disk.img"), target); err != nil {
-				return fmt.Errorf("failed to bindmount hotplug-disk %v: %v : %v", volume, string(out), err)
+			sourcePath, err = sourcePath.AppendAndResolveWithRelativeRoot("disk.img")
+			if err != nil {
+				return err
+			}
+			if out, err := mountCommand(sourcePath, target); err != nil {
+				return fmt.Errorf("failed to bindmount hotplug-disk %v to %v: %v : %v", sourcePath, target, string(out), err)
 			}
+			log.DefaultLogger().V(1).Infof("successfully mounted %v", volume)
 		}
 	}
+
 	return m.ownershipManager.SetFileOwnership(target)
 }
 
@@ -587,43 +571,58 @@ func (m *volumeMounter) findVirtlauncherUID(vmi *v1.VirtualMachineInstance) (uid
 	return types.UID("")
 }
 
-func (m *volumeMounter) getSourcePodFilePath(sourceUID types.UID, vmi *v1.VirtualMachineInstance, volume string) (string, error) {
+func (m *volumeMounter) getSourcePodFilePath(sourceUID types.UID, vmi *v1.VirtualMachineInstance, volume string) (*safepath.Path, error) {
 	iso := isolationDetector("/path")
 	isoRes, err := iso.DetectForSocket(vmi, socketPath(sourceUID))
 	if err != nil {
-		return "", err
+		return nil, err
 	}
 	findmounts, err := LookupFindmntInfoByVolume(volume, isoRes.Pid())
 	if err != nil {
-		return "", err
+		return nil, err
+	}
+	mountRoot, err := nodeIsolationResult().MountRoot()
+	if err != nil {
+		return nil, err
 	}
+
 	for _, findmnt := range findmounts {
 		if filepath.Base(findmnt.Target) == volume {
 			source := findmnt.GetSourcePath()
-			isBlock, _ := isBlockDevice(filepath.Join(util.HostRootMount, source))
-			if _, err := os.Stat(filepath.Join(util.HostRootMount, source)); os.IsNotExist(err) || isBlock {
+			path, err := mountRoot.AppendAndResolveWithRelativeRoot(source)
+			exists := !os.IsNotExist(err)
+			if err != nil && !os.IsNotExist(err) {
+				return nil, err
+			}
+
+			isBlock := false
+			if exists {
+				isBlock, _ = isBlockDevice(path)
+			}
+
+			if !exists || isBlock {
 				// file not found, or block device, or directory check if we can find the mount.
 				deviceFindMnt, err := LookupFindmntInfoByDevice(source)
 				if err != nil {
 					// Try the device found from the source
 					deviceFindMnt, err = LookupFindmntInfoByDevice(findmnt.GetSourceDevice())
 					if err != nil {
-						return "", err
+						return nil, err
 					}
 					// Check if the path was relative to the device.
-					if _, err := os.Stat(filepath.Join(util.HostRootMount, source)); err != nil {
-						return filepath.Join(deviceFindMnt[0].Target, source), nil
+					if !exists {
+						return mountRoot.AppendAndResolveWithRelativeRoot(deviceFindMnt[0].Target, source)
 					}
-					return "", err
+					return nil, err
 				}
-				return deviceFindMnt[0].Target, nil
+				return mountRoot.AppendAndResolveWithRelativeRoot(deviceFindMnt[0].Target)
 			} else {
-				return source, nil
+				return path, nil
 			}
 		}
 	}
 	// Did not find the disk image file, return error
-	return "", fmt.Errorf("unable to find source disk image path for pod %s", sourceUID)
+	return nil, fmt.Errorf("unable to find source disk image path for pod %s", sourceUID)
 }
 
 // Unmount unmounts all hotplug disk that are no longer part of the VMI
@@ -645,6 +644,13 @@ func (m *volumeMounter) Unmount(vmi *v1.VirtualMachineInstance) error {
 
 		basePath, err := m.hotplugDiskManager.GetHotplugTargetPodPathOnHost(virtlauncherUID)
 		if err != nil {
+			if os.IsNotExist(err) {
+				// no mounts left, the base path does not even exist anymore
+				if err := m.deleteMountTargetRecord(vmi); err != nil {
+					return fmt.Errorf("failed to delete mount target records: %v", err)
+				}
+				return nil
+			}
 			return err
 		}
 		for _, volumeStatus := range vmi.Status.VolumeStatus {
@@ -652,40 +658,57 @@ func (m *volumeMounter) Unmount(vmi *v1.VirtualMachineInstance) error {
 				continue
 			}
 			if m.isBlockVolume(&vmi.Status, volumeStatus.Name) {
-				path := filepath.Join(basePath, volumeStatus.Name)
-				currentHotplugPaths[path] = virtlauncherUID
+				path, err := safepath.JoinNoFollow(basePath, volumeStatus.Name)
+				if err != nil {
+					return err
+				}
+				currentHotplugPaths[unsafepath.UnsafeAbsolute(path.Raw())] = virtlauncherUID
 			} else if m.isDirectoryMounted(&vmi.Status, volumeStatus.Name) {
 				path, err := m.hotplugDiskManager.GetFileSystemDirectoryTargetPathFromHostView(virtlauncherUID, volumeStatus.Name, false)
+				if os.IsExist(err) {
+					// already unmounted or never mounted
+					continue
+				}
 				if err != nil {
 					return err
 				}
-				currentHotplugPaths[path] = virtlauncherUID
+				currentHotplugPaths[unsafepath.UnsafeAbsolute(path.Raw())] = virtlauncherUID
 			} else {
 				path, err := m.hotplugDiskManager.GetFileSystemDiskTargetPathFromHostView(virtlauncherUID, volumeStatus.Name, false)
+				if os.IsNotExist(err) {
+					// already unmounted or never mounted
+					continue
+				}
 				if err != nil {
 					return err
 				}
-				currentHotplugPaths[path] = virtlauncherUID
+				currentHotplugPaths[unsafepath.UnsafeAbsolute(path.Raw())] = virtlauncherUID
 			}
 		}
 		newRecord := vmiMountTargetRecord{
 			MountTargetEntries: make([]vmiMountTargetEntry, 0),
 		}
 		for _, entry := range record.MountTargetEntries {
-			diskPath := entry.TargetFile
-			if _, ok := currentHotplugPaths[diskPath]; !ok {
-				if m.isBlockFile(diskPath) {
+			fd, err := safepath.NewFileNoFollow(entry.TargetFile)
+			if err != nil {
+				return err
+			}
+			fd.Close()
+			diskPath := fd.Path()
+
+			if _, ok := currentHotplugPaths[unsafepath.UnsafeAbsolute(diskPath.Raw())]; !ok {
+				if blockDevice, err := isBlockDevice(diskPath); err != nil {
+					return err
+				} else if blockDevice {
 					if err := m.unmountBlockHotplugVolumes(diskPath, vmi); err != nil {
 						return err
 					}
-				} else {
-					if err := m.unmountFileSystemHotplugVolumes(diskPath); err != nil {
-						return err
-					}
+				} else if err := m.unmountFileSystemHotplugVolumes(diskPath); err != nil {
+					return err
 				}
 			} else {
 				newRecord.MountTargetEntries = append(newRecord.MountTargetEntries, vmiMountTargetEntry{
-					TargetFile: diskPath,
+					TargetFile: unsafepath.UnsafeAbsolute(diskPath.Raw()),
 				})
 			}
 		}
@@ -701,7 +724,7 @@ func (m *volumeMounter) Unmount(vmi *v1.VirtualMachineInstance) error {
 	return nil
 }
 
-func (m *volumeMounter) unmountFileSystemHotplugVolumes(diskPath string) error {
+func (m *volumeMounter) unmountFileSystemHotplugVolumes(diskPath *safepath.Path) error {
 	if mounted, err := isMounted(diskPath); err != nil {
 		return fmt.Errorf("failed to check mount point for hotplug disk %v: %v", diskPath, err)
 	} else if mounted {
@@ -709,7 +732,7 @@ func (m *volumeMounter) unmountFileSystemHotplugVolumes(diskPath string) error {
 		if err != nil {
 			return fmt.Errorf("failed to unmount hotplug disk %v: %v : %v", diskPath, string(out), err)
 		}
-		err = os.Remove(diskPath)
+		err = safepath.UnlinkAtNoFollow(diskPath)
 		if err != nil {
 			return fmt.Errorf("failed to remove hotplug disk directory %v: %v : %v", diskPath, string(out), err)
 		}
@@ -718,23 +741,22 @@ func (m *volumeMounter) unmountFileSystemHotplugVolumes(diskPath string) error {
 	return nil
 }
 
-func (m *volumeMounter) unmountBlockHotplugVolumes(diskPath string, vmi *v1.VirtualMachineInstance) error {
+func (m *volumeMounter) unmountBlockHotplugVolumes(diskPath *safepath.Path, vmi *v1.VirtualMachineInstance) error {
 	cgroupsManager, err := getCgroupManager(vmi)
 	if err != nil {
 		return fmt.Errorf(failedToCreateCgroupManagerErrTemplate, err)
 	}
 
 	// Get major and minor so we can deny the container.
-	major, minor, _, err := m.getBlockFileMajorMinor(diskPath)
+	dev, _, err := m.getBlockFileMajorMinor(diskPath, statDevice)
 	if err != nil {
 		return err
 	}
 	// Delete block device file
-	err = os.Remove(diskPath)
-	if err != nil {
+	if err := safepath.UnlinkAtNoFollow(diskPath); err != nil {
 		return err
 	}
-	if err := m.removeBlockMajorMinor(major, minor, cgroupsManager); err != nil {
+	if err := m.removeBlockMajorMinor(dev, cgroupsManager); err != nil {
 		return err
 	}
 	return nil
@@ -755,14 +777,25 @@ func (m *volumeMounter) UnmountAll(vmi *v1.VirtualMachineInstance) error {
 		}
 
 		for _, entry := range record.MountTargetEntries {
-			diskPath := entry.TargetFile
-			if m.isBlockFile(diskPath) {
-				if err := m.unmountBlockHotplugVolumes(diskPath, vmi); err != nil {
+			diskPath, err := safepath.NewFileNoFollow(entry.TargetFile)
+			if err != nil {
+				if os.IsNotExist(err) {
+					logger.Infof("Device %v is not mounted anymore, continuing.", entry.TargetFile)
+					continue
+				}
+				logger.Infof("Unable to unmount volume at path %s: %v", entry.TargetFile, err)
+				continue
+			}
+			diskPath.Close()
+			if isBlock, err := isBlockDevice(diskPath.Path()); err != nil {
+				logger.Infof("Unable to remove block device at path %s: %v", diskPath, err)
+			} else if isBlock {
+				if err := m.unmountBlockHotplugVolumes(diskPath.Path(), vmi); err != nil {
 					logger.Infof("Unable to remove block device at path %s: %v", diskPath, err)
 					// Don't return error, try next.
 				}
 			} else {
-				if err := m.unmountFileSystemHotplugVolumes(diskPath); err != nil {
+				if err := m.unmountFileSystemHotplugVolumes(diskPath.Path()); err != nil {
 					logger.Infof("Unable to unmount volume at path %s: %v", diskPath, err)
 					// Don't return error, try next.
 				}
@@ -784,16 +817,38 @@ func (m *volumeMounter) IsMounted(vmi *v1.VirtualMachineInstance, volume string,
 	}
 	targetPath, err := m.hotplugDiskManager.GetHotplugTargetPodPathOnHost(virtlauncherUID)
 	if err != nil {
+		if os.IsNotExist(err) {
+			return false, nil
+		}
 		return false, err
 	}
 	if m.isBlockVolume(&vmi.Status, volume) {
-		deviceName := filepath.Join(targetPath, volume)
+		deviceName, err := safepath.JoinNoFollow(targetPath, volume)
+		if err != nil {
+			if os.IsNotExist(err) {
+				return false, nil
+			}
+			return false, err
+		}
 		isBlockExists, _ := isBlockDevice(deviceName)
 		return isBlockExists, nil
 	}
-
 	if m.isDirectoryMounted(&vmi.Status, volume) {
-		return isMounted(filepath.Join(targetPath, volume))
+		path, err := safepath.JoinNoFollow(targetPath, volume)
+		if err != nil {
+			if os.IsNotExist(err) {
+				return false, nil
+			}
+			return false, err
+		}
+		return isMounted(path)
+	}
+	path, err := safepath.JoinNoFollow(targetPath, fmt.Sprintf("%s.img", volume))
+	if err != nil {
+		if os.IsNotExist(err) {
+			return false, nil
+		}
+		return false, err
 	}
-	return isMounted(filepath.Join(targetPath, fmt.Sprintf("%s.img", volume)))
+	return isMounted(path)
 }
diff --git a/pkg/virt-handler/hotplug-disk/mount_test.go b/pkg/virt-handler/hotplug-disk/mount_test.go
index 2d5984ecf509..696adce6ac8f 100644
--- a/pkg/virt-handler/hotplug-disk/mount_test.go
+++ b/pkg/virt-handler/hotplug-disk/mount_test.go
@@ -22,11 +22,18 @@ package hotplug_volume
 import (
 	"encoding/json"
 	"fmt"
+	"io/fs"
 	"io/ioutil"
 	"os"
 	"path/filepath"
+	"strings"
+	"syscall"
+	"time"
 
-	"kubevirt.io/client-go/log"
+	"golang.org/x/sys/unix"
+
+	"kubevirt.io/kubevirt/pkg/safepath"
+	"kubevirt.io/kubevirt/pkg/unsafepath"
 
 	"github.com/golang/mock/gomock"
 	. "github.com/onsi/ginkgo/v2"
@@ -55,18 +62,21 @@ const (
 )
 
 var (
-	tempDir              string
-	orgIsoDetector       = isolationDetector
-	orgDeviceBasePath    = deviceBasePath
-	orgStatCommand       = statCommand
-	orgMknodCommand      = mknodCommand
-	orgSourcePodBasePath = sourcePodBasePath
-	orgMountCommand      = mountCommand
-	orgUnMountCommand    = unmountCommand
-	orgIsMounted         = isMounted
-	orgIsBlockDevice     = isBlockDevice
-	orgFindMntByVolume   = findMntByVolume
-	orgFindMntByDevice   = findMntByDevice
+	tempDir                string
+	tmpDirSafe             *safepath.Path
+	orgIsoDetector         = isolationDetector
+	orgDeviceBasePath      = deviceBasePath
+	orgStatSourceCommand   = statSourceDevice
+	orgStatCommand         = statDevice
+	orgMknodCommand        = mknodCommand
+	orgSourcePodBasePath   = sourcePodBasePath
+	orgMountCommand        = mountCommand
+	orgUnMountCommand      = unmountCommand
+	orgIsMounted           = isMounted
+	orgIsBlockDevice       = isBlockDevice
+	orgFindMntByVolume     = findMntByVolume
+	orgFindMntByDevice     = findMntByDevice
+	orgNodeIsolationResult = nodeIsolationResult
 )
 
 var _ = Describe("HotplugVolume", func() {
@@ -128,6 +138,10 @@ var _ = Describe("HotplugVolume", func() {
 		cgroupManagerMock.EXPECT().GetCgroupVersion().AnyTimes()
 		expectedCgroupRule = nil
 		ownershipManager = diskutils.NewMockOwnershipManagerInterface(ctrl)
+
+		nodeIsolationResult = func() isolation.IsolationResult {
+			return isolation.NewIsolationResult(os.Getpid(), os.Getppid())
+		}
 	})
 
 	Context("mount target records", func() {
@@ -141,6 +155,8 @@ var _ = Describe("HotplugVolume", func() {
 		BeforeEach(func() {
 			tempDir, err = ioutil.TempDir("", "hotplug-volume-test")
 			Expect(err).ToNot(HaveOccurred())
+			tmpDirSafe, err = safepath.JoinAndResolveWithRelativeRoot(tempDir)
+			Expect(err).ToNot(HaveOccurred())
 			vmi = api.NewMinimalVMI("fake-vmi")
 			vmi.UID = "1234"
 
@@ -241,13 +257,15 @@ var _ = Describe("HotplugVolume", func() {
 		BeforeEach(func() {
 			tempDir, err = ioutil.TempDir("", "hotplug-volume-test")
 			Expect(err).ToNot(HaveOccurred())
+			tmpDirSafe, err = safepath.JoinAndResolveWithRelativeRoot(tempDir)
+			Expect(err).ToNot(HaveOccurred())
 			vmi = api.NewMinimalVMI("fake-vmi")
 			vmi.UID = "1234"
 			activePods := make(map[types.UID]string, 0)
 			activePods["abcd"] = "host"
 			vmi.Status.ActivePods = activePods
 
-			targetPodPath = filepath.Join(tempDir, "abcd/volumes/kubernetes.io~empty-dir/hotplug-disks/testvolume")
+			targetPodPath = filepath.Join(tempDir, "abcd/volumes/kubernetes.io~empty-dir/hotplug-disks/")
 			err = os.MkdirAll(targetPodPath, 0755)
 			Expect(err).ToNot(HaveOccurred())
 
@@ -261,11 +279,11 @@ var _ = Describe("HotplugVolume", func() {
 				ownershipManager:   ownershipManager,
 			}
 
-			deviceBasePath = func(sourceUID types.UID) string {
-				return filepath.Join(tempDir, string(sourceUID), "volumes")
+			deviceBasePath = func(sourceUID types.UID) (*safepath.Path, error) {
+				return newDir(tempDir, string(sourceUID), "volumes")
 			}
-			statCommand = func(fileName string) ([]byte, error) {
-				return []byte("6,6,0777,block special file"), nil
+			statSourceDevice = func(fileName *safepath.Path) (os.FileInfo, error) {
+				return fakeStat(true, 0777, 123456), nil
 			}
 
 		})
@@ -273,9 +291,10 @@ var _ = Describe("HotplugVolume", func() {
 		AfterEach(func() {
 			_ = os.RemoveAll(tempDir)
 			deviceBasePath = orgDeviceBasePath
-			statCommand = orgStatCommand
+			statSourceDevice = orgStatSourceCommand
 			mknodCommand = orgMknodCommand
 			isBlockDevice = orgIsBlockDevice
+			nodeIsolationResult = orgNodeIsolationResult
 		})
 
 		It("isBlockVolume should determine if we have a block volume", func() {
@@ -329,30 +348,39 @@ var _ = Describe("HotplugVolume", func() {
 			targetPodPath := hotplugdisk.TargetPodBasePath(tempDir, m.findVirtlauncherUID(vmi))
 			err = os.MkdirAll(targetPodPath, 0755)
 			Expect(err).ToNot(HaveOccurred())
-			deviceFile := filepath.Join(tempDir, string(blockSourcePodUID), "volumes", "testvolume", "file")
-			err = os.MkdirAll(filepath.Dir(deviceFile), 0755)
-			Expect(err).ToNot(HaveOccurred())
-			err = ioutil.WriteFile(deviceFile, []byte("test"), 0644)
+			deviceFile, err := newFile(tempDir, string(blockSourcePodUID), "volumes", "testvolume", "file")
 			Expect(err).ToNot(HaveOccurred())
+			Expect(ioutil.WriteFile(unsafepath.UnsafeAbsolute(deviceFile.Raw()), []byte("test"), 0644))
 
-			targetDevicePath := filepath.Join(targetPodPath, "testvolume")
+			vmi.Status.VolumeStatus = []v1.VolumeStatus{{Name: "testvolume", HotplugVolume: &v1.HotplugVolumeStatus{}}}
+			targetDevicePath, err := newFile(targetPodPath, "testvolume")
+			Expect(err).ToNot(HaveOccurred())
 			ownershipManager.EXPECT().SetFileOwnership(targetDevicePath)
+			statSourceDevice = func(fileName *safepath.Path) (os.FileInfo, error) {
+				return fakeStat(true, 0666, 123456), nil
+			}
+			statDevice = func(fileName *safepath.Path) (os.FileInfo, error) {
+				return fakeStat(true, 0666, 123456), nil
+			}
+			isBlockDevice = func(fileName *safepath.Path) (bool, error) {
+				return true, nil
+			}
 
 			By("Mounting and validating expected rule is set")
 			setExpectedCgroupRuns(2)
-			expectCgroupRule(devices.BlockDevice, 6, 6, true)
+			expectCgroupRule(devices.BlockDevice, 482, 64, true)
 			err = m.mountBlockHotplugVolume(vmi, "testvolume", blockSourcePodUID, record)
 			Expect(err).ToNot(HaveOccurred())
 
 			By("Unmounting, we verify the reverse process happens")
-			expectCgroupRule(devices.BlockDevice, 6, 6, false)
-			err = m.unmountBlockHotplugVolumes(targetDevicePath, vmi)
+			expectCgroupRule(devices.BlockDevice, 482, 64, false)
+			err = m.unmountBlockHotplugVolumes(deviceFile, vmi)
 			Expect(err).ToNot(HaveOccurred())
 		})
 
 		It("getSourceMajorMinor should return an error if no uid", func() {
 			vmi.UID = ""
-			_, _, _, err := m.getSourceMajorMinor("fghij", "invalid")
+			_, _, err := m.getSourceMajorMinor("fghij", "invalid")
 			Expect(err).To(HaveOccurred())
 		})
 
@@ -362,161 +390,121 @@ var _ = Describe("HotplugVolume", func() {
 			Expect(err).ToNot(HaveOccurred())
 			err = ioutil.WriteFile(deviceFile, []byte("test"), 0644)
 			Expect(err).ToNot(HaveOccurred())
-			major, minor, perm, err := m.getSourceMajorMinor("fghij", "test-volume")
+			numbers, perm, err := m.getSourceMajorMinor("fghij", "test-volume")
 			Expect(err).ToNot(HaveOccurred())
-			Expect(major).To(Equal(int64(6)))
-			Expect(minor).To(Equal(int64(6)))
-			Expect(perm).To(Equal("0777"))
+			Expect(unix.Major(numbers)).To(Equal(uint32(482)))
+			Expect(unix.Minor(numbers)).To(Equal(uint32(64)))
+			Expect(perm & 0777).To(Equal(os.FileMode(0777)))
 		})
 
 		It("getSourceMajorMinor should return error if file doesn't exists", func() {
 			deviceFile := filepath.Join(tempDir, "fghij", "volumes", "file")
 			err = os.MkdirAll(filepath.Dir(deviceFile), 0755)
 			Expect(err).ToNot(HaveOccurred())
-			major, minor, perm, err := m.getSourceMajorMinor("fghij", "test-volume")
+			_, _, err := m.getSourceMajorMinor("fghij", "test-volume")
 			Expect(err).To(HaveOccurred())
-			Expect(major).To(Equal(int64(-1)))
-			Expect(minor).To(Equal(int64(-1)))
-			Expect(perm).To(Equal(""))
+			Expect(os.IsNotExist(err)).To(BeTrue())
 		})
 
-		It("isBlockFile should return proper value based on stat command", func() {
-			testFileName := "test-file"
-			statCommand = func(fileName string) ([]byte, error) {
-				Expect(testFileName).To(Equal(fileName))
-				return []byte("6,6,0777,block special file"), nil
-			}
-			Expect(m.isBlockFile(testFileName)).To(BeTrue())
-			statCommand = func(fileName string) ([]byte, error) {
-				Expect(testFileName).To(Equal(fileName))
-				return []byte("6,6,0777,block special file"), fmt.Errorf("Error")
-			}
-			Expect(m.isBlockFile(testFileName)).To(BeFalse())
-			statCommand = func(fileName string) ([]byte, error) {
-				Expect(testFileName).To(Equal(fileName))
-				return []byte("6,6,0777"), nil
-			}
-			Expect(m.isBlockFile(testFileName)).To(BeFalse())
-			statCommand = func(fileName string) ([]byte, error) {
-				Expect(testFileName).To(Equal(fileName))
-				return []byte("6,6,0777,block special"), nil
-			}
-			Expect(m.isBlockFile(testFileName)).To(BeFalse())
-		})
-
-		DescribeTable("Should return proper values", func(stat func(fileName string) ([]byte, error), major, minor int, perm string, expectErr bool) {
-			testFileName := "test-file"
-			statCommand = stat
-			majorRes, minorRes, permRes, err := m.getBlockFileMajorMinor(testFileName)
+		DescribeTable("Should return proper values", func(stat func(safePath *safepath.Path) (os.FileInfo, error), major, minor uint32, perm os.FileMode, expectErr bool) {
+			statSourceDevice = stat
+			testFileName, err := newFile(tempDir, "test-file")
+			Expect(err).ToNot(HaveOccurred())
+			numbers, permRes, err := m.getBlockFileMajorMinor(testFileName, statSourceDevice)
 			if expectErr {
 				Expect(err).To(HaveOccurred())
 			} else {
 				Expect(err).ToNot(HaveOccurred())
 			}
-			// Values are translated to hex (245->580, 32->50)
-			Expect(int64(major)).To(Equal(majorRes))
-			Expect(int64(minor)).To(Equal(minorRes))
-			Expect(perm).To(Equal(permRes))
+			Expect(unix.Major(numbers)).To(Equal(major))
+			Expect(unix.Minor(numbers)).To(Equal(minor))
+			Expect(perm).To(Equal(permRes & 0777))
 		},
-			Entry("Should return values if stat command successful", func(fileName string) ([]byte, error) {
-				return []byte("245,32,0664,block special file"), nil
-			}, 581, 50, "0664", false),
-			Entry("Should not return values if stat command errors", func(fileName string) ([]byte, error) {
-				return []byte("245,32,0664,block special file"), fmt.Errorf("Error")
-			}, -1, -1, "", true),
-			Entry("Should not return values if stat command doesn't return 4 fields", func(fileName string) ([]byte, error) {
-				return []byte("245,32,0664"), nil
-			}, -1, -1, "", true),
-			Entry("Should not return values if stat command doesn't return block special file", func(fileName string) ([]byte, error) {
-				return []byte("245,32,0664, block file"), nil
-			}, -1, -1, "", true),
-			Entry("Should not return values if stat command doesn't int major", func(fileName string) ([]byte, error) {
-				return []byte("kk,32,0664,block special file"), nil
-			}, -1, -1, "", true),
-			Entry("Should not return values if stat command doesn't int minor", func(fileName string) ([]byte, error) {
-				return []byte("254,gg,0664,block special file"), nil
-			}, -1, -1, "", true),
+			Entry("Should return values if stat command successful", func(safePath *safepath.Path) (os.FileInfo, error) {
+				return fakeStat(true, 0664, 123456), nil
+			}, uint32(482), uint32(64), os.FileMode(0664), false),
+			Entry("Should not return error if stat command errors", func(safePath *safepath.Path) (os.FileInfo, error) {
+				return fakeStat(true, 0664, 123456), fmt.Errorf("Error")
+			}, uint32(0), uint32(0), os.FileMode(0), true),
 		)
 
 		It("should write properly to allow/deny files if able", func() {
 			setExpectedCgroupRuns(2)
-			expectCgroupRule(devices.BlockDevice, 34, 53, true)
-			err = m.allowBlockMajorMinor(34, 53, cgroupManagerMock)
+			expectCgroupRule(devices.BlockDevice, 482, 64, true)
+			err = m.allowBlockMajorMinor(123456, cgroupManagerMock)
 			Expect(err).ToNot(HaveOccurred())
 
-			expectCgroupRule(devices.BlockDevice, 34, 53, false)
-			err = m.removeBlockMajorMinor(34, 53, cgroupManagerMock)
+			expectCgroupRule(devices.BlockDevice, 482, 64, false)
+			err = m.removeBlockMajorMinor(123456, cgroupManagerMock)
 			Expect(err).ToNot(HaveOccurred())
 		})
 
 		It("Should remove the block device and permissions on unmount", func() {
 			By("Initializing cgroup mock files")
-			statCommand = func(fileName string) ([]byte, error) {
-				return []byte("245,32,0664,block special file"), nil
+			statSourceDevice = func(fileName *safepath.Path) (os.FileInfo, error) {
+				return fakeStat(true, 0664, 123456), nil
 			}
-			deviceFileName := filepath.Join(tempDir, "devicefile")
-			_, err := os.Create(deviceFileName)
+			deviceFileName, err := newFile(tempDir, "devicefile")
 			Expect(err).ToNot(HaveOccurred())
 
 			By("Mounting and validating expected rule is set")
 			setExpectedCgroupRuns(1)
-			expectCgroupRule(devices.BlockDevice, 581, 50, false)
+			expectCgroupRule(devices.BlockDevice, 482, 64, false)
 			err = m.unmountBlockHotplugVolumes(deviceFileName, vmi)
 			Expect(err).ToNot(HaveOccurred())
 		})
 
 		It("Should return error if deviceFile doesn' exist", func() {
-			statCommand = func(fileName string) ([]byte, error) {
-				return []byte("245,32,0664,block special file"), nil
+			statSourceDevice = func(fileName *safepath.Path) (os.FileInfo, error) {
+				return fakeStat(true, 0664, 123456), nil
 			}
-			deviceFileName := filepath.Join(tempDir, "devicefile")
+			deviceFileName, err := newFile(tempDir, "devicefile")
+			Expect(err).ToNot(HaveOccurred())
+			os.Remove(unsafepath.UnsafeAbsolute(deviceFileName.Raw()))
 			err = m.unmountBlockHotplugVolumes(deviceFileName, vmi)
 			Expect(err).To(HaveOccurred())
 			Expect(err.Error()).To(ContainSubstring("no such file or directory"))
 		})
 
 		It("Should attempt to create a block device file if it doesn't exist", func() {
-			testFile := filepath.Join(tempDir, "testfile")
-			testMajor := int64(100)
-			testMinor := int64(53)
-			testPerm := "0664"
-			mknodCommand = func(deviceName string, major, minor int64, blockDevicePermissions string) ([]byte, error) {
-				Expect(deviceName).To(Equal(testFile))
-				Expect(major).To(Equal(testMajor))
-				Expect(minor).To(Equal(testMinor))
+			testMajor := uint32(482)
+			testMinor := uint32(64)
+			testPerm := os.FileMode(0664)
+			mknodCommand = func(basePath *safepath.Path, deviceName string, dev uint64, blockDevicePermissions os.FileMode) error {
+				Expect(basePath).To(Equal(tmpDirSafe))
+				Expect(deviceName).To(Equal("testfile"))
+				Expect(unix.Major(dev)).To(Equal(testMajor))
+				Expect(unix.Minor(dev)).To(Equal(testMinor))
 				Expect(blockDevicePermissions).To(Equal(testPerm))
-				return []byte("Yay"), nil
+				return nil
 			}
-			res, err := m.createBlockDeviceFile(testFile, testMajor, testMinor, testPerm)
+			err := m.createBlockDeviceFile(tmpDirSafe, "testfile", 123456, testPerm)
 			Expect(err).ToNot(HaveOccurred())
-			Expect(res).To(Equal(testFile))
 
-			mknodCommand = func(deviceName string, major, minor int64, blockDevicePermissions string) ([]byte, error) {
-				Expect(deviceName).To(Equal(testFile))
-				Expect(major).To(Equal(testMajor))
-				Expect(minor).To(Equal(testMinor))
+			mknodCommand = func(basePath *safepath.Path, deviceName string, dev uint64, blockDevicePermissions os.FileMode) error {
+				Expect(basePath).To(Equal(tmpDirSafe))
+				Expect(deviceName).To(Equal("testfile"))
+				Expect(unix.Major(dev)).To(Equal(testMajor))
+				Expect(unix.Minor(dev)).To(Equal(testMinor))
 				Expect(blockDevicePermissions).To(Equal(testPerm))
-				return []byte("Yay"), fmt.Errorf("Error creating block file")
+				return fmt.Errorf("Error creating block file")
 			}
-			_, err = m.createBlockDeviceFile(testFile, testMajor, testMinor, testPerm)
+			err = m.createBlockDeviceFile(tmpDirSafe, "testfile", 123456, testPerm)
 			Expect(err).To(HaveOccurred())
 			Expect(err.Error()).To(ContainSubstring("Error creating block file"))
 		})
 
 		It("Should not attempt to create a block device file if it exists", func() {
 			testFile := filepath.Join(tempDir, "testfile")
-			testMajor := int64(100)
-			testMinor := int64(53)
-			testPerm := "0664"
+			testPerm := os.FileMode(0664)
 			_, err = os.Create(testFile)
 			Expect(err).ToNot(HaveOccurred())
-			mknodCommand = func(deviceName string, major, minor int64, blockDevicePermissions string) ([]byte, error) {
+			mknodCommand = func(basePath *safepath.Path, deviceName string, dev uint64, blockDevicePermissions os.FileMode) error {
 				Fail("Should not get called")
-				return nil, nil
+				return nil
 			}
-			res, err := m.createBlockDeviceFile(testFile, testMajor, testMinor, testPerm)
+			err := m.createBlockDeviceFile(tmpDirSafe, "testfile", 123456, testPerm)
 			Expect(err).ToNot(HaveOccurred())
-			Expect(res).To(Equal(testFile))
 		})
 
 	})
@@ -527,20 +515,24 @@ var _ = Describe("HotplugVolume", func() {
 			err           error
 			vmi           *v1.VirtualMachineInstance
 			record        *vmiMountTargetRecord
-			targetPodPath string
+			targetPodPath *safepath.Path
 		)
 
 		BeforeEach(func() {
 			tempDir, err = ioutil.TempDir("", "hotplug-volume-test")
 			Expect(err).ToNot(HaveOccurred())
+			tmpDirSafe, err = safepath.JoinAndResolveWithRelativeRoot(tempDir)
+			Expect(err).ToNot(HaveOccurred())
+
+			volumeDir, err := newDir(tempDir, "volumes")
+			Expect(err).ToNot(HaveOccurred())
 			vmi = api.NewMinimalVMI("fake-vmi")
 			vmi.UID = "1234"
 			activePods := make(map[types.UID]string, 0)
 			activePods["abcd"] = "host"
 			vmi.Status.ActivePods = activePods
 
-			targetPodPath = filepath.Join(tempDir, "abcd/volumes/kubernetes.io~empty-dir/hotplug-disks")
-			err = os.MkdirAll(targetPodPath, 0755)
+			targetPodPath, err = newDir(tempDir, "abcd/volumes/kubernetes.io~empty-dir/hotplug-disks")
 			Expect(err).ToNot(HaveOccurred())
 
 			record = &vmiMountTargetRecord{}
@@ -552,12 +544,13 @@ var _ = Describe("HotplugVolume", func() {
 				ownershipManager:   ownershipManager,
 			}
 
-			deviceBasePath = func(sourceUID types.UID) string {
-				return filepath.Join(tempDir, string(sourceUID), "volumes")
+			deviceBasePath = func(podUID types.UID) (*safepath.Path, error) {
+				return volumeDir, nil
+
 			}
 			isolationDetector = func(path string) isolation.PodIsolationDetector {
 				return &mockIsolationDetector{
-					pid: 1,
+					pid: os.Getpid(),
 				}
 			}
 		})
@@ -574,20 +567,19 @@ var _ = Describe("HotplugVolume", func() {
 		})
 
 		It("getSourcePodFile should find the disk.img file, if it exists", func() {
-			path := filepath.Join(tempDir, "ghfjk", "volumes")
-			err = os.MkdirAll(path, 0755)
-			sourcePodBasePath = func(podUID types.UID) string {
-				return path
+			path, err := newDir(tempDir, "ghfjk", "volumes")
+			Expect(err).ToNot(HaveOccurred())
+			sourcePodBasePath = func(podUID types.UID) (*safepath.Path, error) {
+				return path, nil
 			}
 			findMntByVolume = func(volumeName string, pid int) ([]byte, error) {
-				return []byte(fmt.Sprintf(findmntByVolumeRes, "pvc", path)), nil
+				return []byte(fmt.Sprintf(findmntByVolumeRes, "pvc", unsafepath.UnsafeAbsolute(path.Raw()))), nil
 			}
-			diskFile := filepath.Join(path, "disk.img")
-			_, err := os.Create(diskFile)
+			_, err = newFile(unsafepath.UnsafeAbsolute(path.Raw()), "disk.img")
 			Expect(err).ToNot(HaveOccurred())
 			file, err := m.getSourcePodFilePath("ghfjk", vmi, "pvc")
 			Expect(err).ToNot(HaveOccurred())
-			Expect(file).To(Equal(path))
+			Expect(unsafepath.UnsafeRelative(file.Raw())).To(Equal(unsafepath.UnsafeAbsolute(path.Raw())))
 		})
 
 		It("getSourcePodFile should return error if no UID", func() {
@@ -596,82 +588,77 @@ var _ = Describe("HotplugVolume", func() {
 		})
 
 		It("getSourcePodFile should return error if disk.img doesn't exist", func() {
-			path := filepath.Join(tempDir, "ghfjk", "volumes")
-			err = os.MkdirAll(path, 0755)
-			sourcePodBasePath = func(podUID types.UID) string {
-				return path
-			}
+			path, err := newDir(tempDir, "ghfjk", "volumes")
 			Expect(err).ToNot(HaveOccurred())
-			_, err := m.getSourcePodFilePath("ghfjk", vmi, "")
+			sourcePodBasePath = func(podUID types.UID) (*safepath.Path, error) {
+				return path, nil
+			}
+			_, err = m.getSourcePodFilePath("ghfjk", vmi, "")
 			Expect(err).To(HaveOccurred())
 		})
 
 		It("getSourcePodFile should return error if iso detection returns error", func() {
-			expectedPath := filepath.Join(tempDir, "ghfjk", "volumes")
-			err = os.MkdirAll(expectedPath, 0755)
-			sourcePodBasePath = func(podUID types.UID) string {
-				return expectedPath
+			expectedPath, err := newDir(tempDir, "ghfjk", "volumes")
+			Expect(err).ToNot(HaveOccurred())
+			sourcePodBasePath = func(podUID types.UID) (*safepath.Path, error) {
+				return expectedPath, nil
 			}
 			isolationDetector = func(path string) isolation.PodIsolationDetector {
 				return &mockIsolationDetector{
-					pid: 40,
+					pid: 9999,
 				}
 			}
 
-			Expect(err).ToNot(HaveOccurred())
-			_, err := m.getSourcePodFilePath("ghfjk", vmi, "")
+			_, err = m.getSourcePodFilePath("ghfjk", vmi, "")
 			Expect(err).To(HaveOccurred())
 			Expect(err.Error()).To(ContainSubstring("isolation error"))
 		})
 
 		It("getSourcePodFile should return error if find mounts returns error", func() {
-			expectedPath := filepath.Join(tempDir, "ghfjk", "volumes")
-			err = os.MkdirAll(expectedPath, 0755)
-			sourcePodBasePath = func(podUID types.UID) string {
-				return expectedPath
+			expectedPath, err := newDir(tempDir, "ghfjk", "volumes")
+			Expect(err).ToNot(HaveOccurred())
+			sourcePodBasePath = func(podUID types.UID) (*safepath.Path, error) {
+				return expectedPath, nil
 			}
 			findMntByVolume = func(volumeName string, pid int) ([]byte, error) {
 				return []byte(""), fmt.Errorf("findmnt error")
 			}
-
-			Expect(err).ToNot(HaveOccurred())
-			_, err := m.getSourcePodFilePath("ghfjk", vmi, "")
+			_, err = m.getSourcePodFilePath("ghfjk", vmi, "")
 			Expect(err).To(HaveOccurred())
 			Expect(err.Error()).To(ContainSubstring("findmnt error"))
 		})
 
 		It("getSourcePodFile should return the findmnt value", func() {
-			expectedPath := filepath.Join(tempDir, "ghfjk", "volumes")
-			err = os.MkdirAll(expectedPath, 0755)
-			sourcePodBasePath = func(podUID types.UID) string {
-				return expectedPath
+			expectedPath, err := newDir(tempDir, "ghfjk", "volumes")
+			Expect(err).ToNot(HaveOccurred())
+			sourcePodBasePath = func(podUID types.UID) (*safepath.Path, error) {
+				return expectedPath, nil
 			}
 			findMntByVolume = func(volumeName string, pid int) ([]byte, error) {
-				return []byte(fmt.Sprintf(findmntByVolumeRes, "pvc", expectedPath)), nil
+				return []byte(fmt.Sprintf(findmntByVolumeRes, "pvc", unsafepath.UnsafeAbsolute(expectedPath.Raw()))), nil
 			}
 
-			Expect(err).ToNot(HaveOccurred())
 			res, err := m.getSourcePodFilePath("ghfjk", vmi, "pvc")
 			Expect(err).ToNot(HaveOccurred())
-			Expect(res).To(Equal(expectedPath))
+			Expect(unsafepath.UnsafeRelative(res.Raw())).To(Equal(unsafepath.UnsafeAbsolute(expectedPath.Raw())))
 		})
 
 		It("should properly mount and unmount filesystem", func() {
 			sourcePodUID := "ghfjk"
-			path := filepath.Join(tempDir, sourcePodUID, "volumes", "disk.img")
-			err = os.MkdirAll(path, 0755)
-			sourcePodBasePath = func(podUID types.UID) string {
-				return path
+			path, err := newDir(tempDir, sourcePodUID, "volumes")
+			Expect(err).ToNot(HaveOccurred())
+			sourcePodBasePath = func(podUID types.UID) (*safepath.Path, error) {
+				return path, nil
 			}
-			diskFile := filepath.Join(path, "disk.img")
-			_, err := os.Create(diskFile)
+			diskFile, err := newFile(unsafepath.UnsafeAbsolute(path.Raw()), "disk.img")
 			Expect(err).ToNot(HaveOccurred())
 			findMntByVolume = func(volumeName string, pid int) ([]byte, error) {
-				return []byte(fmt.Sprintf(findmntByVolumeRes, "testvolume", path)), nil
+				return []byte(fmt.Sprintf(findmntByVolumeRes, "testvolume", unsafepath.UnsafeAbsolute(path.Raw()))), nil
 			}
-			targetFilePath := filepath.Join(targetPodPath, "testvolume.img")
-			mountCommand = func(sourcePath, targetPath string) ([]byte, error) {
-				Expect(sourcePath).To(Equal(diskFile))
+			targetFilePath, err := newFile(unsafepath.UnsafeAbsolute(targetPodPath.Raw()), "testvolume.img")
+			Expect(err).ToNot(HaveOccurred())
+			mountCommand = func(sourcePath, targetPath *safepath.Path) ([]byte, error) {
+				Expect(unsafepath.UnsafeRelative(sourcePath.Raw())).To(Equal(unsafepath.UnsafeAbsolute(diskFile.Raw())))
 				Expect(targetPath).To(Equal(targetFilePath))
 				return []byte("Success"), nil
 			}
@@ -680,28 +667,27 @@ var _ = Describe("HotplugVolume", func() {
 			err = m.mountFileSystemHotplugVolume(vmi, "testvolume", types.UID(sourcePodUID), record, false)
 			Expect(err).ToNot(HaveOccurred())
 			Expect(record.MountTargetEntries).To(HaveLen(1))
-			Expect(record.MountTargetEntries[0].TargetFile).To(Equal(targetFilePath))
+			Expect(record.MountTargetEntries[0].TargetFile).To(Equal(unsafepath.UnsafeAbsolute(targetFilePath.Raw())))
 
-			unmountCommand = func(diskPath string) ([]byte, error) {
+			unmountCommand = func(diskPath *safepath.Path) ([]byte, error) {
 				Expect(targetFilePath).To(Equal(diskPath))
 				return []byte("Success"), nil
 			}
 
-			isMounted = func(diskPath string) (bool, error) {
+			isMounted = func(diskPath *safepath.Path) (bool, error) {
 				Expect(targetFilePath).To(Equal(diskPath))
 				return true, nil
 			}
 
-			err = m.unmountFileSystemHotplugVolumes(record.MountTargetEntries[0].TargetFile)
+			err = m.unmountFileSystemHotplugVolumes(targetFilePath)
 			Expect(err).ToNot(HaveOccurred())
-			_, err = os.Stat(targetFilePath)
-			Expect(err).To(HaveOccurred())
 		})
 
 		It("unmountFileSystemHotplugVolumes should return error if isMounted returns error", func() {
-			testPath := "test"
-			isMounted = func(diskPath string) (bool, error) {
-				Expect(testPath).To(Equal(diskPath))
+			testPath, err := newFile(tempDir, "test")
+			Expect(err).ToNot(HaveOccurred())
+			isMounted = func(path *safepath.Path) (bool, error) {
+				Expect(testPath).To(Equal(path))
 				return false, fmt.Errorf("isMounted error")
 			}
 
@@ -711,8 +697,9 @@ var _ = Describe("HotplugVolume", func() {
 		})
 
 		It("unmountFileSystemHotplugVolumes should return nil if isMounted returns false", func() {
-			testPath := "test"
-			isMounted = func(diskPath string) (bool, error) {
+			testPath, err := newFile(tempDir, "test")
+			Expect(err).ToNot(HaveOccurred())
+			isMounted = func(diskPath *safepath.Path) (bool, error) {
 				Expect(testPath).To(Equal(diskPath))
 				return false, nil
 			}
@@ -722,12 +709,13 @@ var _ = Describe("HotplugVolume", func() {
 		})
 
 		It("unmountFileSystemHotplugVolumes should return error if unmountCommand returns error", func() {
-			testPath := "test"
-			isMounted = func(diskPath string) (bool, error) {
+			testPath, err := newFile(tempDir, "test")
+			Expect(err).ToNot(HaveOccurred())
+			isMounted = func(diskPath *safepath.Path) (bool, error) {
 				Expect(testPath).To(Equal(diskPath))
 				return true, nil
 			}
-			unmountCommand = func(diskPath string) ([]byte, error) {
+			unmountCommand = func(diskPath *safepath.Path) ([]byte, error) {
 				return []byte("Failure"), fmt.Errorf("unmount error")
 			}
 
@@ -748,6 +736,8 @@ var _ = Describe("HotplugVolume", func() {
 		BeforeEach(func() {
 			tempDir, err = ioutil.TempDir("", "hotplug-volume-test")
 			Expect(err).ToNot(HaveOccurred())
+			tmpDirSafe, err = safepath.JoinAndResolveWithRelativeRoot(tempDir)
+			Expect(err).ToNot(HaveOccurred())
 			vmi = api.NewMinimalVMI("fake-vmi")
 			vmi.UID = "1234"
 			activePods := make(map[types.UID]string, 0)
@@ -766,15 +756,18 @@ var _ = Describe("HotplugVolume", func() {
 				ownershipManager:   ownershipManager,
 			}
 
-			deviceBasePath = func(sourceUID types.UID) string {
-				return filepath.Join(tempDir, string(sourceUID), "volumes")
+			deviceBasePath = func(podUID types.UID) (*safepath.Path, error) {
+				return newDir(tempDir, string(podUID), "volumes")
 			}
-			statCommand = func(fileName string) ([]byte, error) {
-				return []byte("6,6,0777,block special file"), nil
+			statSourceDevice = func(fileName *safepath.Path) (os.FileInfo, error) {
+				return fakeStat(true, 0777, 123456), nil
+			}
+			statDevice = func(fileName *safepath.Path) (os.FileInfo, error) {
+				return fakeStat(true, 0777, 123456), nil
 			}
 			isolationDetector = func(path string) isolation.PodIsolationDetector {
 				return &mockIsolationDetector{
-					pid: 1,
+					pid: os.Getpid(),
 				}
 			}
 		})
@@ -786,14 +779,15 @@ var _ = Describe("HotplugVolume", func() {
 			mountCommand = orgMountCommand
 			unmountCommand = orgUnMountCommand
 			isMounted = orgIsMounted
-			statCommand = orgStatCommand
+			statSourceDevice = orgStatSourceCommand
+			statDevice = orgStatCommand
 			mknodCommand = orgMknodCommand
 			isBlockDevice = orgIsBlockDevice
 			findMntByVolume = orgFindMntByVolume
 		})
 
 		It("mount and umount should work for filesystem volumes", func() {
-			setExpectedCgroupRuns(3)
+			setExpectedCgroupRuns(2)
 
 			sourcePodUID := types.UID("klmno")
 			volumeStatuses := make([]v1.VolumeStatus, 0)
@@ -823,52 +817,53 @@ var _ = Describe("HotplugVolume", func() {
 				},
 			})
 			vmi.Status.VolumeStatus = volumeStatuses
-			deviceBasePath = func(sourceUID types.UID) string {
-				return filepath.Join(tempDir, string(sourceUID), "volumeDevices")
+			deviceBasePath = func(podUID types.UID) (*safepath.Path, error) {
+				return newDir(tempDir, string(podUID), "volumeDevices")
 			}
-			blockDevicePath := filepath.Join(tempDir, string(sourcePodUID), "volumeDevices", "blockvolume")
-			fileSystemPath := filepath.Join(tempDir, string(sourcePodUID), "volumes", "disk.img")
-			By(fmt.Sprintf("Creating block path: %s", blockDevicePath))
-			err = os.MkdirAll(blockDevicePath, 0755)
+			blockDevicePath, err := newDir(tempDir, string(sourcePodUID), "volumeDevices", "blockvolume")
 			Expect(err).ToNot(HaveOccurred())
-			By(fmt.Sprintf("Creating filesystem path: %s", fileSystemPath))
-			err = os.MkdirAll(fileSystemPath, 0755)
+			fileSystemPath, err := newDir(tempDir, string(sourcePodUID), "volumes")
 			Expect(err).ToNot(HaveOccurred())
 
-			deviceFile := filepath.Join(blockDevicePath, "blockvolumefile")
-			err = ioutil.WriteFile(deviceFile, []byte("test"), 0644)
+			deviceFile, err := newFile(unsafepath.UnsafeAbsolute(blockDevicePath.Raw()), "blockvolumefile")
+			Expect(err).ToNot(HaveOccurred())
+			err = ioutil.WriteFile(unsafepath.UnsafeAbsolute(deviceFile.Raw()), []byte("test"), 0644)
 			Expect(err).ToNot(HaveOccurred())
 
-			sourcePodBasePath = func(podUID types.UID) string {
+			sourcePodBasePath = func(podUID types.UID) (*safepath.Path, error) {
 				if podUID == sourcePodUID {
-					return blockDevicePath
+					return blockDevicePath, nil
 				}
-				return fileSystemPath
+				return fileSystemPath, nil
 			}
 			findMntByVolume = func(volumeName string, pid int) ([]byte, error) {
-				return []byte(fmt.Sprintf(findmntByVolumeRes, "filesystemvolume", fileSystemPath)), nil
+				return []byte(fmt.Sprintf(findmntByVolumeRes, "filesystemvolume", unsafepath.UnsafeAbsolute(fileSystemPath.Raw()))), nil
 			}
 
-			diskFile := filepath.Join(fileSystemPath, "disk.img")
-			_, err = os.Create(diskFile)
+			diskFile, err := newFile(unsafepath.UnsafeAbsolute(fileSystemPath.Raw()), "disk.img")
 			Expect(err).ToNot(HaveOccurred())
-			mknodCommand = func(deviceName string, major, minor int64, blockDevicePermissions string) ([]byte, error) {
-				Expect(os.MkdirAll(deviceName, 0755)).To(Succeed())
-				return []byte("Yay"), nil
+			mknodCommand = func(basePath *safepath.Path, deviceName string, dev uint64, blockDevicePermissions os.FileMode) error {
+				_, err := newFile(unsafepath.UnsafeAbsolute(basePath.Raw()), deviceName)
+				Expect(err).ToNot(HaveOccurred())
+				return nil
 			}
+
 			blockVolume := filepath.Join(targetPodPath, "blockvolume")
 			targetFilePath := filepath.Join(targetPodPath, "filesystemvolume.img")
-			mountCommand = func(sourcePath, targetPath string) ([]byte, error) {
-				Expect(sourcePath).To(Equal(filepath.Join(fileSystemPath, "disk.img")))
-				Expect(targetPath).To(Equal(targetFilePath))
+			isBlockDevice = func(path *safepath.Path) (bool, error) {
+				return strings.Contains(unsafepath.UnsafeAbsolute(path.Raw()), "blockvolume"), nil
+			}
+			mountCommand = func(sourcePath, targetPath *safepath.Path) ([]byte, error) {
+				Expect(unsafepath.UnsafeRelative(sourcePath.Raw())).To(Equal(unsafepath.UnsafeAbsolute(diskFile.Raw())))
+				Expect(unsafepath.UnsafeAbsolute(targetPath.Raw())).To(Equal(targetFilePath))
 				return []byte("Success"), nil
 			}
 
 			expectedPaths := []string{targetFilePath, blockVolume}
 			capturedPaths := []string{}
 
-			ownershipManager.EXPECT().SetFileOwnership(gomock.Any()).Times(2).DoAndReturn(func(path string) error {
-				capturedPaths = append(capturedPaths, path)
+			ownershipManager.EXPECT().SetFileOwnership(gomock.Any()).Times(2).DoAndReturn(func(path *safepath.Path) error {
+				capturedPaths = append(capturedPaths, unsafepath.UnsafeAbsolute(path.Raw()))
 				return nil
 			})
 
@@ -922,12 +917,9 @@ var _ = Describe("HotplugVolume", func() {
 
 		It("unmountAll should cleanup regardless of vmi volumestatuses", func() {
 			setExpectedCgroupRuns(2)
-			log.DefaultLogger().Infof("tempdir: %s", tempDir)
+
 			sourcePodUID := types.UID("klmno")
 			volumeStatuses := make([]v1.VolumeStatus, 0)
-			mknodCommand = func(deviceName string, major, minor int64, blockDevicePermissions string) ([]byte, error) {
-				return []byte("Yay"), nil
-			}
 			volumeStatuses = append(volumeStatuses, v1.VolumeStatus{
 				Name: "permanent",
 			})
@@ -954,43 +946,53 @@ var _ = Describe("HotplugVolume", func() {
 				},
 			})
 			vmi.Status.VolumeStatus = volumeStatuses
-			deviceBasePath = func(sourceUID types.UID) string {
-				return filepath.Join(tempDir, string(sourceUID), "volumeDevices")
+			deviceBasePath = func(podUID types.UID) (*safepath.Path, error) {
+				return newDir(tempDir, string(podUID), "volumeDevices")
 			}
-			blockDevicePath := filepath.Join(tempDir, string(sourcePodUID), "volumeDevices", "blockvolume")
-			fileSystemPath := filepath.Join(tempDir, string(sourcePodUID), "volumes")
-			err = os.MkdirAll(blockDevicePath, 0755)
+			blockDevicePath, err := newDir(tempDir, string(sourcePodUID), "volumeDevices", "blockvolume")
 			Expect(err).ToNot(HaveOccurred())
-			err = os.MkdirAll(fileSystemPath, 0755)
+			fileSystemPath, err := newDir(tempDir, string(sourcePodUID), "volumes")
 			Expect(err).ToNot(HaveOccurred())
-			findMntByVolume = func(volumeName string, pid int) ([]byte, error) {
-				return []byte(fmt.Sprintf(findmntByVolumeRes, "filesystemvolume", fileSystemPath)), nil
-			}
 
-			deviceFile := filepath.Join(blockDevicePath, "file")
-			err = ioutil.WriteFile(deviceFile, []byte("test"), 0644)
+			deviceFile, err := newFile(unsafepath.UnsafeAbsolute(blockDevicePath.Raw()), "blockvolumefile")
+			Expect(err).ToNot(HaveOccurred())
+			err = ioutil.WriteFile(unsafepath.UnsafeAbsolute(deviceFile.Raw()), []byte("test"), 0644)
 			Expect(err).ToNot(HaveOccurred())
-			sourcePodBasePath = func(podUID types.UID) string {
+
+			sourcePodBasePath = func(podUID types.UID) (*safepath.Path, error) {
 				if podUID == sourcePodUID {
-					return blockDevicePath
+					return blockDevicePath, nil
 				}
-				return fileSystemPath
+				return fileSystemPath, nil
 			}
-			diskFile := filepath.Join(fileSystemPath, "disk.img")
-			_, err = os.Create(diskFile)
+			findMntByVolume = func(volumeName string, pid int) ([]byte, error) {
+				return []byte(fmt.Sprintf(findmntByVolumeRes, "filesystemvolume", unsafepath.UnsafeAbsolute(fileSystemPath.Raw()))), nil
+			}
+
+			diskFile, err := newFile(unsafepath.UnsafeAbsolute(fileSystemPath.Raw()), "disk.img")
 			Expect(err).ToNot(HaveOccurred())
+			mknodCommand = func(basePath *safepath.Path, deviceName string, dev uint64, blockDevicePermissions os.FileMode) error {
+				_, err := newFile(unsafepath.UnsafeAbsolute(basePath.Raw()), deviceName)
+				Expect(err).ToNot(HaveOccurred())
+				return nil
+			}
+
 			blockVolume := filepath.Join(targetPodPath, "blockvolume")
 			targetFilePath := filepath.Join(targetPodPath, "filesystemvolume.img")
-			mountCommand = func(sourcePath, targetPath string) ([]byte, error) {
-				Expect(sourcePath).To(Equal(filepath.Join(fileSystemPath, "disk.img")))
-				Expect(targetPath).To(Equal(targetFilePath))
+			isBlockDevice = func(path *safepath.Path) (bool, error) {
+				return strings.Contains(unsafepath.UnsafeAbsolute(path.Raw()), "blockvolume"), nil
+			}
+			mountCommand = func(sourcePath, targetPath *safepath.Path) ([]byte, error) {
+				Expect(unsafepath.UnsafeRelative(sourcePath.Raw())).To(Equal(unsafepath.UnsafeAbsolute(diskFile.Raw())))
+				Expect(unsafepath.UnsafeAbsolute(targetPath.Raw())).To(Equal(targetFilePath))
 				return []byte("Success"), nil
 			}
 
-			expectedPaths := []string{blockVolume, targetFilePath}
+			expectedPaths := []string{targetFilePath, blockVolume}
 			capturedPaths := []string{}
-			ownershipManager.EXPECT().SetFileOwnership(gomock.Any()).Times(2).DoAndReturn(func(path string) error {
-				capturedPaths = append(capturedPaths, path)
+
+			ownershipManager.EXPECT().SetFileOwnership(gomock.Any()).Times(2).DoAndReturn(func(path *safepath.Path) error {
+				capturedPaths = append(capturedPaths, unsafepath.UnsafeAbsolute(path.Raw()))
 				return nil
 			})
 
@@ -1043,7 +1045,7 @@ func (i *mockIsolationDetector) Detect(_ *v1.VirtualMachineInstance) (isolation.
 }
 
 func (i *mockIsolationDetector) DetectForSocket(_ *v1.VirtualMachineInstance, _ string) (isolation.IsolationResult, error) {
-	if i.pid == 1 {
+	if i.pid != 9999 {
 		return isolation.NewIsolationResult(i.pid, i.ppid), nil
 	}
 	return nil, fmt.Errorf("isolation error")
@@ -1056,3 +1058,66 @@ func (i *mockIsolationDetector) Allowlist(_ []string) isolation.PodIsolationDete
 func (i *mockIsolationDetector) AdjustResources(_ *v1.VirtualMachineInstance) error {
 	return nil
 }
+
+func newFile(baseDir string, elems ...string) (*safepath.Path, error) {
+	targetPath := filepath.Join(append([]string{baseDir}, elems...)...)
+	err := os.MkdirAll(filepath.Dir(targetPath), os.ModePerm)
+	if err != nil {
+		return nil, err
+	}
+	f, err := os.Create(targetPath)
+	if err != nil {
+		return nil, err
+	}
+	f.Close()
+	return safepath.JoinAndResolveWithRelativeRoot(baseDir, elems...)
+}
+func newDir(baseDir string, elems ...string) (*safepath.Path, error) {
+	targetPath := filepath.Join(append([]string{baseDir}, elems...)...)
+	err := os.MkdirAll(targetPath, os.ModePerm)
+	if err != nil {
+		return nil, err
+	}
+	return safepath.JoinAndResolveWithRelativeRoot(baseDir, elems...)
+}
+
+func fakeStat(isDevice bool, mode os.FileMode, dev uint64) os.FileInfo {
+	return fakeFileInfo{isDevice: isDevice, mode: mode, dev: dev}
+}
+
+type fakeFileInfo struct {
+	isDevice bool
+	mode     os.FileMode
+	dev      uint64
+}
+
+func (f fakeFileInfo) Name() string {
+	//TODO implement me
+	panic("implement me")
+}
+
+func (f fakeFileInfo) Size() int64 {
+	//TODO implement me
+	panic("implement me")
+}
+
+func (f fakeFileInfo) Mode() fs.FileMode {
+	if f.isDevice {
+		return f.mode | fs.ModeDevice
+	}
+	return f.mode
+}
+
+func (f fakeFileInfo) ModTime() time.Time {
+	//TODO implement me
+	panic("implement me")
+}
+
+func (f fakeFileInfo) IsDir() bool {
+	//TODO implement me
+	panic("implement me")
+}
+
+func (f fakeFileInfo) Sys() interface{} {
+	return &syscall.Stat_t{Rdev: f.dev}
+}
