From 906c7e7044ad51a432caed791c69a50ac998423e Mon Sep 17 00:00:00 2001
From: Michael Henriksen <mhenriks@redhat.com>
Date: Fri, 15 Feb 2019 10:42:19 -0500
Subject: [PATCH] cherry pick import cert support

---
 api/openapi-spec/swagger.json                 |  8 ++
 cmd/cdi-importer/importer.go                  | 18 ++--
 .../cdi-func-test-registry-init/Dockerfile    |  9 --
 manifests/example/registry-image-pvc.yaml     |  2 +-
 manifests/templates/registry-host.yaml.in     |  2 +-
 pkg/apis/core/v1alpha1/openapi_generated.go   | 14 +++
 pkg/apis/core/v1alpha1/types.go               |  4 +
 .../core/v1alpha1/types_swagger_generated.go  | 14 +--
 pkg/common/common.go                          |  6 +-
 pkg/controller/datavolume-controller.go       |  6 ++
 pkg/controller/import-controller.go           |  6 +-
 pkg/controller/util.go                        | 58 +++++++++++-
 pkg/controller/util_test.go                   | 10 +--
 pkg/image/skopeo.go                           | 21 +++--
 pkg/image/skopeo_test.go                      |  4 +-
 pkg/importer/dataStream.go                    |  5 +-
 pkg/importer/dataStream_test.go               |  6 ++
 pkg/importer/registry_test.go                 |  3 +-
 tests/datavolume_test.go                      |  3 +
 tests/transport_test.go                       | 22 +++--
 tests/utils/common.go                         |  2 +
 tests/utils/configmaps.go                     | 44 +++++++++
 tools/cdi-func-test-registry-init/main.go     | 90 ++++++++++++-------
 23 files changed, 271 insertions(+), 86 deletions(-)
 create mode 100644 tests/utils/configmaps.go

diff --git a/api/openapi-spec/swagger.json b/api/openapi-spec/swagger.json
index 9addc073a3..34ccdf1afd 100644
--- a/api/openapi-spec/swagger.json
+++ b/api/openapi-spec/swagger.json
@@ -2518,6 +2518,10 @@
    "v1alpha1.DataVolumeSourceHTTP": {
     "description": "DataVolumeSourceHTTP provides the parameters to create a Data Volume from an HTTP source",
     "properties": {
+     "certConfigMap": {
+      "description": "CertConfigMap provides a reference to the Registry certs",
+      "type": "string"
+     },
      "secretRef": {
       "description": "SecretRef provides the secret reference needed to access the HTTP source",
       "type": "string"
@@ -2542,6 +2546,10 @@
    "v1alpha1.DataVolumeSourceRegistry": {
     "description": "DataVolumeSourceRegistry provides the parameters to create a Data Volume from an registry source",
     "properties": {
+     "certConfigMap": {
+      "description": "CertConfigMap provides a reference to the Registry certs",
+      "type": "string"
+     },
      "secretRef": {
       "description": "SecretRef provides the secret reference needed to access the Registry source",
       "type": "string"
diff --git a/cmd/cdi-importer/importer.go b/cmd/cdi-importer/importer.go
index 3209efb06d..57a493fb92 100644
--- a/cmd/cdi-importer/importer.go
+++ b/cmd/cdi-importer/importer.go
@@ -49,6 +49,7 @@ func main() {
 	source, _ := util.ParseEnvVar(common.ImporterSource, false)
 	contentType, _ := util.ParseEnvVar(common.ImporterContentType, false)
 	imageSize, _ := util.ParseEnvVar(common.ImporterImageSize, false)
+	certDir, _ := util.ParseEnvVar(common.ImporterCertDirVar, false)
 
 	//Registry import currently support only kubevirt content type
 	if contentType != string(cdiv1.DataVolumeKubeVirt) && source == controller.SourceRegistry {
@@ -63,14 +64,15 @@ func main() {
 
 	glog.V(1).Infoln("begin import process")
 	dso := &importer.DataStreamOptions{
-		dest,
-		ep,
-		acc,
-		sec,
-		source,
-		contentType,
-		imageSize,
-		util.GetAvailableSpace(common.ImporterVolumePath),
+		Dest:           dest,
+		Endpoint:       ep,
+		AccessKey:      acc,
+		SecKey:         sec,
+		Source:         source,
+		ContentType:    contentType,
+		ImageSize:      imageSize,
+		AvailableSpace: util.GetAvailableSpace(common.ImporterVolumePath),
+		CertDir:        certDir,
 	}
 
 	if source == controller.SourceNone && contentType == string(cdiv1.DataVolumeKubeVirt) {
diff --git a/hack/build/docker/cdi-func-test-registry-init/Dockerfile b/hack/build/docker/cdi-func-test-registry-init/Dockerfile
index aa560371d4..d2e9027a72 100644
--- a/hack/build/docker/cdi-func-test-registry-init/Dockerfile
+++ b/hack/build/docker/cdi-func-test-registry-init/Dockerfile
@@ -10,14 +10,5 @@ RUN chmod u+x /usr/bin/cdi-func-test-registry-init
 
 COPY tinyCore.iso /tmp/source/tinyCore.iso
 
-
-RUN mkdir -p /tmp/source/certs
-RUN dnf install -y openssl
-RUN  openssl req \
-	  -newkey rsa:4096 -nodes -sha256 -keyout /tmp/source/certs/domain.key \
-	  -x509 -days 365  \
-          -subj "/C=GB/ST=TLV/L=TLV/O=RedHat/OU=CDI/CN=cdi-docker-registry-host.cdi" \
-	  -out /tmp/source/certs/domain.crt
-
 ENTRYPOINT ["cdi-func-test-registry-init", "-alsologtostderr"]
 
diff --git a/manifests/example/registry-image-pvc.yaml b/manifests/example/registry-image-pvc.yaml
index 56efb4d0b3..72c70b5dac 100644
--- a/manifests/example/registry-image-pvc.yaml
+++ b/manifests/example/registry-image-pvc.yaml
@@ -12,6 +12,6 @@ spec:
   - ReadWriteOnce
   resources:
     requests:
-      storage: 1Gi
+      storage: 5Gi
   # Optional: Set the storage class or omit to accept the default
   storageClassName: local
diff --git a/manifests/templates/registry-host.yaml.in b/manifests/templates/registry-host.yaml.in
index 36cb937f55..4400f829ec 100644
--- a/manifests/templates/registry-host.yaml.in
+++ b/manifests/templates/registry-host.yaml.in
@@ -39,7 +39,7 @@ spec:
       - name: registry-init
         image: {{ .DockerRepo }}/cdi-func-test-registry-init:{{ .DockerTag }}
         imagePullPolicy: {{ .PullPolicy }}
-        args: ["-inCertDir", "/tmp/source/certs", "-outCertDir", "/tmp/shared/certs", "-inFile", "/tmp/source/tinyCore.iso", "-outDir", "/tmp/shared/images"]
+        args: ["-certDir", "/tmp/shared/certs", "-inFile", "/tmp/source/tinyCore.iso", "-outDir", "/tmp/shared/images"]
         volumeMounts:
         - name: "images"
           mountPath: "/tmp/shared"
diff --git a/pkg/apis/core/v1alpha1/openapi_generated.go b/pkg/apis/core/v1alpha1/openapi_generated.go
index f20dbaf727..d05369ab38 100644
--- a/pkg/apis/core/v1alpha1/openapi_generated.go
+++ b/pkg/apis/core/v1alpha1/openapi_generated.go
@@ -424,6 +424,13 @@ func schema_pkg_apis_core_v1alpha1_DataVolumeSourceHTTP(ref common.ReferenceCall
 							Format:      "",
 						},
 					},
+					"certConfigMap": {
+						SchemaProps: spec.SchemaProps{
+							Description: "CertConfigMap provides a reference to the Registry certs",
+							Type:        []string{"string"},
+							Format:      "",
+						},
+					},
 				},
 			},
 		},
@@ -476,6 +483,13 @@ func schema_pkg_apis_core_v1alpha1_DataVolumeSourceRegistry(ref common.Reference
 							Format:      "",
 						},
 					},
+					"certConfigMap": {
+						SchemaProps: spec.SchemaProps{
+							Description: "CertConfigMap provides a reference to the Registry certs",
+							Type:        []string{"string"},
+							Format:      "",
+						},
+					},
 				},
 			},
 		},
diff --git a/pkg/apis/core/v1alpha1/types.go b/pkg/apis/core/v1alpha1/types.go
index 1f020d0157..59efaae98e 100644
--- a/pkg/apis/core/v1alpha1/types.go
+++ b/pkg/apis/core/v1alpha1/types.go
@@ -94,6 +94,8 @@ type DataVolumeSourceRegistry struct {
 	URL string `json:"url,omitempty"`
 	//SecretRef provides the secret reference needed to access the Registry source
 	SecretRef string `json:"secretRef,omitempty"`
+	//CertConfigMap provides a reference to the Registry certs
+	CertConfigMap string `json:"certConfigMap,omitempty"`
 }
 
 // DataVolumeSourceHTTP provides the parameters to create a Data Volume from an HTTP source
@@ -102,6 +104,8 @@ type DataVolumeSourceHTTP struct {
 	URL string `json:"url,omitempty"`
 	//SecretRef provides the secret reference needed to access the HTTP source
 	SecretRef string `json:"secretRef,omitempty"`
+	//CertConfigMap provides a reference to the Registry certs
+	CertConfigMap string `json:"certConfigMap,omitempty"`
 }
 
 // DataVolumeStatus provides the parameters to store the phase of the Data Volume
diff --git a/pkg/apis/core/v1alpha1/types_swagger_generated.go b/pkg/apis/core/v1alpha1/types_swagger_generated.go
index 8cabb8586e..7cc917580c 100644
--- a/pkg/apis/core/v1alpha1/types_swagger_generated.go
+++ b/pkg/apis/core/v1alpha1/types_swagger_generated.go
@@ -51,17 +51,19 @@ func (DataVolumeSourceS3) SwaggerDoc() map[string]string {
 
 func (DataVolumeSourceRegistry) SwaggerDoc() map[string]string {
 	return map[string]string{
-		"":          "DataVolumeSourceRegistry provides the parameters to create a Data Volume from an registry source",
-		"url":       "URL is the url of the Registry source",
-		"secretRef": "SecretRef provides the secret reference needed to access the Registry source",
+		"":              "DataVolumeSourceRegistry provides the parameters to create a Data Volume from an registry source",
+		"url":           "URL is the url of the Registry source",
+		"secretRef":     "SecretRef provides the secret reference needed to access the Registry source",
+		"certConfigMap": "CertConfigMap provides a reference to the Registry certs",
 	}
 }
 
 func (DataVolumeSourceHTTP) SwaggerDoc() map[string]string {
 	return map[string]string{
-		"":          "DataVolumeSourceHTTP provides the parameters to create a Data Volume from an HTTP source",
-		"url":       "URL is the URL of the http source",
-		"secretRef": "SecretRef provides the secret reference needed to access the HTTP source",
+		"":              "DataVolumeSourceHTTP provides the parameters to create a Data Volume from an HTTP source",
+		"url":           "URL is the URL of the http source",
+		"secretRef":     "SecretRef provides the secret reference needed to access the HTTP source",
+		"certConfigMap": "CertConfigMap provides a reference to the Registry certs",
 	}
 }
 
diff --git a/pkg/common/common.go b/pkg/common/common.go
index e309eadf17..6e63d26322 100644
--- a/pkg/common/common.go
+++ b/pkg/common/common.go
@@ -3,7 +3,7 @@ package common
 import (
 	"time"
 
-	"k8s.io/api/core/v1"
+	v1 "k8s.io/api/core/v1"
 )
 
 // Common types and constants used by the importer and controller.
@@ -36,6 +36,8 @@ const (
 	ImporterDataDir = "/data"
 	// ImporterS3Host provides an S3 string used by importer/dataStream.go only
 	ImporterS3Host = "s3.amazonaws.com"
+	// ImporterCertDir is where the configmap containg certs will be mounted
+	ImporterCertDir = "/certs"
 	// DefaultPullPolicy imports k8s "IfNotPresent" string for the import_controller_gingko_test and the cdi-controller executable
 	DefaultPullPolicy = string(v1.PullIfNotPresent)
 
@@ -53,6 +55,8 @@ const (
 	ImporterSecretKey = "IMPORTER_SECRET_KEY"
 	// ImporterImageSize provides a constant to capture our env variable "IMPORTER_IMAGE_SIZE"
 	ImporterImageSize = "IMPORTER_IMAGE_SIZE"
+	// ImporterCertDirVar provides a constant to capture our env variable "IMPORTER_CERT_DIR"
+	ImporterCertDirVar = "IMPORTER_CERT_DIR"
 
 	// CloningLabelKey provides a constant to use as a label name for pod affinity (controller pkg only)
 	CloningLabelKey = "cloning"
diff --git a/pkg/controller/datavolume-controller.go b/pkg/controller/datavolume-controller.go
index a42a9c3813..e3cbdfc1c4 100644
--- a/pkg/controller/datavolume-controller.go
+++ b/pkg/controller/datavolume-controller.go
@@ -643,6 +643,9 @@ func newPersistentVolumeClaim(dataVolume *cdiv1.DataVolume) (*corev1.PersistentV
 		if dataVolume.Spec.Source.HTTP.SecretRef != "" {
 			annotations[AnnSecret] = dataVolume.Spec.Source.HTTP.SecretRef
 		}
+		if dataVolume.Spec.Source.HTTP.CertConfigMap != "" {
+			annotations[AnnCertConfigMap] = dataVolume.Spec.Source.HTTP.CertConfigMap
+		}
 	} else if dataVolume.Spec.Source.S3 != nil {
 		annotations[AnnEndpoint] = dataVolume.Spec.Source.S3.URL
 		if dataVolume.Spec.Source.S3.SecretRef != "" {
@@ -654,6 +657,9 @@ func newPersistentVolumeClaim(dataVolume *cdiv1.DataVolume) (*corev1.PersistentV
 		if dataVolume.Spec.Source.Registry.SecretRef != "" {
 			annotations[AnnSecret] = dataVolume.Spec.Source.Registry.SecretRef
 		}
+		if dataVolume.Spec.Source.Registry.CertConfigMap != "" {
+			annotations[AnnCertConfigMap] = dataVolume.Spec.Source.Registry.CertConfigMap
+		}
 	} else if dataVolume.Spec.Source.PVC != nil {
 		if dataVolume.Spec.Source.PVC.Namespace != "" {
 			annotations[AnnCloneRequest] = dataVolume.Spec.Source.PVC.Namespace + "/" + dataVolume.Spec.Source.PVC.Name
diff --git a/pkg/controller/import-controller.go b/pkg/controller/import-controller.go
index 9a91416e89..088907997f 100644
--- a/pkg/controller/import-controller.go
+++ b/pkg/controller/import-controller.go
@@ -22,6 +22,8 @@ const (
 	AnnEndpoint = AnnAPIGroup + "/storage.import.endpoint"
 	// AnnSecret provides a const for our PVC secretName annotation
 	AnnSecret = AnnAPIGroup + "/storage.import.secretName"
+	// AnnCertConfigMap is the name of a configmap containing tls certs
+	AnnCertConfigMap = AnnAPIGroup + "/storage.import.certConfigMap"
 	// AnnContentType provides a const for the PVC content-type
 	AnnContentType = AnnAPIGroup + "/storage.contentType"
 	// AnnImportPod provides a const for our PVC importPodName annotation
@@ -36,7 +38,7 @@ type ImportController struct {
 }
 
 type importPodEnvVar struct {
-	ep, secretName, source, contentType, imageSize string
+	ep, secretName, source, contentType, imageSize, certConfigMap string
 }
 
 // NewImportController sets up an Import Controller, and returns a pointer to
@@ -102,7 +104,7 @@ func (ic *ImportController) processPvcItem(pvc *v1.PersistentVolumeClaim) error
 		needsSync = false
 	}
 	if pod == nil && needsSync {
-		podEnvVar, err := createImportEnvVar(pvc, ic)
+		podEnvVar, err := createImportEnvVar(ic.clientset, pvc)
 		if err != nil {
 			return err
 		}
diff --git a/pkg/controller/util.go b/pkg/controller/util.go
index 74d33c52ef..60b102d0b7 100644
--- a/pkg/controller/util.go
+++ b/pkg/controller/util.go
@@ -26,6 +26,9 @@ const (
 	// DataVolName provides a const to use for creating volumes in pod specs
 	DataVolName = "cdi-data-vol"
 
+	// CertVolName is the name of the volumecontaining certs
+	CertVolName = "cdi-cert-vol"
+
 	// ImagePathName provides a const to use for creating volumes in pod specs
 	ImagePathName  = "image-path"
 	socketPathName = "socket-path"
@@ -314,6 +317,28 @@ func MakeImporterPodSpec(image, verbose, pullPolicy string, podEnvVar *importPod
 		ownerUID = pvc.OwnerReferences[0].UID
 	}
 	pod.Spec.Containers[0].Env = makeEnv(podEnvVar, ownerUID)
+
+	if podEnvVar.certConfigMap != "" {
+		vm := v1.VolumeMount{
+			Name:      CertVolName,
+			MountPath: common.ImporterCertDir,
+		}
+
+		vol := v1.Volume{
+			Name: CertVolName,
+			VolumeSource: v1.VolumeSource{
+				ConfigMap: &v1.ConfigMapVolumeSource{
+					LocalObjectReference: v1.LocalObjectReference{
+						Name: podEnvVar.certConfigMap,
+					},
+				},
+			},
+		}
+
+		pod.Spec.Containers[0].VolumeMounts = append(pod.Spec.Containers[0].VolumeMounts, vm)
+		pod.Spec.Volumes = append(pod.Spec.Volumes, vol)
+	}
+
 	return pod
 }
 
@@ -364,6 +389,12 @@ func makeEnv(podEnvVar *importPodEnvVar, uid types.UID) []v1.EnvVar {
 			},
 		})
 	}
+	if podEnvVar.certConfigMap != "" {
+		env = append(env, v1.EnvVar{
+			Name:  common.ImporterCertDirVar,
+			Value: common.ImporterCertDir,
+		})
+	}
 	return env
 }
 
@@ -878,7 +909,7 @@ func deletePod(req podDeleteRequest) error {
 	return err
 }
 
-func createImportEnvVar(pvc *v1.PersistentVolumeClaim, ic *ImportController) (*importPodEnvVar, error) {
+func createImportEnvVar(client kubernetes.Interface, pvc *v1.PersistentVolumeClaim) (*importPodEnvVar, error) {
 	podEnvVar := &importPodEnvVar{}
 	podEnvVar.source = getSource(pvc)
 	podEnvVar.contentType = getContentType(pvc)
@@ -890,13 +921,17 @@ func createImportEnvVar(pvc *v1.PersistentVolumeClaim, ic *ImportController) (*i
 		if err != nil {
 			return nil, err
 		}
-		podEnvVar.secretName, err = getSecretName(ic.clientset, pvc)
+		podEnvVar.secretName, err = getSecretName(client, pvc)
 		if err != nil {
 			return nil, err
 		}
 		if podEnvVar.secretName == "" {
 			glog.V(2).Infof("no secret will be supplied to endpoint %q\n", podEnvVar.ep)
 		}
+		podEnvVar.certConfigMap, err = getCertConfigMap(client, pvc)
+		if err != nil {
+			return nil, err
+		}
 	}
 	//get the requested image size.
 	podEnvVar.imageSize, err = getRequestedImageSize(pvc)
@@ -905,3 +940,22 @@ func createImportEnvVar(pvc *v1.PersistentVolumeClaim, ic *ImportController) (*i
 	}
 	return podEnvVar, nil
 }
+
+func getCertConfigMap(client kubernetes.Interface, pvc *v1.PersistentVolumeClaim) (string, error) {
+	value, ok := pvc.Annotations[AnnCertConfigMap]
+	if !ok || value == "" {
+		return "", nil
+	}
+
+	_, err := client.CoreV1().ConfigMaps(pvc.Namespace).Get(value, metav1.GetOptions{})
+	if err != nil {
+		if k8serrors.IsNotFound(err) {
+			glog.Warningf("Configmap %s does not exist, pod will not start until it does", value)
+			return value, nil
+		}
+
+		return "", err
+	}
+
+	return value, nil
+}
diff --git a/pkg/controller/util_test.go b/pkg/controller/util_test.go
index ed0910ac79..58d86f192e 100644
--- a/pkg/controller/util_test.go
+++ b/pkg/controller/util_test.go
@@ -757,8 +757,8 @@ func TestCreateImporterPod(t *testing.T) {
 	}{
 		{
 			name:    "expect pod to be created",
-			args:    args{k8sfake.NewSimpleClientset(pvc), "test/image", "-v=5", "Always", &importPodEnvVar{"", "", "", "", "1G"}, pvc},
-			want:    MakeImporterPodSpec("test/image", "-v=5", "Always", &importPodEnvVar{"", "", "", "", "1G"}, pvc),
+			args:    args{k8sfake.NewSimpleClientset(pvc), "test/image", "-v=5", "Always", &importPodEnvVar{"", "", "", "", "1G", ""}, pvc},
+			want:    MakeImporterPodSpec("test/image", "-v=5", "Always", &importPodEnvVar{"", "", "", "", "1G", ""}, pvc),
 			wantErr: false,
 		},
 	}
@@ -796,7 +796,7 @@ func TestMakeImporterPodSpec(t *testing.T) {
 	}{
 		{
 			name:    "expect pod to be created",
-			args:    args{"test/myimage", "5", "Always", &importPodEnvVar{"", "", SourceHTTP, string(cdiv1.DataVolumeKubeVirt), "1G"}, pvc},
+			args:    args{"test/myimage", "5", "Always", &importPodEnvVar{"", "", SourceHTTP, string(cdiv1.DataVolumeKubeVirt), "1G", ""}, pvc},
 			wantPod: pod,
 		},
 	}
@@ -826,8 +826,8 @@ func Test_makeEnv(t *testing.T) {
 	}{
 		{
 			name: "env should match",
-			args: args{&importPodEnvVar{"myendpoint", "mysecret", SourceHTTP, string(cdiv1.DataVolumeKubeVirt), "1G"}},
-			want: createEnv(&importPodEnvVar{"myendpoint", "mysecret", SourceHTTP, string(cdiv1.DataVolumeKubeVirt), "1G"}, mockUID),
+			args: args{&importPodEnvVar{"myendpoint", "mysecret", SourceHTTP, string(cdiv1.DataVolumeKubeVirt), "1G", ""}},
+			want: createEnv(&importPodEnvVar{"myendpoint", "mysecret", SourceHTTP, string(cdiv1.DataVolumeKubeVirt), "1G", ""}, mockUID),
 		},
 	}
 	for _, tt := range tests {
diff --git a/pkg/image/skopeo.go b/pkg/image/skopeo.go
index 1c2970bbec..0e6a2ddc7d 100644
--- a/pkg/image/skopeo.go
+++ b/pkg/image/skopeo.go
@@ -35,7 +35,7 @@ const whFilePrefix string = ".wh."
 
 // SkopeoOperations defines the interface for executing skopeo subprocesses
 type SkopeoOperations interface {
-	CopyImage(string, string, string, string) error
+	CopyImage(string, string, string, string, string) error
 }
 
 type skopeoOperations struct{}
@@ -62,14 +62,17 @@ func NewSkopeoOperations() SkopeoOperations {
 	return &skopeoOperations{}
 }
 
-func (o *skopeoOperations) CopyImage(url, dest, accessKey, secKey string) error {
+func (o *skopeoOperations) CopyImage(url, dest, accessKey, secKey, certDir string) error {
 	var err error
-	if len(accessKey) > 0 && len(secKey) > 0 {
-		var creds = "--src-creds=" + accessKey + ":" + secKey
-		_, err = skopeoExecFunction(processLimits, nil, "skopeo", "copy", url, dest, creds)
-	} else {
-		_, err = skopeoExecFunction(processLimits, nil, "skopeo", "copy", url, dest, "--src-tls-verify=false")
+	args := []string{"copy", url, dest}
+	if accessKey != "" && secKey != "" {
+		creds := "--src-creds=" + accessKey + ":" + secKey
+		args = append(args, creds)
+	}
+	if certDir != "" {
+		args = append(args, "--src-cert-dir="+certDir)
 	}
+	_, err = skopeoExecFunction(processLimits, nil, "skopeo", args...)
 	if err != nil {
 		return errors.Wrap(err, "could not copy image")
 	}
@@ -77,9 +80,9 @@ func (o *skopeoOperations) CopyImage(url, dest, accessKey, secKey string) error
 }
 
 // CopyRegistryImage download image from registry with skopeo
-func CopyRegistryImage(url, dest, destFile, accessKey, secKey string) error {
+func CopyRegistryImage(url, dest, destFile, accessKey, secKey, certDir string) error {
 	skopeoDest := "dir:" + dest + dataTmpDir
-	err := SkopeoInterface.CopyImage(url, skopeoDest, accessKey, secKey)
+	err := SkopeoInterface.CopyImage(url, skopeoDest, accessKey, secKey, certDir)
 	if err != nil {
 		os.RemoveAll(dest + dataTmpDir)
 		return errors.Wrap(err, "Failed to download from registry")
diff --git a/pkg/image/skopeo_test.go b/pkg/image/skopeo_test.go
index 2fedcf4314..c08c73b383 100644
--- a/pkg/image/skopeo_test.go
+++ b/pkg/image/skopeo_test.go
@@ -52,8 +52,8 @@ var _ = Describe("Registry Importer", func() {
 			}
 		})
 	},
-		table.Entry("copy success", mockExecFunction("", ""), "", func() error { return CopyRegistryImage(source, dest, "", "", "") }),
-		table.Entry("copy failure", mockExecFunction("", "Failed to find VM disk image file in the container image"), "Failed to find VM disk image file in the container image", func() error { return CopyRegistryImage(source, dest, "", "", "") }),
+		table.Entry("copy success", mockExecFunction("", ""), "", func() error { return CopyRegistryImage(source, dest, "", "", "", "") }),
+		table.Entry("copy failure", mockExecFunction("", "Failed to find VM disk image file in the container image"), "Failed to find VM disk image file in the container image", func() error { return CopyRegistryImage(source, dest, "", "", "", "") }),
 	)
 
 })
diff --git a/pkg/importer/dataStream.go b/pkg/importer/dataStream.go
index 8271c478ab..220d264550 100644
--- a/pkg/importer/dataStream.go
+++ b/pkg/importer/dataStream.go
@@ -96,6 +96,8 @@ type DataStreamOptions struct {
 	ImageSize string
 	// Available space is the available space before downloading the image
 	AvailableSpace int64
+	// CertDir is a directory containing tls certs
+	CertDir string
 }
 
 const (
@@ -137,6 +139,7 @@ func newDataStreamFromStream(stream io.ReadCloser) (*DataStream, error) {
 		string(cdiv1.DataVolumeKubeVirt),
 		"", // Blank means don't resize
 		util.GetAvailableSpace(common.ImporterVolumePath),
+		"",
 	}, stream)
 }
 
@@ -297,7 +300,7 @@ func CopyData(dso *DataStreamOptions) error {
 	switch dso.Source {
 	case controller.SourceRegistry:
 		glog.V(1).Infof("using skopeo to copy from registry")
-		return image.CopyRegistryImage(dso.Endpoint, dso.Dest, common.DiskImageName, dso.AccessKey, dso.SecKey)
+		return image.CopyRegistryImage(dso.Endpoint, dso.Dest, common.DiskImageName, dso.AccessKey, dso.SecKey, dso.CertDir)
 	default:
 		ds, err := NewDataStream(dso)
 		if err != nil {
diff --git a/pkg/importer/dataStream_test.go b/pkg/importer/dataStream_test.go
index 690851731e..d64c13eb68 100644
--- a/pkg/importer/dataStream_test.go
+++ b/pkg/importer/dataStream_test.go
@@ -123,6 +123,7 @@ var _ = Describe("Data Stream", func() {
 			contentType,
 			"",
 			int64(1234567890),
+			"",
 		})
 		if ds != nil && len(ds.Readers) > 0 {
 			defer ds.Close()
@@ -160,6 +161,7 @@ var _ = Describe("Data Stream", func() {
 			string(cdiv1.DataVolumeKubeVirt),
 			"1G",
 			int64(1234567890),
+			"",
 		})
 		Expect(err).NotTo(HaveOccurred())
 		By("Closing data stream")
@@ -181,6 +183,7 @@ var _ = Describe("Data Stream", func() {
 			string(cdiv1.DataVolumeKubeVirt),
 			"20M",
 			int64(1234567890),
+			"",
 		})
 		if ds != nil && len(ds.Readers) > 0 {
 			defer ds.Close()
@@ -215,6 +218,7 @@ var _ = Describe("Data Stream", func() {
 			contentType,
 			"20M",
 			int64(1234567890),
+			"",
 		})
 		defer func() {
 			tempTestServer.Close()
@@ -289,6 +293,7 @@ var _ = Describe("Copy", func() {
 				string(cdiv1.DataVolumeKubeVirt),
 				"",
 				int64(1234567890),
+				"",
 			})
 			if !wantErr {
 				Expect(err).NotTo(HaveOccurred())
@@ -336,6 +341,7 @@ var _ = Describe("Copy", func() {
 				string(cdiv1.DataVolumeKubeVirt),
 				"1G",
 				int64(1234567890),
+				"",
 			})
 			if wantErr {
 				Expect(err).To(HaveOccurred())
diff --git a/pkg/importer/registry_test.go b/pkg/importer/registry_test.go
index 078a58a903..dffa15488c 100644
--- a/pkg/importer/registry_test.go
+++ b/pkg/importer/registry_test.go
@@ -39,6 +39,7 @@ var _ = Describe("Copy from Registry", func() {
 				string(cdiv1.DataVolumeKubeVirt),
 				"1G",
 				int64(1234567890),
+				"",
 			})
 			if !wantErr {
 				Expect(err).NotTo(HaveOccurred())
@@ -70,7 +71,7 @@ func NewFakeSkopeoOperations(e1 error) image.SkopeoOperations {
 	return &fakeSkopeoOperations{e1}
 }
 
-func (o *fakeSkopeoOperations) CopyImage(string, string, string, string) error {
+func (o *fakeSkopeoOperations) CopyImage(url, dest, accessKey, secKey, certDir string) error {
 	if o.e1 == nil {
 		if err := util.UnArchiveLocalTar(imageFile, imageDir); err != nil {
 			return errors.New("could not extract layer tar")
diff --git a/tests/datavolume_test.go b/tests/datavolume_test.go
index c04ac860ac..0c37cdfa5b 100644
--- a/tests/datavolume_test.go
+++ b/tests/datavolume_test.go
@@ -63,6 +63,9 @@ var _ = Describe("[vendor:cnv-qe@redhat.com][level:component]DataVolume tests",
 				dataVolume = utils.NewCloningDataVolume(dataVolumeName, "1Gi", sourcePvc)
 			case "import-registry":
 				dataVolume = utils.NewDataVolumeWithRegistryImport(dataVolumeName, "1Gi", url)
+				cm, err := utils.CopyRegistryCertConfigMap(f.K8sClient, f.Namespace.Name)
+				Expect(err).To(BeNil())
+				dataVolume.Spec.Source.Registry.CertConfigMap = cm
 			}
 
 			By(fmt.Sprintf("creating new datavolume %s", dataVolume.Name))
diff --git a/tests/transport_test.go b/tests/transport_test.go
index f47b4eb96a..9b9e173cb0 100644
--- a/tests/transport_test.go
+++ b/tests/transport_test.go
@@ -10,7 +10,7 @@ import (
 	. "github.com/onsi/ginkgo/extensions/table"
 	. "github.com/onsi/gomega"
 
-	"k8s.io/api/core/v1"
+	v1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 
 	"kubevirt.io/containerized-data-importer/pkg/common"
@@ -44,7 +44,7 @@ var _ = Describe("Transport Tests", func() {
 
 	// it() is the body of the test and is executed once per Entry() by DescribeTable()
 	// closes over c and ns
-	it := func(ep, file, accessKey, secretKey, source string, shouldSucceed bool) {
+	it := func(ep, file, accessKey, secretKey, source string, useRegistryCert, shouldSucceed bool) {
 
 		var (
 			err error // prevent shadowing
@@ -73,6 +73,12 @@ var _ = Describe("Transport Tests", func() {
 			pvcAnn[controller.AnnSecret] = sec.Name
 		}
 
+		if useRegistryCert {
+			cm, err := utils.CopyRegistryCertConfigMap(c, ns)
+			Expect(err).To(BeNil())
+			pvcAnn[controller.AnnCertConfigMap] = cm
+		}
+
 		By(fmt.Sprintf("Creating PVC with endpoint annotation %q", pvcAnn[controller.AnnEndpoint]))
 		pvc, err := utils.CreatePVCFromDefinition(c, ns, utils.NewPVCDefinition("transport-e2e", "20M", pvcAnn, nil))
 		Expect(err).NotTo(HaveOccurred(), "Error creating PVC")
@@ -120,12 +126,12 @@ var _ = Describe("Transport Tests", func() {
 	httpAuthEp := fmt.Sprintf("http://%s:%d", utils.FileHostName+"."+utils.FileHostNs, utils.HTTPAuthPort)
 	registryNoAuthEp := fmt.Sprintf("docker://%s", utils.RegistryHostName+"."+utils.RegistryHostNs)
 	DescribeTable("Transport Test Table", it,
-		Entry("should connect to http endpoint without credentials", httpNoAuthEp, targetFile, "", "", controller.SourceHTTP, true),
-		Entry("should connect to http endpoint with credentials", httpAuthEp, targetFile, utils.AccessKeyValue, utils.SecretKeyValue, controller.SourceHTTP, true),
-		Entry("should not connect to http endpoint with invalid credentials", httpAuthEp, targetFile, "gopats", "bradyisthegoat", controller.SourceHTTP, false),
-		Entry("should connect to QCOW http endpoint without credentials", httpNoAuthEp, targetQCOWFile, "", "", controller.SourceHTTP, true),
-		Entry("should connect to QCOW http endpoint with credentials", httpAuthEp, targetQCOWFile, utils.AccessKeyValue, utils.SecretKeyValue, controller.SourceHTTP, true),
-		Entry("should connect to registry endpoint without credentials", registryNoAuthEp, targetImage, "", "", controller.SourceRegistry, true),
+		Entry("should connect to http endpoint without credentials", httpNoAuthEp, targetFile, "", "", controller.SourceHTTP, false, true),
+		Entry("should connect to http endpoint with credentials", httpAuthEp, targetFile, utils.AccessKeyValue, utils.SecretKeyValue, controller.SourceHTTP, false, true),
+		Entry("should not connect to http endpoint with invalid credentials", httpAuthEp, targetFile, "gopats", "bradyisthegoat", controller.SourceHTTP, false, false),
+		Entry("should connect to QCOW http endpoint without credentials", httpNoAuthEp, targetQCOWFile, "", "", controller.SourceHTTP, false, true),
+		Entry("should connect to QCOW http endpoint with credentials", httpAuthEp, targetQCOWFile, utils.AccessKeyValue, utils.SecretKeyValue, controller.SourceHTTP, false, true),
+		Entry("should connect to registry endpoint without credentials", registryNoAuthEp, targetImage, "", "", controller.SourceRegistry, true, true),
 		//		Entry("should not connect to registry endpoint with invalid credentials", registryNoAuthEp, "registry", "gopats", "bradyisthegoat", controller.SourceRegistry, false),
 	)
 })
diff --git a/tests/utils/common.go b/tests/utils/common.go
index 48db3ccd64..a903c16b8e 100644
--- a/tests/utils/common.go
+++ b/tests/utils/common.go
@@ -22,4 +22,6 @@ const (
 	HTTPNoAuthPort = 80
 	// S3Port provides a cdi-file-host service S3 port, requires AccessKey and SecretKeyValue
 	S3Port = 9000
+	// RegistryConfigMap is the ConfigMap where the cert for the docker registry is stored
+	RegistryConfigMap = "cdi-docker-registry-host-certs"
 )
diff --git a/tests/utils/configmaps.go b/tests/utils/configmaps.go
new file mode 100644
index 0000000000..ca67831a03
--- /dev/null
+++ b/tests/utils/configmaps.go
@@ -0,0 +1,44 @@
+package utils
+
+import (
+	v1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/client-go/kubernetes"
+)
+
+// CopyRegistryCertConfigMap copies the test registry ConfigMap
+func CopyRegistryCertConfigMap(client kubernetes.Interface, destNamespace string) (string, error) {
+	err := CopyConfigMap(client, RegistryHostNs, RegistryConfigMap, destNamespace, RegistryConfigMap)
+	if err != nil {
+		return "", err
+	}
+	return RegistryConfigMap, nil
+}
+
+// CopyConfigMap copies a ConfigMap
+func CopyConfigMap(client kubernetes.Interface, srcNamespace, srcName, destNamespace, destName string) error {
+	src, err := client.CoreV1().ConfigMaps(srcNamespace).Get(srcName, metav1.GetOptions{})
+	if err != nil {
+		return err
+	}
+
+	dst := &v1.ConfigMap{
+		ObjectMeta: metav1.ObjectMeta{
+			Name: srcName,
+		},
+		Data: src.Data,
+	}
+
+	err = client.CoreV1().ConfigMaps(destNamespace).Delete(destName, nil)
+	if err != nil && !errors.IsNotFound(err) {
+		return err
+	}
+
+	_, err = client.CoreV1().ConfigMaps(destNamespace).Create(dst)
+	if err != nil {
+		return nil
+	}
+
+	return nil
+}
diff --git a/tools/cdi-func-test-registry-init/main.go b/tools/cdi-func-test-registry-init/main.go
index e0f36d647b..894659f303 100644
--- a/tools/cdi-func-test-registry-init/main.go
+++ b/tools/cdi-func-test-registry-init/main.go
@@ -14,21 +14,36 @@ package main
 
 import (
 	"flag"
-
-	"io"
 	"io/ioutil"
+	"path"
+
 	"os"
 	"path/filepath"
 	"strings"
 
 	"github.com/golang/glog"
 	"github.com/pkg/errors"
+
+	v1 "k8s.io/api/core/v1"
+	k8serrors "k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/client-go/kubernetes"
+	"k8s.io/client-go/rest"
+	certutil "k8s.io/client-go/util/cert"
+
+	"kubevirt.io/containerized-data-importer/pkg/util"
 	"kubevirt.io/containerized-data-importer/tests/utils"
 )
 
+const (
+	serviceName   = "cdi-docker-registry-host"
+	configMapName = serviceName + "-certs"
+	certFile      = "domain.crt"
+	keyFile       = "domain.key"
+)
+
 func main() {
-	inCertDir := flag.String("inCertDir", "", "")
-	outCertDir := flag.String("outCertDir", "", "")
+	certDir := flag.String("certDir", "", "")
 	inFile := flag.String("inFile", "", "")
 	outDir := flag.String("outDir", "", "")
 	flag.Parse()
@@ -47,8 +62,8 @@ func main() {
 		glog.Fatal(errors.Wrapf(err, "generating files from %s to %s' errored: ", *inFile, *outDir))
 	}
 
-	if err := ft.copyCertDir(*inCertDir, *outCertDir); err != nil {
-		glog.Fatal(errors.Wrapf(err, "copy certificate directory %s' errored: ", outCertDir))
+	if err := ft.populateCertDir(*certDir); err != nil {
+		glog.Fatal(errors.Wrapf(err, "copy certificate directory %s' errored: ", certDir))
 	}
 }
 
@@ -66,54 +81,69 @@ func (ft formatTable) generateFiles(inFile, outDir string) error {
 	return nil
 }
 
-func (ft formatTable) copyFile(src, dest string, info os.FileInfo) error {
+func (ft formatTable) populateCertDir(certDir string) error {
 
-	if err := os.MkdirAll(filepath.Dir(dest), os.ModePerm); err != nil {
+	glog.Info("Creating key/certificate")
+
+	config, err := rest.InClusterConfig()
+	if err != nil {
 		return err
 	}
 
-	f, err := os.Create(dest)
+	clientset, err := kubernetes.NewForConfig(config)
 	if err != nil {
 		return err
 	}
-	defer f.Close()
 
-	if err = os.Chmod(f.Name(), info.Mode()); err != nil {
-		return err
+	if err := os.MkdirAll(certDir, 0777); err != nil {
+		glog.Fatal(errors.Wrapf(err, "'mkdir %s' errored: ", certDir))
 	}
 
-	s, err := os.Open(src)
+	namespacedName := serviceName + "." + util.GetNamespace()
+
+	certBytes, keyBytes, err := certutil.GenerateSelfSignedCertKey(serviceName, nil, []string{namespacedName, namespacedName + ".svc"})
 	if err != nil {
 		return err
 	}
-	defer s.Close()
 
-	_, err = io.Copy(f, s)
-	return err
-}
+	cm := &v1.ConfigMap{
+		ObjectMeta: metav1.ObjectMeta{
+			Name: configMapName,
+		},
+		Data: map[string]string{
+			certFile: string(certBytes),
+		},
+	}
 
-func (ft formatTable) copyCertDir(inCertDir string, outCertDir string) error {
+	stored, err := clientset.CoreV1().ConfigMaps(util.GetNamespace()).Get(configMapName, metav1.GetOptions{})
+	if err != nil {
+		if !k8serrors.IsNotFound(err) {
+			return err
+		}
 
-	glog.Info("Copying certificates")
+		_, err := clientset.CoreV1().ConfigMaps(util.GetNamespace()).Create(cm)
+		if err != nil {
+			return err
+		}
 
-	if err := os.MkdirAll(outCertDir, 0777); err != nil {
-		glog.Fatal(errors.Wrapf(err, "'mkdir %s' errored: ", outCertDir))
+	} else {
+		cpy := stored.DeepCopyObject().(*v1.ConfigMap)
+		cpy.Data = cm.Data
+		_, err := clientset.CoreV1().ConfigMaps(util.GetNamespace()).Update(cpy)
+		if err != nil {
+			return err
+		}
 	}
 
-	contents, err := ioutil.ReadDir(inCertDir)
-	if err != nil {
+	if err = ioutil.WriteFile(path.Join(certDir, certFile), certBytes, 0644); err != nil {
 		return err
 	}
 
-	for _, content := range contents {
-		cs, cd := filepath.Join(inCertDir, content.Name()), filepath.Join(outCertDir, content.Name())
-		if err := ft.copyFile(cs, cd, content); err != nil {
-			// If any error exit
-			return err
-		}
+	if err = ioutil.WriteFile(path.Join(certDir, keyFile), keyBytes, 0600); err != nil {
+		return err
 	}
 
-	glog.Info("Copying certificates completed without errors")
+	glog.Info("Successfully created key/certificate")
 	return nil
 
 }
