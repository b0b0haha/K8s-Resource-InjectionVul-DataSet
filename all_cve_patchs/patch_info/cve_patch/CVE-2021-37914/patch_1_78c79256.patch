From 78c792569c0a26bccbce70f527598222d1d14590 Mon Sep 17 00:00:00 2001
From: Alex Collins <alex_collins@intuit.com>
Date: Wed, 28 Jul 2021 09:50:59 -0700
Subject: [PATCH] feat!: Rewrite templating. BREAKING CHANGE

Signed-off-by: Alex Collins <alex_collins@intuit.com>
---
 util/template/replace.go             | 93 ++++++++++++++++++++++++++--
 util/template/replace_test.go        | 62 ++++++++++---------
 util/template/template.go            | 46 --------------
 workflow/common/util.go              | 25 ++------
 workflow/controller/dag.go           | 26 ++------
 workflow/controller/exit_handler.go  | 15 +----
 workflow/controller/operator.go      | 73 +++-------------------
 workflow/controller/operator_test.go |  6 +-
 workflow/controller/scope.go         |  4 +-
 workflow/controller/steps.go         | 26 ++------
 workflow/controller/workflowpod.go   | 13 +---
 11 files changed, 149 insertions(+), 240 deletions(-)
 delete mode 100644 util/template/template.go

diff --git a/util/template/replace.go b/util/template/replace.go
index 79950dcc1c85..c3b1e1f5cc26 100644
--- a/util/template/replace.go
+++ b/util/template/replace.go
@@ -1,9 +1,94 @@
 package template
 
-func Replace(s string, replaceMap map[string]string, allowUnresolved bool) (string, error) {
-	t, err := NewTemplate(s)
+import (
+	"bytes"
+	"encoding/json"
+	"fmt"
+	"io"
+	"reflect"
+
+	log "github.com/sirupsen/logrus"
+
+	"github.com/valyala/fasttemplate"
+
+	exprenv "github.com/argoproj/argo-workflows/v3/util/expr/env"
+)
+
+const (
+	prefix = "{{"
+	suffix = "}}"
+)
+
+func replace(v interface{}, f func(string) (string, error)) (interface{}, error) {
+	switch x := v.(type) {
+	case string:
+		y, err := f(x)
+		return y, err
+	case []interface{}:
+		for m, n := range x {
+			y, err := replace(n, f)
+			if err != nil {
+				return nil, err
+			}
+			x[m] = y
+		}
+		return x, nil
+	case map[string]interface{}:
+		for m, n := range x {
+			y, err := replace(n, f)
+			if err != nil {
+				return nil, err
+			}
+			x[m] = y
+		}
+		return x, nil
+	default:
+		// int, float etc
+		return v, nil
+	}
+}
+
+func Replace(obj interface{}, replaceMap map[string]string, allowUnresolved bool) error {
+	switch kind := reflect.ValueOf(obj).Kind(); kind {
+	case reflect.Ptr, reflect.Slice, reflect.Map:
+	default:
+		return fmt.Errorf("obj must be pointer, slice or map, but is %q", kind)
+	}
+	data, err := json.Marshal(obj)
+	if err != nil {
+		return err
+	}
+	log.Debugf("replacing %T; %q", obj, data)
+	var x interface{}
+	if err := json.Unmarshal(data, &x); err != nil {
+		return err
+	}
+	replaceText := func(text string) (string, error) {
+		template, err := fasttemplate.NewTemplate(text, prefix, suffix)
+		if err != nil {
+			return "", err
+		}
+		replacedTmpl := &bytes.Buffer{}
+		_, err = template.ExecuteFunc(replacedTmpl, func(w io.Writer, tag string) (int, error) {
+			kind, expression := parseTag(tag)
+			switch kind {
+			case kindExpression:
+				env := exprenv.GetFuncMap(envMap(replaceMap))
+				return expressionReplace(w, expression, env, allowUnresolved)
+			default:
+				return simpleReplace(w, tag, replaceMap, allowUnresolved)
+			}
+		})
+		return replacedTmpl.String(), err
+	}
+	y, err := replace(x, replaceText)
+	if err != nil {
+		return err
+	}
+	data, err = json.Marshal(y)
 	if err != nil {
-		return "", err
+		return err
 	}
-	return t.Replace(replaceMap, allowUnresolved)
+	log.Debugf("replaced  %T: %q", obj, data)
+	return json.Unmarshal(data, &obj)
 }
diff --git a/util/template/replace_test.go b/util/template/replace_test.go
index 5775424bdd2e..c042eb045cf0 100644
--- a/util/template/replace_test.go
+++ b/util/template/replace_test.go
@@ -7,50 +7,54 @@ import (
 )
 
 func Test_Replace(t *testing.T) {
-	t.Run("InvailedTemplate", func(t *testing.T) {
-		_, err := Replace("{{", nil, false)
-		assert.Error(t, err)
-	})
 	t.Run("Simple", func(t *testing.T) {
 		t.Run("Valid", func(t *testing.T) {
-			r, err := Replace("{{foo}}", map[string]string{"foo": "bar"}, false)
+			obj := "{{foo}}"
+			err := Replace(&obj, map[string]string{"foo": "bar"}, false)
 			assert.NoError(t, err)
-			assert.Equal(t, "bar", r)
+			assert.Equal(t, "bar", obj)
 		})
 		t.Run("Unresolved", func(t *testing.T) {
 			t.Run("Allowed", func(t *testing.T) {
-				_, err := Replace("{{foo}}", nil, true)
+				obj := "{{foo}}"
+				err := Replace(&obj, nil, true)
 				assert.NoError(t, err)
 			})
 			t.Run("Disallowed", func(t *testing.T) {
-				_, err := Replace("{{foo}}", nil, false)
+				obj := "{{foo}}"
+				err := Replace(&obj, nil, false)
 				assert.EqualError(t, err, "failed to resolve {{foo}}")
 			})
 		})
 	})
 	t.Run("Expression", func(t *testing.T) {
 		t.Run("Valid", func(t *testing.T) {
-			r, err := Replace("{{=foo}}", map[string]string{"foo": "bar"}, false)
+			obj := "{{=foo}}"
+			err := Replace(&obj, map[string]string{"foo": "bar"}, false)
 			assert.NoError(t, err)
-			assert.Equal(t, "bar", r)
+			assert.Equal(t, "bar", obj)
 		})
 		t.Run("Unresolved", func(t *testing.T) {
 			t.Run("Allowed", func(t *testing.T) {
-				_, err := Replace("{{=foo}}", nil, true)
+				obj := "{{=foo}}"
+				err := Replace(&obj, nil, true)
 				assert.NoError(t, err)
 			})
 			t.Run("AllowedRetries", func(t *testing.T) {
-				replaced, err := Replace("{{=sprig.int(retries)}}", nil, true)
+				obj := "{{=sprig.int(retries)}}"
+				err := Replace(&obj, nil, true)
 				assert.NoError(t, err)
-				assert.Equal(t, replaced, "{{=sprig.int(retries)}}")
+				assert.Equal(t, obj, "{{=sprig.int(retries)}}")
 			})
 			t.Run("Disallowed", func(t *testing.T) {
-				_, err := Replace("{{=foo}}", nil, false)
+				obj := "{{=foo}}"
+				err := Replace(&obj, nil, false)
 				assert.EqualError(t, err, "failed to evaluate expression \"foo\"")
 			})
 		})
 		t.Run("Error", func(t *testing.T) {
-			_, err := Replace("{{=!}}", nil, false)
+			obj := "{{=!}}"
+			err := Replace(&obj, nil, false)
 			if assert.Error(t, err) {
 				assert.Contains(t, err.Error(), "failed to evaluate expression")
 			}
@@ -64,54 +68,54 @@ func TestNestedReplaceString(t *testing.T) {
 	test := `{{- with secret "{{inputs.parameters.message}}" -}}
     {{ .Data.data.gitcreds }}
   {{- end }}`
-	replacement, err := Replace(test, replaceMap, true)
+	err := Replace(&test, replaceMap, true)
 	if assert.NoError(t, err) {
-		assert.Equal(t, "{{- with secret \"hello world\" -}}\n    {{ .Data.data.gitcreds }}\n  {{- end }}", replacement)
+		assert.Equal(t, "{{- with secret \"hello world\" -}}\n    {{ .Data.data.gitcreds }}\n  {{- end }}", test)
 	}
 
 	test = `{{- with {{ secret "{{inputs.parameters.message}}" -}}
     {{ .Data.data.gitcreds }}
   {{- end }}`
 
-	replacement, err = Replace(test, replaceMap, true)
+	err = Replace(&test, replaceMap, true)
 	if assert.NoError(t, err) {
-		assert.Equal(t, "{{- with {{ secret \"hello world\" -}}\n    {{ .Data.data.gitcreds }}\n  {{- end }}", replacement)
+		assert.Equal(t, "{{- with {{ secret \"hello world\" -}}\n    {{ .Data.data.gitcreds }}\n  {{- end }}", test)
 	}
 
 	test = `{{- with {{ secret "{{inputs.parameters.message}}" -}} }}
     {{ .Data.data.gitcreds }}
   {{- end }}`
 
-	replacement, err = Replace(test, replaceMap, true)
+	err = Replace(&test, replaceMap, true)
 	if assert.NoError(t, err) {
-		assert.Equal(t, "{{- with {{ secret \"hello world\" -}} }}\n    {{ .Data.data.gitcreds }}\n  {{- end }}", replacement)
+		assert.Equal(t, "{{- with {{ secret \"hello world\" -}} }}\n    {{ .Data.data.gitcreds }}\n  {{- end }}", test)
 	}
 
 	test = `{{- with secret "{{inputs.parameters.message}}" -}} }}
     {{ .Data.data.gitcreds }}
   {{- end }}`
 
-	replacement, err = Replace(test, replaceMap, true)
+	err = Replace(&test, replaceMap, true)
 	if assert.NoError(t, err) {
-		assert.Equal(t, "{{- with secret \"hello world\" -}} }}\n    {{ .Data.data.gitcreds }}\n  {{- end }}", replacement)
+		assert.Equal(t, "{{- with secret \"hello world\" -}} }}\n    {{ .Data.data.gitcreds }}\n  {{- end }}", test)
 	}
 
 	test = `{{- with {{ {{ }} secret "{{inputs.parameters.message}}" -}} }}
     {{ .Data.data.gitcreds }}
   {{- end }}`
 
-	replacement, err = Replace(test, replaceMap, true)
+	err = Replace(&test, replaceMap, true)
 	if assert.NoError(t, err) {
-		assert.Equal(t, "{{- with {{ {{ }} secret \"hello world\" -}} }}\n    {{ .Data.data.gitcreds }}\n  {{- end }}", replacement)
+		assert.Equal(t, "{{- with {{ {{ }} secret \"hello world\" -}} }}\n    {{ .Data.data.gitcreds }}\n  {{- end }}", test)
 	}
 
 	test = `{{- with {{ {{ }} secret "{{does-not-exist}}" -}} }}
     {{ .Data.data.gitcreds }}
   {{- end }}`
 
-	replacement, err = Replace(test, replaceMap, true)
+	err = Replace(&test, replaceMap, true)
 	if assert.NoError(t, err) {
-		assert.Equal(t, test, replacement)
+		assert.Equal(t, test, test)
 	}
 }
 
@@ -119,8 +123,8 @@ func TestReplaceStringWithWhiteSpace(t *testing.T) {
 	replaceMap := map[string]string{"inputs.parameters.message": "hello world"}
 
 	test := `{{ inputs.parameters.message }}`
-	replacement, err := Replace(test, replaceMap, true)
+	err := Replace(&test, replaceMap, true)
 	if assert.NoError(t, err) {
-		assert.Equal(t, "hello world", replacement)
+		assert.Equal(t, "hello world", test)
 	}
 }
diff --git a/util/template/template.go b/util/template/template.go
deleted file mode 100644
index 97f2580b6810..000000000000
--- a/util/template/template.go
+++ /dev/null
@@ -1,46 +0,0 @@
-package template
-
-import (
-	"bytes"
-	"io"
-
-	"github.com/valyala/fasttemplate"
-
-	exprenv "github.com/argoproj/argo-workflows/v3/util/expr/env"
-)
-
-const (
-	prefix = "{{"
-	suffix = "}}"
-)
-
-type Template interface {
-	Replace(replaceMap map[string]string, allowUnresolved bool) (string, error)
-}
-
-func NewTemplate(s string) (Template, error) {
-	template, err := fasttemplate.NewTemplate(s, prefix, suffix)
-	if err != nil {
-		return nil, err
-	}
-	return &impl{template}, nil
-}
-
-type impl struct {
-	*fasttemplate.Template
-}
-
-func (t *impl) Replace(replaceMap map[string]string, allowUnresolved bool) (string, error) {
-	replacedTmpl := &bytes.Buffer{}
-	_, err := t.Template.ExecuteFunc(replacedTmpl, func(w io.Writer, tag string) (int, error) {
-		kind, expression := parseTag(tag)
-		switch kind {
-		case kindExpression:
-			env := exprenv.GetFuncMap(envMap(replaceMap))
-			return expressionReplace(w, expression, env, allowUnresolved)
-		default:
-			return simpleReplace(w, tag, replaceMap, allowUnresolved)
-		}
-	})
-	return replacedTmpl.String(), err
-}
diff --git a/workflow/common/util.go b/workflow/common/util.go
index 0cde8ce51ad0..660a33f701a6 100644
--- a/workflow/common/util.go
+++ b/workflow/common/util.go
@@ -168,21 +168,12 @@ func ProcessArgs(tmpl *wfv1.Template, args wfv1.ArgumentsProvider, globalParams,
 
 // SubstituteParams returns a new copy of the template with global, pod, and input parameters substituted
 func SubstituteParams(tmpl *wfv1.Template, globalParams, localParams Parameters) (*wfv1.Template, error) {
-	tmplBytes, err := json.Marshal(tmpl)
-	if err != nil {
-		return nil, errors.InternalWrapError(err)
-	}
 	// First replace globals & locals, then replace inputs because globals could be referenced in the inputs
 	replaceMap := globalParams.Merge(localParams)
-	globalReplacedTmplStr, err := template.Replace(string(tmplBytes), replaceMap, true)
-	if err != nil {
+	globalReplacedTmpl := *tmpl.DeepCopy()
+	if err := template.Replace(&globalReplacedTmpl, replaceMap, true); err != nil {
 		return nil, err
 	}
-	var globalReplacedTmpl wfv1.Template
-	err = json.Unmarshal([]byte(globalReplacedTmplStr), &globalReplacedTmpl)
-	if err != nil {
-		return nil, errors.InternalWrapError(err)
-	}
 	// Now replace the rest of substitutions (the ones that can be made) in the template
 	replaceMap = make(map[string]string)
 	for _, inParam := range globalReplacedTmpl.Inputs.Parameters {
@@ -192,7 +183,7 @@ func SubstituteParams(tmpl *wfv1.Template, globalParams, localParams Parameters)
 		replaceMap["inputs.parameters."+inParam.Name] = inParam.Value.String()
 	}
 	// allow {{inputs.parameters}} to fetch the entire input parameters list as JSON
-	jsonInputParametersBytes, err := json.Marshal(globalReplacedTmpl.Inputs.Parameters)
+	jsonInputParametersBytes, err := json.Marshal(&globalReplacedTmpl.Inputs.Parameters)
 	if err != nil {
 		return nil, errors.InternalWrapError(err)
 	}
@@ -213,16 +204,10 @@ func SubstituteParams(tmpl *wfv1.Template, globalParams, localParams Parameters)
 		}
 	}
 
-	s, err := template.Replace(globalReplacedTmplStr, replaceMap, true)
-	if err != nil {
+	if err := template.Replace(&globalReplacedTmpl, replaceMap, true); err != nil {
 		return nil, err
 	}
-	var newTmpl wfv1.Template
-	err = json.Unmarshal([]byte(s), &newTmpl)
-	if err != nil {
-		return nil, errors.InternalWrapError(err)
-	}
-	return &newTmpl, nil
+	return &globalReplacedTmpl, nil
 }
 
 // RunCommand is a convenience function to run/log a command and log the stderr upon failure
diff --git a/workflow/controller/dag.go b/workflow/controller/dag.go
index 94000f9d408a..80dd1d9ef355 100644
--- a/workflow/controller/dag.go
+++ b/workflow/controller/dag.go
@@ -544,19 +544,10 @@ func (woc *wfOperationCtx) resolveDependencyReferences(dagCtx *dagContext, task
 	}
 
 	// Replace task's parameters
-	taskBytes, err := json.Marshal(task)
-	if err != nil {
-		return nil, errors.InternalWrapError(err)
-	}
-	newTaskStr, err := template.Replace(string(taskBytes), woc.globalParams.Merge(scope.getParameters()), true)
-	if err != nil {
+	newTask := *task.DeepCopy()
+	if err := template.Replace(&newTask, woc.globalParams.Merge(scope.getParameters()), true); err != nil {
 		return nil, err
 	}
-	var newTask wfv1.DAGTask
-	err = json.Unmarshal([]byte(newTaskStr), &newTask)
-	if err != nil {
-		return nil, errors.InternalWrapError(err)
-	}
 
 	// If we are not executing, don't attempt to resolve any artifact references. We only check if we are executing after
 	// the initial parameter resolution, since it's likely that the "when" clause will contain parameter references.
@@ -637,25 +628,16 @@ func expandTask(task wfv1.DAGTask) ([]wfv1.DAGTask, error) {
 		return []wfv1.DAGTask{task}, nil
 	}
 
-	taskBytes, err := json.Marshal(task)
-	if err != nil {
-		return nil, errors.InternalWrapError(err)
-	}
-
 	// these fields can be very large (>100m) and marshalling 10k x 100m = 6GB of memory used and
 	// very poor performance, so we just nil them out
 	task.WithItems = nil
 	task.WithParam = ""
 	task.WithSequence = nil
 
-	tmpl, err := template.NewTemplate(string(taskBytes))
-	if err != nil {
-		return nil, fmt.Errorf("unable to parse argo variable: %w", err)
-	}
 	expandedTasks := make([]wfv1.DAGTask, 0)
 	for i, item := range items {
-		var newTask wfv1.DAGTask
-		newTaskName, err := processItem(tmpl, task.Name, i, item, &newTask)
+		newTask := *task.DeepCopy()
+		newTaskName, err := processItem(task.Name, i, item, &newTask)
 		if err != nil {
 			return nil, err
 		}
diff --git a/workflow/controller/exit_handler.go b/workflow/controller/exit_handler.go
index 86099e6f4b78..8171a0f94de3 100644
--- a/workflow/controller/exit_handler.go
+++ b/workflow/controller/exit_handler.go
@@ -2,7 +2,6 @@ package controller
 
 import (
 	"context"
-	"encoding/json"
 	"fmt"
 
 	wfv1 "github.com/argoproj/argo-workflows/v3/pkg/apis/workflow/v1alpha1"
@@ -59,18 +58,8 @@ func (woc *wfOperationCtx) resolveExitTmplArgument(args wfv1.Arguments, prefix s
 	for _, arts := range outputs.Artifacts {
 		scope.addArtifactToScope(fmt.Sprintf("%s.outputs.artifacts.%s", prefix, arts.Name), arts)
 	}
-
-	stepBytes, err := json.Marshal(args)
-	if err != nil {
-		return args, err
-	}
-	newStepStr, err := template.Replace(string(stepBytes), woc.globalParams.Merge(scope.getParameters()), true)
-	if err != nil {
-		return args, err
-	}
-	var newArgs wfv1.Arguments
-	err = json.Unmarshal([]byte(newStepStr), &newArgs)
-	if err != nil {
+	newArgs := *args.DeepCopy()
+	if err := template.Replace(&newArgs, woc.globalParams.Merge(scope.getParameters()), true); err != nil {
 		return args, err
 	}
 	// Step 2: replace all artifact references
diff --git a/workflow/controller/operator.go b/workflow/controller/operator.go
index 70afd0b56593..44a46191d303 100644
--- a/workflow/controller/operator.go
+++ b/workflow/controller/operator.go
@@ -2871,7 +2871,7 @@ func parseStringToDuration(durationString string) (time.Duration, error) {
 	return suspendDuration, nil
 }
 
-func processItem(tmpl template.Template, name string, index int, item wfv1.Item, obj interface{}) (string, error) {
+func processItem(name string, index int, item wfv1.Item, obj interface{}) (string, error) {
 	replaceMap := make(map[string]string)
 	var newName string
 
@@ -2912,15 +2912,7 @@ func processItem(tmpl template.Template, name string, index int, item wfv1.Item,
 	default:
 		return "", errors.Errorf(errors.CodeBadRequest, "withItems[%d] expected string, number, list, or map. received: %v", index, item)
 	}
-	newStepStr, err := tmpl.Replace(replaceMap, false)
-	if err != nil {
-		return "", err
-	}
-	err = json.Unmarshal([]byte(newStepStr), &obj)
-	if err != nil {
-		return "", errors.InternalWrapError(err)
-	}
-	return newName, nil
+	return newName, template.Replace(obj, replaceMap, false)
 }
 
 func generateNodeName(name string, index int, desc interface{}) string {
@@ -2986,26 +2978,7 @@ func expandSequence(seq *wfv1.Sequence) ([]wfv1.Item, error) {
 }
 
 func (woc *wfOperationCtx) substituteParamsInVolumes(params map[string]string) error {
-	if woc.volumes == nil {
-		return nil
-	}
-
-	volumes := woc.volumes
-	volumesBytes, err := json.Marshal(volumes)
-	if err != nil {
-		return errors.InternalWrapError(err)
-	}
-	newVolumesStr, err := template.Replace(string(volumesBytes), params, true)
-	if err != nil {
-		return err
-	}
-	var newVolumes []apiv1.Volume
-	err = json.Unmarshal([]byte(newVolumesStr), &newVolumes)
-	if err != nil {
-		return errors.InternalWrapError(err)
-	}
-	woc.volumes = newVolumes
-	return nil
+	return template.Replace(woc.volumes, params, true)
 }
 
 // createTemplateContext creates a new template context.
@@ -3044,23 +3017,11 @@ func (woc *wfOperationCtx) computeMetrics(metricList []*wfv1.Prometheus, localSc
 		// Substitute parameters in non-value fields of the template to support variables in places such as labels,
 		// name, and help. We do not substitute value fields here (i.e. gauge, histogram, counter) here because they
 		// might be realtime ({{workflow.duration}} will not be substituted the same way if it's realtime or if it isn't).
-		metricTmplBytes, err := json.Marshal(metricTmpl)
-		if err != nil {
-			woc.reportMetricEmissionError(fmt.Sprintf("unable to substitute parameters for metric '%s' (marshal): %s", metricTmpl.Name, err))
-			continue
-		}
-		replacedValue, err := template.Replace(string(metricTmplBytes), localScope, false)
-		if err != nil {
+		metricTmplSubstituted := *metricTmpl.DeepCopy()
+		if err := template.Replace(&metricTmplSubstituted, localScope, false); err != nil {
 			woc.reportMetricEmissionError(fmt.Sprintf("unable to substitute parameters for metric '%s': %s", metricTmpl.Name, err))
 			continue
 		}
-
-		var metricTmplSubstituted wfv1.Prometheus
-		err = json.Unmarshal([]byte(replacedValue), &metricTmplSubstituted)
-		if err != nil {
-			woc.reportMetricEmissionError(fmt.Sprintf("unable to substitute parameters for metric '%s' (unmarshal): %s", metricTmpl.Name, err))
-			continue
-		}
 		// Only substitute non-value fields here. Value field substitution happens below
 		metricTmpl.Name = metricTmplSubstituted.Name
 		metricTmpl.Help = metricTmplSubstituted.Help
@@ -3104,12 +3065,10 @@ func (woc *wfOperationCtx) computeMetrics(metricList []*wfv1.Prometheus, localSc
 			metricSpec := metricTmpl.DeepCopy()
 
 			// Finally substitute value parameters
-			replacedValue, err := template.Replace(metricSpec.GetValueString(), localScope, false)
-			if err != nil {
+			if err := template.Replace(metricSpec, localScope, false); err != nil {
 				woc.reportMetricEmissionError(fmt.Sprintf("unable to substitute parameters for metric '%s': %s", metricSpec.Name, err))
 				continue
 			}
-			metricSpec.SetValueString(replacedValue)
 
 			metric := woc.controller.metrics.GetCustomMetric(metricSpec.GetDesc())
 			// It is valid to pass a nil metric to ConstructOrUpdateMetric, in that case the metric will be created for us
@@ -3397,23 +3356,5 @@ func (woc *wfOperationCtx) mergedTemplateDefaultsInto(originalTmpl *wfv1.Templat
 }
 
 func (woc *wfOperationCtx) substituteGlobalVariables() error {
-	execWfSpec := woc.execWf.Spec
-
-	// To Avoid the stale Global parameter value substitution to templates.
-	// Updated Global parameter values will be substituted in 'executetemplate' for templates.
-	execWfSpec.Templates = nil
-
-	wfSpec, err := json.Marshal(execWfSpec)
-	if err != nil {
-		return err
-	}
-	resolveSpec, err := template.Replace(string(wfSpec), woc.globalParams, true)
-	if err != nil {
-		return err
-	}
-	err = json.Unmarshal([]byte(resolveSpec), &woc.execWf.Spec)
-	if err != nil {
-		return err
-	}
-	return nil
+	return template.Replace(&woc.execWf.Spec, woc.globalParams, true)
 }
diff --git a/workflow/controller/operator_test.go b/workflow/controller/operator_test.go
index 7083939d8fd9..0bb8655c6c73 100644
--- a/workflow/controller/operator_test.go
+++ b/workflow/controller/operator_test.go
@@ -32,7 +32,6 @@ import (
 	"github.com/argoproj/argo-workflows/v3/config"
 	wfv1 "github.com/argoproj/argo-workflows/v3/pkg/apis/workflow/v1alpha1"
 	intstrutil "github.com/argoproj/argo-workflows/v3/util/intstr"
-	"github.com/argoproj/argo-workflows/v3/util/template"
 	"github.com/argoproj/argo-workflows/v3/workflow/common"
 	"github.com/argoproj/argo-workflows/v3/workflow/controller/cache"
 	hydratorfake "github.com/argoproj/argo-workflows/v3/workflow/hydrator/fake"
@@ -5503,14 +5502,11 @@ func Test_processItem(t *testing.T) {
 	task := wfv1.DAGTask{
 		WithParam: `[{"number": 2, "string": "foo", "list": [0, "1"], "json": {"number": 2, "string": "foo", "list": [0, "1"]}}]`,
 	}
-	taskBytes, err := json.Marshal(task)
-	assert.NoError(t, err)
 	var items []wfv1.Item
 	wfv1.MustUnmarshal([]byte(task.WithParam), &items)
 
 	var newTask wfv1.DAGTask
-	tmpl, _ := template.NewTemplate(string(taskBytes))
-	newTaskName, err := processItem(tmpl, "task-name", 0, items[0], &newTask)
+	newTaskName, err := processItem("task-name", 0, items[0], &newTask)
 	if assert.NoError(t, err) {
 		assert.Equal(t, `task-name(0:json:{"list":[0,"1"],"number":2,"string":"foo"},list:[0,"1"],number:2,string:foo)`, newTaskName)
 	}
diff --git a/workflow/controller/scope.go b/workflow/controller/scope.go
index 638f3b9dfdf9..d5c734adb657 100644
--- a/workflow/controller/scope.go
+++ b/workflow/controller/scope.go
@@ -106,8 +106,8 @@ func (s *wfScope) resolveArtifact(art *wfv1.Artifact) (*wfv1.Artifact, error) {
 	}
 
 	if art.SubPath != "" {
-		resolvedSubPath, err := template.Replace(art.SubPath, s.getParameters(), true)
-		if err != nil {
+		resolvedSubPath := art.SubPath
+		if err := template.Replace(&resolvedSubPath, s.getParameters(), true); err != nil {
 			return nil, err
 		}
 
diff --git a/workflow/controller/steps.go b/workflow/controller/steps.go
index d783b5c4ddf4..1f2e4a5b865d 100644
--- a/workflow/controller/steps.go
+++ b/workflow/controller/steps.go
@@ -346,19 +346,10 @@ func (woc *wfOperationCtx) resolveReferences(stepGroup []wfv1.WorkflowStep, scop
 	for i, step := range stepGroup {
 		// Step 1: replace all parameter scope references in the step
 		// TODO: improve this
-		stepBytes, err := json.Marshal(step)
-		if err != nil {
-			return nil, errors.InternalWrapError(err)
-		}
-		newStepStr, err := template.Replace(string(stepBytes), woc.globalParams.Merge(scope.getParameters()), true)
-		if err != nil {
+		newStep := *step.DeepCopy()
+		if err := template.Replace(&newStep, woc.globalParams.Merge(scope.getParameters()), true); err != nil {
 			return nil, err
 		}
-		var newStep wfv1.WorkflowStep
-		err = json.Unmarshal([]byte(newStepStr), &newStep)
-		if err != nil {
-			return nil, errors.InternalWrapError(err)
-		}
 
 		// If we are not executing, don't attempt to resolve any artifact references. We only check if we are executing after
 		// the initial parameter resolution, since it's likely that the "when" clause will contain parameter references.
@@ -457,18 +448,9 @@ func (woc *wfOperationCtx) expandStep(step wfv1.WorkflowStep) ([]wfv1.WorkflowSt
 	step.WithParam = ""
 	step.WithSequence = nil
 
-	stepBytes, err := json.Marshal(step)
-	if err != nil {
-		return nil, errors.InternalWrapError(err)
-	}
-	t, err := template.NewTemplate(string(stepBytes))
-	if err != nil {
-		return nil, fmt.Errorf("unable to parse argo variable: %w", err)
-	}
-
 	for i, item := range items {
-		var newStep wfv1.WorkflowStep
-		newStepName, err := processItem(t, step.Name, i, item, &newStep)
+		newStep := *step.DeepCopy()
+		newStepName, err := processItem(step.Name, i, item, &newStep)
 		if err != nil {
 			return nil, err
 		}
diff --git a/workflow/controller/workflowpod.go b/workflow/controller/workflowpod.go
index b64fd978bc39..9dae035fb509 100644
--- a/workflow/controller/workflowpod.go
+++ b/workflow/controller/workflowpod.go
@@ -448,17 +448,8 @@ func substitutePodParams(pod *apiv1.Pod, globalParams common.Parameters, tmpl *w
 		podParams["inputs.parameters."+inParam.Name] = inParam.Value.String()
 	}
 	podParams[common.LocalVarPodName] = pod.Name
-	specBytes, err := json.Marshal(pod)
-	if err != nil {
-		return nil, err
-	}
-	newSpecBytes, err := template.Replace(string(specBytes), podParams, true)
-	if err != nil {
-		return nil, err
-	}
-	var newSpec apiv1.Pod
-	err = json.Unmarshal([]byte(newSpecBytes), &newSpec)
-	if err != nil {
+	newSpec := *pod.DeepCopy()
+	if err := template.Replace(&newSpec, podParams, true); err != nil {
 		return nil, errors.InternalWrapError(err)
 	}
 	return &newSpec, nil
