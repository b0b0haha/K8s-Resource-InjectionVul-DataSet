From 079dafdae334b93e1b9217ef7bc53bcee1405835 Mon Sep 17 00:00:00 2001
From: Tom Proctor <tomhjp@users.noreply.github.com>
Date: Wed, 4 Nov 2020 17:45:31 +0000
Subject: [PATCH] Enforce descending directory write path

---
 provider.go      | 14 ++++++++++++++
 provider_test.go | 47 +++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 61 insertions(+)
 create mode 100644 provider_test.go

diff --git a/provider.go b/provider.go
index 5260d44..fc1b2e3 100644
--- a/provider.go
+++ b/provider.go
@@ -449,6 +449,9 @@ func (p *Provider) MountSecretsStoreObjectContent(ctx context.Context, attrib ma
 			return err
 		}
 		objectContent := []byte(content)
+		if err := validateFilePath(keyValueObject.ObjectName); err != nil {
+			return err
+		}
 		if err := ioutil.WriteFile(path.Join(targetPath, keyValueObject.ObjectName), objectContent, permission); err != nil {
 			return errors.Wrapf(err, "secrets-store csi driver failed to write %s at %s", keyValueObject.ObjectName, targetPath)
 		}
@@ -458,6 +461,17 @@ func (p *Provider) MountSecretsStoreObjectContent(ctx context.Context, attrib ma
 	return nil
 }
 
+func validateFilePath(path string) error {
+	segments := strings.Split(strings.ReplaceAll(path, `\`, "/"), "/")
+	for _, segment := range segments {
+		if segment == ".." {
+			return fmt.Errorf("ObjectName %q invalid, must not contain any .. segments", path)
+		}
+	}
+
+	return nil
+}
+
 // GetKeyValueObjectContent get content of the vault object
 func (p *Provider) GetKeyValueObjectContent(ctx context.Context, objectPath string, objectName string, objectVersion string) (content string, err error) {
 	// Read the jwt token from disk
diff --git a/provider_test.go b/provider_test.go
new file mode 100644
index 0000000..bee5c4c
--- /dev/null
+++ b/provider_test.go
@@ -0,0 +1,47 @@
+package main
+
+import (
+	"strings"
+	"testing"
+)
+
+func TestValidateFilePath(t *testing.T) {
+	// Don't use filepath.Join to generate the test cases because it calls filepath.Clean
+	// which simplifies some of the test cases into less interesting paths.
+	for _, tc := range []string {
+		"",
+		".",
+		"/",
+		"bar",
+		"bar/foo",
+		"bar///foo",
+		"./bar",
+		"/foo/bar",
+		"foo/bar\\baz",
+	} {
+		err := validateFilePath(tc)
+		if err != nil {
+			t.Fatalf("Expected no error for %q but got %s", tc, err)
+		}
+	}
+}
+
+func TestValidatePath_Malformed(t *testing.T) {
+	for _, tc := range []string{
+		"../bar",
+		"foo/..",
+		"foo/../../bar",
+		"foo////..",
+	} {
+		err := validateFilePath(tc)
+		if err == nil {
+			t.Fatalf("Expected error for %q but got none", tc)
+		}
+
+		tc = strings.ReplaceAll(tc, "/", "\\")
+		err = validateFilePath(tc)
+		if err == nil {
+			t.Fatalf("Expected error for %q but got none", tc)
+		}
+	}
+}
\ No newline at end of file
