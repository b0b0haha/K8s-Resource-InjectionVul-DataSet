From ccd5b0a1f41e919620d4a8b488c10e73897e6f18 Mon Sep 17 00:00:00 2001
From: Anish Ramasekar <anish.ramasekar@gmail.com>
Date: Tue, 3 Nov 2020 12:52:00 -0800
Subject: [PATCH] feat: add validation for file name

---
 pkg/provider/provider.go      | 44 +++++++++++++++++++++++++++++++----
 pkg/provider/provider_test.go | 43 ++++++++++++++++++++++++++++++++++
 2 files changed, 82 insertions(+), 5 deletions(-)

diff --git a/pkg/provider/provider.go b/pkg/provider/provider.go
index 6fbd9eee3..5fbf0169c 100644
--- a/pkg/provider/provider.go
+++ b/pkg/provider/provider.go
@@ -253,6 +253,7 @@ func (p *Provider) MountSecretsStoreObjectContent(ctx context.Context, attrib ma
 
 	objectVersionMap := make(map[string]string)
 	for _, keyVaultObject := range keyVaultObjects {
+		// validation on the provided object
 		klog.V(2).Infof("fetching object: %s, type: %s from key vault %s", keyVaultObject.ObjectName, keyVaultObject.ObjectType, p.KeyvaultName)
 		if err := validateObjectFormat(keyVaultObject.ObjectFormat, keyVaultObject.ObjectType); err != nil {
 			return nil, wrapObjectTypeError(err, keyVaultObject.ObjectType, keyVaultObject.ObjectName, keyVaultObject.ObjectVersion)
@@ -260,6 +261,15 @@ func (p *Provider) MountSecretsStoreObjectContent(ctx context.Context, attrib ma
 		if err := validateObjectEncoding(keyVaultObject.ObjectEncoding, keyVaultObject.ObjectType); err != nil {
 			return nil, wrapObjectTypeError(err, keyVaultObject.ObjectType, keyVaultObject.ObjectName, keyVaultObject.ObjectVersion)
 		}
+		fileName := keyVaultObject.ObjectName
+		if keyVaultObject.ObjectAlias != "" {
+			fileName = keyVaultObject.ObjectAlias
+		}
+		if err := validateFileName(fileName); err != nil {
+			return nil, wrapObjectTypeError(err, keyVaultObject.ObjectType, keyVaultObject.ObjectName, keyVaultObject.ObjectVersion)
+		}
+
+		// fetch the object from Key Vault
 		content, newObjectVersion, err := p.GetKeyVaultObjectContent(ctx, keyVaultObject)
 		if err != nil {
 			return nil, err
@@ -274,11 +284,6 @@ func (p *Provider) MountSecretsStoreObjectContent(ctx context.Context, attrib ma
 		if err != nil {
 			return nil, err
 		}
-
-		fileName := keyVaultObject.ObjectName
-		if keyVaultObject.ObjectAlias != "" {
-			fileName = keyVaultObject.ObjectAlias
-		}
 		if err := ioutil.WriteFile(filepath.Join(targetPath, fileName), objectContent, permission); err != nil {
 			return nil, errors.Wrapf(err, "failed to write file %s at %s", fileName, targetPath)
 		}
@@ -594,3 +599,32 @@ func formatKeyVaultObject(object *KeyVaultObject) {
 		field.SetString(str)
 	}
 }
+
+// This validate will make sure fileName:
+// 1. is not abs path
+// 2. does not contain any '..' elements
+// 3. does not start with '..'
+// These checks have been implemented based on -
+// [validateLocalDescendingPath] https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L1158-L1170
+// [validatePathNoBacksteps] https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/validation/validation.go#L1172-L1186
+func validateFileName(fileName string) error {
+	if len(fileName) == 0 {
+		return fmt.Errorf("file name must not be empty")
+	}
+	// is not abs path
+	if filepath.IsAbs(fileName) {
+		return fmt.Errorf("file name must be a relative path")
+	}
+	// does not have any element which is ".."
+	parts := strings.Split(filepath.ToSlash(fileName), "/")
+	for _, item := range parts {
+		if item == ".." {
+			return fmt.Errorf("file name must not contain '..'")
+		}
+	}
+	// fallback logic if .. is missed in the previous check
+	if strings.Contains(fileName, "..") {
+		return fmt.Errorf("file name must not contain '..'")
+	}
+	return nil
+}
diff --git a/pkg/provider/provider_test.go b/pkg/provider/provider_test.go
index 0fac246bf..174c6da71 100644
--- a/pkg/provider/provider_test.go
+++ b/pkg/provider/provider_test.go
@@ -514,3 +514,46 @@ func TestFormatKeyVaultObject(t *testing.T) {
 		})
 	}
 }
+
+func TestValidateFilePath(t *testing.T) {
+	cases := []struct {
+		desc        string
+		fileName    string
+		expectedErr error
+	}{
+		{
+			desc:        "file name is absolute path",
+			fileName:    "/secret1",
+			expectedErr: fmt.Errorf("file name must be a relative path"),
+		},
+		{
+			desc:        "file name contains '..'",
+			fileName:    "secret1/..",
+			expectedErr: fmt.Errorf("file name must not contain '..'"),
+		},
+		{
+			desc:        "file name starts with '..'",
+			fileName:    "../secret1",
+			expectedErr: fmt.Errorf("file name must not contain '..'"),
+		},
+		{
+			desc:        "file name is empty",
+			fileName:    "",
+			expectedErr: fmt.Errorf("file name must not be empty"),
+		},
+		{
+			desc:        "valid file name",
+			fileName:    "secret1",
+			expectedErr: nil,
+		},
+	}
+
+	for _, tc := range cases {
+		t.Run(tc.desc, func(t *testing.T) {
+			err := validateFileName(tc.fileName)
+			if tc.expectedErr != nil && err.Error() != tc.expectedErr.Error() || tc.expectedErr == nil && err != nil {
+				t.Fatalf("expected err: %+v, got: %+v", tc.expectedErr, err)
+			}
+		})
+	}
+}
