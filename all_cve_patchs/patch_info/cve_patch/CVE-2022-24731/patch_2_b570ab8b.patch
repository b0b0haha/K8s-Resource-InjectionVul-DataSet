From b570ab8b1703eeca12c590e307632d3f66d013ba Mon Sep 17 00:00:00 2001
From: Alexander Matyushentsev <AMatyushentsev@gmail.com>
Date: Thu, 24 Feb 2022 12:58:38 -0800
Subject: [PATCH] fix: prevent file traversal using helm file values param and
 application details api (#8606)

* fix: prevent file traversal using helm file values param and application details api

Signed-off-by: Alexander Matyushentsev <AMatyushentsev@gmail.com>

* apply reviewer notes: move resolve.go into separate package; use uuid to generate random file

Signed-off-by: Alexander Matyushentsev <AMatyushentsev@gmail.com>
---
 reposerver/apiclient/repository.go            |  15 ++
 reposerver/apiclient/repository.pb.go         | 244 +++++++++++-------
 reposerver/repository/repository.go           | 197 ++------------
 reposerver/repository/repository.proto        |   1 +
 reposerver/repository/repository_test.go      | 208 ++-------------
 server/application/application.go             |   1 +
 server/repository/repository.go               |   5 +
 util/argo/argo.go                             |   1 +
 util/argo/argo_test.go                        |   1 +
 util/helm/cmd.go                              |   9 +-
 util/helm/helm.go                             |   8 +-
 util/helm/helm_test.go                        |  11 +-
 util/io/path/resolved.go                      | 158 ++++++++++++
 util/io/path/resolved_test.go                 | 181 +++++++++++++
 .../symlinks => util/io/path/testdata}/bam    |   0
 .../symlinks => util/io/path/testdata}/bar    |   0
 .../symlinks => util/io/path/testdata}/baz    |   0
 .../symlinks => util/io/path/testdata}/foo    |   0
 18 files changed, 585 insertions(+), 455 deletions(-)
 create mode 100644 reposerver/apiclient/repository.go
 create mode 100644 util/io/path/resolved.go
 create mode 100644 util/io/path/resolved_test.go
 rename {reposerver/repository/testdata/symlinks => util/io/path/testdata}/bam (100%)
 rename {reposerver/repository/testdata/symlinks => util/io/path/testdata}/bar (100%)
 rename {reposerver/repository/testdata/symlinks => util/io/path/testdata}/baz (100%)
 rename {reposerver/repository/testdata/symlinks => util/io/path/testdata}/foo (100%)

diff --git a/reposerver/apiclient/repository.go b/reposerver/apiclient/repository.go
new file mode 100644
index 0000000000000..20516c2988b87
--- /dev/null
+++ b/reposerver/apiclient/repository.go
@@ -0,0 +1,15 @@
+package apiclient
+
+func (q *ManifestRequest) GetValuesFileSchemes() []string {
+	if q.HelmOptions == nil {
+		return nil
+	}
+	return q.HelmOptions.ValuesFileSchemes
+}
+
+func (q *RepoServerAppDetailsQuery) GetValuesFileSchemes() []string {
+	if q.HelmOptions == nil {
+		return nil
+	}
+	return q.HelmOptions.ValuesFileSchemes
+}
diff --git a/reposerver/apiclient/repository.pb.go b/reposerver/apiclient/repository.pb.go
index 490d5f27e02e5..b93452305bbec 100644
--- a/reposerver/apiclient/repository.pb.go
+++ b/reposerver/apiclient/repository.pb.go
@@ -612,6 +612,7 @@ type RepoServerAppDetailsQuery struct {
 	NoCache              bool                        `protobuf:"varint,6,opt,name=noCache,proto3" json:"noCache,omitempty"`
 	NoRevisionCache      bool                        `protobuf:"varint,7,opt,name=noRevisionCache,proto3" json:"noRevisionCache,omitempty"`
 	TrackingMethod       string                      `protobuf:"bytes,8,opt,name=trackingMethod,proto3" json:"trackingMethod,omitempty"`
+	HelmOptions          *v1alpha1.HelmOptions       `protobuf:"bytes,10,opt,name=helmOptions,proto3" json:"helmOptions,omitempty"`
 	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
 	XXX_unrecognized     []byte                      `json:"-"`
 	XXX_sizecache        int32                       `json:"-"`
@@ -706,6 +707,13 @@ func (m *RepoServerAppDetailsQuery) GetTrackingMethod() string {
 	return ""
 }
 
+func (m *RepoServerAppDetailsQuery) GetHelmOptions() *v1alpha1.HelmOptions {
+	if m != nil {
+		return m.HelmOptions
+	}
+	return nil
+}
+
 // RepoAppDetailsResponse application details
 type RepoAppDetailsResponse struct {
 	Type                 string            `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
@@ -1391,98 +1399,98 @@ func init() {
 }
 
 var fileDescriptor_dd8723cfcc820480 = []byte{
-	// 1441 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x4b, 0x6f, 0xdb, 0xc6,
-	0x16, 0x36, 0x6d, 0xd9, 0x96, 0x8e, 0x12, 0x5b, 0x9e, 0x3c, 0x2e, 0xaf, 0xae, 0x23, 0x38, 0x04,
-	0x6e, 0xe0, 0x36, 0x0d, 0x85, 0x28, 0x41, 0x1b, 0x24, 0x40, 0x01, 0xd5, 0x49, 0x9c, 0xc2, 0x71,
-	0xec, 0xd2, 0x69, 0x81, 0x16, 0x41, 0x83, 0x31, 0x75, 0x4c, 0x4d, 0x25, 0x91, 0x13, 0x92, 0x52,
-	0xe1, 0x00, 0x5d, 0x16, 0x5d, 0x74, 0xdd, 0xfe, 0x9d, 0x6e, 0xfa, 0x5a, 0xf6, 0x27, 0x14, 0x59,
-	0xf4, 0x77, 0x14, 0x33, 0x7c, 0x0d, 0x29, 0xda, 0x2d, 0xa0, 0xc4, 0xd9, 0xd8, 0x33, 0xe7, 0x3d,
-	0x67, 0xce, 0x7c, 0xe7, 0x88, 0x70, 0xcd, 0x47, 0xee, 0x05, 0xe8, 0x4f, 0xd0, 0x6f, 0xcb, 0x25,
-	0x0b, 0x3d, 0xff, 0x58, 0x59, 0x9a, 0xdc, 0xf7, 0x42, 0x8f, 0x40, 0x46, 0x69, 0x5e, 0x74, 0x3c,
-	0xc7, 0x93, 0xe4, 0xb6, 0x58, 0x45, 0x12, 0xcd, 0x75, 0xc7, 0xf3, 0x9c, 0x21, 0xb6, 0x29, 0x67,
-	0x6d, 0xea, 0xba, 0x5e, 0x48, 0x43, 0xe6, 0xb9, 0x41, 0xcc, 0x35, 0x06, 0x77, 0x02, 0x93, 0x79,
-	0x92, 0x6b, 0x7b, 0x3e, 0xb6, 0x27, 0x37, 0xdb, 0x0e, 0xba, 0xe8, 0xd3, 0x10, 0x7b, 0xb1, 0xcc,
-	0x63, 0x87, 0x85, 0xfd, 0xf1, 0xa1, 0x69, 0x7b, 0xa3, 0x36, 0xf5, 0xa5, 0x8b, 0xaf, 0xe4, 0xe2,
-	0x86, 0xdd, 0x6b, 0x4f, 0x3a, 0x6d, 0x3e, 0x70, 0x84, 0x7e, 0xd0, 0xa6, 0x9c, 0x0f, 0x99, 0x2d,
-	0xed, 0xb7, 0x27, 0x37, 0xe9, 0x90, 0xf7, 0xe9, 0x94, 0x35, 0xe3, 0xaf, 0x2a, 0xac, 0xee, 0x52,
-	0x97, 0x1d, 0x61, 0x10, 0x5a, 0xf8, 0x62, 0x8c, 0x41, 0x48, 0x9e, 0x41, 0x45, 0x9c, 0x43, 0xd7,
-	0x36, 0xb4, 0xcd, 0x7a, 0xe7, 0x91, 0x99, 0x39, 0x34, 0x13, 0x87, 0x72, 0xf1, 0xdc, 0xee, 0x99,
-	0x93, 0x8e, 0xc9, 0x07, 0x8e, 0x29, 0x1c, 0x9a, 0x8a, 0x43, 0x33, 0x71, 0x68, 0x5a, 0x69, 0x46,
-	0x2c, 0x69, 0x95, 0x34, 0xa1, 0xea, 0xe3, 0x84, 0x05, 0xcc, 0x73, 0xf5, 0xf9, 0x0d, 0x6d, 0xb3,
-	0x66, 0xa5, 0x7b, 0xa2, 0xc3, 0xb2, 0xeb, 0x6d, 0x51, 0xbb, 0x8f, 0xfa, 0xc2, 0x86, 0xb6, 0x59,
-	0xb5, 0x92, 0x2d, 0xd9, 0x80, 0x3a, 0xe5, 0xfc, 0x31, 0x3d, 0xc4, 0xe1, 0x0e, 0x1e, 0xeb, 0x15,
-	0xa9, 0xa8, 0x92, 0x84, 0x2e, 0xe5, 0xfc, 0x09, 0x1d, 0xa1, 0xbe, 0x28, 0xb9, 0xc9, 0x96, 0xac,
-	0x43, 0xcd, 0xa5, 0x23, 0x0c, 0x38, 0xb5, 0x51, 0xaf, 0x4a, 0x5e, 0x46, 0x20, 0xdf, 0xc0, 0x9a,
-	0x12, 0xf8, 0x81, 0x37, 0xf6, 0x6d, 0xd4, 0x41, 0x1e, 0x7d, 0x6f, 0xb6, 0xa3, 0x77, 0x8b, 0x66,
-	0xad, 0x69, 0x4f, 0xe4, 0x4b, 0x58, 0x94, 0x45, 0xa3, 0xd7, 0x37, 0x16, 0x5e, 0x6b, 0xb6, 0x23,
-	0xb3, 0xc4, 0x85, 0x65, 0x3e, 0x1c, 0x3b, 0xcc, 0x0d, 0xf4, 0x73, 0xd2, 0xc3, 0xd3, 0xd9, 0x3c,
-	0x6c, 0x79, 0xee, 0x11, 0x73, 0x76, 0xa9, 0x4b, 0x1d, 0x1c, 0xa1, 0x1b, 0xee, 0x4b, 0xe3, 0x56,
-	0xe2, 0x84, 0xbc, 0x84, 0xc6, 0x60, 0x1c, 0x84, 0xde, 0x88, 0xbd, 0xc4, 0x3d, 0x2e, 0x8b, 0x5b,
-	0x3f, 0x2f, 0xb3, 0xf9, 0x64, 0x36, 0xc7, 0x3b, 0x05, 0xab, 0xd6, 0x94, 0x1f, 0x51, 0x24, 0x83,
-	0xf1, 0x21, 0x7e, 0x86, 0xbe, 0xac, 0xae, 0x95, 0xa8, 0x48, 0x14, 0x52, 0x54, 0x46, 0x2c, 0xde,
-	0x05, 0xfa, 0xea, 0xc6, 0x42, 0x54, 0x46, 0x29, 0x89, 0x6c, 0xc2, 0xea, 0x04, 0x7d, 0x76, 0x74,
-	0x7c, 0xc0, 0x1c, 0x97, 0x86, 0x63, 0x1f, 0xf5, 0x86, 0x2c, 0xc5, 0x22, 0x99, 0x8c, 0xe0, 0x7c,
-	0x1f, 0x87, 0x23, 0x91, 0xf2, 0x2d, 0x1f, 0x7b, 0x81, 0xbe, 0x26, 0xf3, 0xbb, 0x3d, 0xfb, 0x0d,
-	0x4a, 0x73, 0x56, 0xde, 0xba, 0x08, 0xcc, 0xf5, 0xac, 0xf8, 0xa5, 0x44, 0x6f, 0x84, 0x44, 0x81,
-	0x15, 0xc8, 0xe4, 0x1a, 0xac, 0x84, 0x3e, 0xb5, 0x07, 0xcc, 0x75, 0x76, 0x31, 0xec, 0x7b, 0x3d,
-	0xfd, 0x82, 0xcc, 0x44, 0x81, 0x4a, 0x06, 0x50, 0x17, 0x2e, 0x92, 0x5b, 0xba, 0x24, 0x6f, 0xe9,
-	0xe3, 0xd9, 0xc2, 0x7f, 0x94, 0x19, 0xb4, 0x54, 0xeb, 0xc6, 0x18, 0x2e, 0x3d, 0x95, 0x18, 0x93,
-	0x16, 0xe8, 0x59, 0xa0, 0x8d, 0xf1, 0x08, 0x2e, 0x17, 0xdd, 0x06, 0xdc, 0x73, 0x03, 0x24, 0x26,
-	0x10, 0x79, 0xa3, 0x0c, 0x7b, 0x19, 0x57, 0x46, 0x51, 0xb5, 0x4a, 0x38, 0xc6, 0xaf, 0x1a, 0x34,
-	0x32, 0xa4, 0x8c, 0x8d, 0xac, 0x43, 0x6d, 0x14, 0xd3, 0x02, 0x5d, 0x93, 0xd5, 0x94, 0x11, 0xf2,
-	0xc0, 0x33, 0x5f, 0x04, 0x9e, 0xcb, 0xb0, 0x14, 0xb5, 0x14, 0x89, 0x75, 0x35, 0x2b, 0xde, 0xe5,
-	0x00, 0xb2, 0x52, 0x00, 0xc8, 0x16, 0x40, 0x20, 0x71, 0xe3, 0xe9, 0x31, 0x47, 0x7d, 0x49, 0x72,
-	0x15, 0x0a, 0x31, 0xe0, 0x5c, 0x54, 0xa6, 0x16, 0x06, 0xe3, 0x61, 0xa8, 0x2f, 0x4b, 0x89, 0x1c,
-	0xcd, 0xf0, 0x60, 0xf5, 0x31, 0x13, 0x67, 0x38, 0x0a, 0xce, 0xe6, 0x0e, 0xde, 0x87, 0x8a, 0x70,
-	0x26, 0x0e, 0x76, 0xe8, 0x53, 0xd7, 0xee, 0x63, 0x92, 0xab, 0x74, 0x4f, 0x08, 0x54, 0x42, 0xea,
-	0x04, 0xfa, 0xbc, 0xa4, 0xcb, 0xb5, 0xf1, 0xbd, 0x16, 0x45, 0xda, 0xe5, 0x3c, 0x78, 0xeb, 0xbd,
-	0xc9, 0x18, 0xc3, 0x72, 0x97, 0x73, 0x11, 0x0f, 0xb9, 0x09, 0x15, 0xca, 0x79, 0x74, 0x88, 0x7a,
-	0xe7, 0x8a, 0xa9, 0xcc, 0x01, 0xb1, 0x88, 0xf8, 0x1f, 0x3c, 0x70, 0x43, 0x61, 0x59, 0x88, 0x36,
-	0x3f, 0x80, 0x5a, 0x4a, 0x22, 0x0d, 0x58, 0x18, 0x60, 0x54, 0x6b, 0x35, 0x4b, 0x2c, 0xc9, 0x45,
-	0x58, 0x9c, 0xd0, 0xe1, 0x38, 0xa9, 0x92, 0x68, 0x73, 0x77, 0xfe, 0x8e, 0x66, 0xfc, 0x5c, 0x81,
-	0xff, 0x8a, 0x38, 0x0f, 0x64, 0x71, 0x74, 0x39, 0xbf, 0x8f, 0x21, 0x65, 0xc3, 0xe0, 0x93, 0x31,
-	0xfa, 0xc7, 0x6f, 0x38, 0x1d, 0x0e, 0x2c, 0x45, 0xb5, 0x25, 0xc3, 0x7a, 0x03, 0xfd, 0x30, 0x36,
-	0x9f, 0x35, 0xc1, 0x85, 0x37, 0xd3, 0x04, 0xcb, 0x9a, 0x52, 0xe5, 0x8c, 0x9a, 0xd2, 0xc9, 0x73,
-	0x89, 0x32, 0xed, 0x2c, 0xe5, 0xa7, 0x9d, 0x12, 0xac, 0x5f, 0xfe, 0xb7, 0x58, 0x5f, 0x2d, 0xc3,
-	0x7a, 0xe3, 0xbb, 0x79, 0xb8, 0x2c, 0xf2, 0x92, 0x15, 0x50, 0x8a, 0x61, 0xe2, 0xe9, 0x09, 0x34,
-	0x89, 0xca, 0x51, 0xae, 0xc9, 0x6d, 0x58, 0x1e, 0x04, 0x9e, 0xeb, 0x62, 0x18, 0x5f, 0x7d, 0x53,
-	0x2d, 0xf2, 0x9d, 0x88, 0xd5, 0xe5, 0xfc, 0x80, 0xa3, 0x6d, 0x25, 0xa2, 0xe4, 0x3a, 0x54, 0x04,
-	0xe4, 0x4b, 0x3c, 0xab, 0x77, 0xfe, 0xa3, 0xaa, 0x88, 0xbe, 0x90, 0xc8, 0x4b, 0x21, 0x72, 0x17,
-	0x6a, 0x69, 0xae, 0xe2, 0xcb, 0x58, 0xcf, 0x39, 0x49, 0x98, 0x89, 0x5a, 0x26, 0x2e, 0x74, 0x7b,
-	0xcc, 0x47, 0x5b, 0x42, 0xf6, 0xe2, 0xb4, 0xee, 0xfd, 0x84, 0x99, 0xea, 0xa6, 0xe2, 0xc6, 0x2f,
-	0x1a, 0x5c, 0xcd, 0x1e, 0x54, 0x92, 0xcd, 0x5d, 0x0c, 0x69, 0x8f, 0x86, 0xf4, 0xed, 0xcf, 0xc0,
-	0xd7, 0x60, 0xc5, 0xee, 0xa3, 0x3d, 0xc8, 0xe6, 0x8f, 0x68, 0x14, 0x2e, 0x50, 0x8d, 0xdf, 0xe6,
-	0x61, 0x25, 0x7f, 0x11, 0xe2, 0x26, 0x45, 0x7b, 0x49, 0x6e, 0x52, 0xac, 0xc9, 0x3e, 0x9c, 0x43,
-	0x77, 0xc2, 0x7c, 0xcf, 0x15, 0xd3, 0x5a, 0xf2, 0xc2, 0xde, 0x3b, 0xf9, 0x3a, 0xcd, 0x07, 0x8a,
-	0x78, 0x04, 0x61, 0x39, 0x0b, 0xc4, 0x05, 0xe0, 0xd4, 0xa7, 0x23, 0x0c, 0xd1, 0x17, 0xcf, 0x68,
-	0xe1, 0x35, 0x3c, 0xa3, 0x28, 0x82, 0xfd, 0xc4, 0xac, 0xa5, 0x78, 0x68, 0x3e, 0x87, 0xb5, 0xa9,
-	0x90, 0x4a, 0x20, 0xf4, 0xb6, 0x0a, 0xa1, 0xf5, 0x4e, 0xab, 0xe4, 0x84, 0x8a, 0x19, 0x15, 0x62,
-	0x7f, 0x9a, 0x87, 0xba, 0x52, 0x9f, 0xa5, 0x69, 0x6c, 0x01, 0x48, 0x85, 0x87, 0x6c, 0x88, 0x51,
-	0x12, 0x6b, 0x96, 0x42, 0x21, 0x83, 0x92, 0xa4, 0xec, 0xcc, 0x3e, 0x4a, 0x95, 0x66, 0x44, 0x4c,
-	0x0e, 0xd2, 0x75, 0x10, 0x23, 0x4a, 0xbc, 0x23, 0x5f, 0xc3, 0xca, 0x11, 0x1b, 0xe2, 0x7e, 0x16,
-	0xc8, 0x92, 0x0c, 0x64, 0x6f, 0xf6, 0x40, 0x1e, 0xaa, 0x76, 0xad, 0x82, 0x1b, 0xe3, 0x5d, 0x68,
-	0x14, 0x9f, 0xab, 0x08, 0x92, 0x8d, 0xa8, 0x93, 0x66, 0x2b, 0xde, 0x19, 0x3f, 0x68, 0x40, 0xa6,
-	0xef, 0xe3, 0xa4, 0xa4, 0x0f, 0xee, 0x04, 0xc9, 0x38, 0x1f, 0x3d, 0x14, 0x85, 0x42, 0x76, 0xa0,
-	0xde, 0xc3, 0x20, 0x64, 0xae, 0x0c, 0x38, 0x06, 0x91, 0x77, 0x4e, 0xbf, 0xf8, 0xfb, 0x99, 0x82,
-	0xa5, 0x6a, 0x1b, 0x9f, 0xc2, 0x95, 0x53, 0xa5, 0x95, 0x79, 0x4d, 0xcb, 0xcd, 0x6b, 0xa7, 0x4e,
-	0x79, 0x06, 0x81, 0x46, 0x11, 0x8d, 0x8c, 0x17, 0xb0, 0x26, 0x72, 0xba, 0xd5, 0xa7, 0x7e, 0x78,
-	0x46, 0x33, 0xd8, 0x3d, 0xa8, 0xa5, 0x2e, 0x4b, 0x73, 0xdd, 0x84, 0xea, 0x24, 0xf9, 0x59, 0x14,
-	0x0d, 0x61, 0xe9, 0xde, 0xe8, 0x02, 0x51, 0xe3, 0x8d, 0xfb, 0xc6, 0x75, 0x58, 0x64, 0x21, 0x8e,
-	0x92, 0x31, 0xe8, 0x52, 0x11, 0xee, 0xa5, 0xb8, 0x15, 0xc9, 0x74, 0xbe, 0x5d, 0x84, 0xb5, 0x0c,
-	0x75, 0xc5, 0x5f, 0x66, 0x23, 0xd9, 0x83, 0xc6, 0x76, 0xfc, 0x41, 0x22, 0x19, 0xad, 0xc9, 0xff,
-	0x54, 0x3b, 0x85, 0x4f, 0x13, 0xcd, 0xf5, 0x72, 0x66, 0x14, 0x91, 0x31, 0x47, 0x3e, 0x87, 0x95,
-	0xfc, 0xb8, 0x4f, 0xae, 0xaa, 0x1a, 0xa5, 0xbf, 0x40, 0x9a, 0xc6, 0x69, 0x22, 0xa9, 0xe9, 0x7b,
-	0x50, 0x4d, 0xc6, 0xe6, 0x7c, 0x8c, 0x85, 0x61, 0xba, 0xd9, 0x50, 0x99, 0x82, 0x61, 0xcc, 0x91,
-	0x0f, 0x23, 0x65, 0x31, 0x02, 0x4e, 0x2b, 0x2b, 0xf3, 0x6d, 0xf3, 0x42, 0xc9, 0x30, 0x69, 0xcc,
-	0x91, 0x67, 0x70, 0x7e, 0x5b, 0x22, 0x74, 0xdc, 0xbc, 0xc9, 0xff, 0xf3, 0x4e, 0x4e, 0x98, 0x0f,
-	0xf3, 0x47, 0x2b, 0xef, 0xff, 0xc6, 0x1c, 0xf9, 0x51, 0x83, 0x0b, 0xdb, 0x18, 0x16, 0x7b, 0x21,
-	0xb9, 0x51, 0xee, 0xe4, 0x84, 0x9e, 0xd9, 0x7c, 0x32, 0x6b, 0xcd, 0xe6, 0xcd, 0x1a, 0x73, 0x64,
-	0x5f, 0x1e, 0x3b, 0xab, 0x3d, 0x72, 0xa5, 0xb4, 0xc8, 0xd2, 0xec, 0xb5, 0x4e, 0x62, 0x27, 0x47,
-	0xfd, 0xa8, 0xfb, 0xfb, 0xab, 0x96, 0xf6, 0xc7, 0xab, 0x96, 0xf6, 0xe7, 0xab, 0x96, 0xf6, 0xc5,
-	0xad, 0x7f, 0xf8, 0x96, 0xa6, 0x7c, 0xf6, 0xa3, 0x9c, 0xd9, 0x43, 0x86, 0x6e, 0x78, 0xb8, 0x24,
-	0xbf, 0x9c, 0xdd, 0xfa, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xf9, 0x2d, 0xd7, 0x68, 0x15, 0x14, 0x00,
-	0x00,
+	// 1447 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xdd, 0x6e, 0x1b, 0xc5,
+	0x17, 0xcf, 0x3a, 0x76, 0x62, 0x1f, 0xb7, 0x89, 0x33, 0xfd, 0xf8, 0xef, 0xdf, 0xa4, 0x56, 0xba,
+	0x12, 0x55, 0xa0, 0x74, 0xad, 0xba, 0x15, 0x54, 0xad, 0x84, 0x64, 0xd2, 0x36, 0x45, 0x69, 0x9a,
+	0xb0, 0x29, 0x48, 0xa0, 0x8a, 0x6a, 0xb2, 0x9e, 0xac, 0x07, 0xdb, 0xbb, 0xd3, 0xdd, 0xb1, 0x51,
+	0x2a, 0x71, 0x89, 0xb8, 0xe0, 0x1a, 0xde, 0x83, 0x27, 0xe0, 0x8a, 0x8f, 0x4b, 0x1e, 0x01, 0xf5,
+	0x82, 0xe7, 0x40, 0x33, 0xfb, 0x35, 0xbb, 0x5e, 0x87, 0x4a, 0x6e, 0xd2, 0x9b, 0x64, 0xe6, 0xcc,
+	0xf9, 0x9a, 0x73, 0xce, 0xfc, 0xce, 0xf1, 0xc2, 0x35, 0x9f, 0x30, 0x2f, 0x20, 0xfe, 0x84, 0xf8,
+	0x6d, 0xb9, 0xa4, 0xdc, 0xf3, 0x8f, 0x95, 0xa5, 0xc9, 0x7c, 0x8f, 0x7b, 0x08, 0x52, 0x4a, 0xf3,
+	0xa2, 0xe3, 0x39, 0x9e, 0x24, 0xb7, 0xc5, 0x2a, 0xe4, 0x68, 0xae, 0x3b, 0x9e, 0xe7, 0x0c, 0x49,
+	0x1b, 0x33, 0xda, 0xc6, 0xae, 0xeb, 0x71, 0xcc, 0xa9, 0xe7, 0x06, 0xd1, 0xa9, 0x31, 0xb8, 0x13,
+	0x98, 0xd4, 0x93, 0xa7, 0xb6, 0xe7, 0x93, 0xf6, 0xe4, 0x66, 0xdb, 0x21, 0x2e, 0xf1, 0x31, 0x27,
+	0xbd, 0x88, 0xe7, 0xb1, 0x43, 0x79, 0x7f, 0x7c, 0x68, 0xda, 0xde, 0xa8, 0x8d, 0x7d, 0x69, 0xe2,
+	0x1b, 0xb9, 0xb8, 0x61, 0xf7, 0xda, 0x93, 0x4e, 0x9b, 0x0d, 0x1c, 0x21, 0x1f, 0xb4, 0x31, 0x63,
+	0x43, 0x6a, 0x4b, 0xfd, 0xed, 0xc9, 0x4d, 0x3c, 0x64, 0x7d, 0x3c, 0xa5, 0xcd, 0xf8, 0xa7, 0x0a,
+	0xab, 0xbb, 0xd8, 0xa5, 0x47, 0x24, 0xe0, 0x16, 0x79, 0x31, 0x26, 0x01, 0x47, 0xcf, 0xa0, 0x2c,
+	0xee, 0xa1, 0x6b, 0x1b, 0xda, 0x66, 0xbd, 0xf3, 0xc8, 0x4c, 0x0d, 0x9a, 0xb1, 0x41, 0xb9, 0x78,
+	0x6e, 0xf7, 0xcc, 0x49, 0xc7, 0x64, 0x03, 0xc7, 0x14, 0x06, 0x4d, 0xc5, 0xa0, 0x19, 0x1b, 0x34,
+	0xad, 0x24, 0x22, 0x96, 0xd4, 0x8a, 0x9a, 0x50, 0xf5, 0xc9, 0x84, 0x06, 0xd4, 0x73, 0xf5, 0xd2,
+	0x86, 0xb6, 0x59, 0xb3, 0x92, 0x3d, 0xd2, 0x61, 0xd9, 0xf5, 0xb6, 0xb0, 0xdd, 0x27, 0xfa, 0xe2,
+	0x86, 0xb6, 0x59, 0xb5, 0xe2, 0x2d, 0xda, 0x80, 0x3a, 0x66, 0xec, 0x31, 0x3e, 0x24, 0xc3, 0x1d,
+	0x72, 0xac, 0x97, 0xa5, 0xa0, 0x4a, 0x12, 0xb2, 0x98, 0xb1, 0x27, 0x78, 0x44, 0xf4, 0x8a, 0x3c,
+	0x8d, 0xb7, 0x68, 0x1d, 0x6a, 0x2e, 0x1e, 0x91, 0x80, 0x61, 0x9b, 0xe8, 0x55, 0x79, 0x96, 0x12,
+	0xd0, 0x77, 0xb0, 0xa6, 0x38, 0x7e, 0xe0, 0x8d, 0x7d, 0x9b, 0xe8, 0x20, 0xaf, 0xbe, 0x37, 0xdf,
+	0xd5, 0xbb, 0x79, 0xb5, 0xd6, 0xb4, 0x25, 0xf4, 0x35, 0x54, 0x64, 0xd1, 0xe8, 0xf5, 0x8d, 0xc5,
+	0x37, 0x1a, 0xed, 0x50, 0x2d, 0x72, 0x61, 0x99, 0x0d, 0xc7, 0x0e, 0x75, 0x03, 0xfd, 0x9c, 0xb4,
+	0xf0, 0x74, 0x3e, 0x0b, 0x5b, 0x9e, 0x7b, 0x44, 0x9d, 0x5d, 0xec, 0x62, 0x87, 0x8c, 0x88, 0xcb,
+	0xf7, 0xa5, 0x72, 0x2b, 0x36, 0x82, 0x5e, 0x42, 0x63, 0x30, 0x0e, 0xb8, 0x37, 0xa2, 0x2f, 0xc9,
+	0x1e, 0x93, 0xc5, 0xad, 0x9f, 0x97, 0xd1, 0x7c, 0x32, 0x9f, 0xe1, 0x9d, 0x9c, 0x56, 0x6b, 0xca,
+	0x8e, 0x28, 0x92, 0xc1, 0xf8, 0x90, 0x7c, 0x41, 0x7c, 0x59, 0x5d, 0x2b, 0x61, 0x91, 0x28, 0xa4,
+	0xb0, 0x8c, 0x68, 0xb4, 0x0b, 0xf4, 0xd5, 0x8d, 0xc5, 0xb0, 0x8c, 0x12, 0x12, 0xda, 0x84, 0xd5,
+	0x09, 0xf1, 0xe9, 0xd1, 0xf1, 0x01, 0x75, 0x5c, 0xcc, 0xc7, 0x3e, 0xd1, 0x1b, 0xb2, 0x14, 0xf3,
+	0x64, 0x34, 0x82, 0xf3, 0x7d, 0x32, 0x1c, 0x89, 0x90, 0x6f, 0xf9, 0xa4, 0x17, 0xe8, 0x6b, 0x32,
+	0xbe, 0xdb, 0xf3, 0x67, 0x50, 0xaa, 0xb3, 0xb2, 0xda, 0x85, 0x63, 0xae, 0x67, 0x45, 0x2f, 0x25,
+	0x7c, 0x23, 0x28, 0x74, 0x2c, 0x47, 0x46, 0xd7, 0x60, 0x85, 0xfb, 0xd8, 0x1e, 0x50, 0xd7, 0xd9,
+	0x25, 0xbc, 0xef, 0xf5, 0xf4, 0x0b, 0x32, 0x12, 0x39, 0x2a, 0x1a, 0x40, 0x5d, 0x98, 0x88, 0xb3,
+	0x74, 0x49, 0x66, 0xe9, 0xd3, 0xf9, 0xdc, 0x7f, 0x94, 0x2a, 0xb4, 0x54, 0xed, 0xc6, 0x18, 0x2e,
+	0x3d, 0x95, 0x18, 0x93, 0x14, 0xe8, 0x59, 0xa0, 0x8d, 0xf1, 0x08, 0x2e, 0xe7, 0xcd, 0x06, 0xcc,
+	0x73, 0x03, 0x82, 0x4c, 0x40, 0x32, 0xa3, 0x94, 0xf4, 0xd2, 0x53, 0xe9, 0x45, 0xd5, 0x2a, 0x38,
+	0x31, 0x7e, 0xd7, 0xa0, 0x91, 0x22, 0x65, 0xa4, 0x64, 0x1d, 0x6a, 0xa3, 0x88, 0x16, 0xe8, 0x9a,
+	0xac, 0xa6, 0x94, 0x90, 0x05, 0x9e, 0x52, 0x1e, 0x78, 0x2e, 0xc3, 0x52, 0xd8, 0x52, 0x24, 0xd6,
+	0xd5, 0xac, 0x68, 0x97, 0x01, 0xc8, 0x72, 0x0e, 0x20, 0x5b, 0x00, 0x81, 0xc4, 0x8d, 0xa7, 0xc7,
+	0x8c, 0xe8, 0x4b, 0xf2, 0x54, 0xa1, 0x20, 0x03, 0xce, 0x85, 0x65, 0x6a, 0x91, 0x60, 0x3c, 0xe4,
+	0xfa, 0xb2, 0xe4, 0xc8, 0xd0, 0x0c, 0x0f, 0x56, 0x1f, 0x53, 0x71, 0x87, 0xa3, 0xe0, 0x6c, 0x72,
+	0xf0, 0x21, 0x94, 0x85, 0x31, 0x71, 0xb1, 0x43, 0x1f, 0xbb, 0x76, 0x9f, 0xc4, 0xb1, 0x4a, 0xf6,
+	0x08, 0x41, 0x99, 0x63, 0x27, 0xd0, 0x4b, 0x92, 0x2e, 0xd7, 0xc6, 0x8f, 0x5a, 0xe8, 0x69, 0x97,
+	0xb1, 0xe0, 0xad, 0xf7, 0x26, 0x63, 0x0c, 0xcb, 0x5d, 0xc6, 0x84, 0x3f, 0xe8, 0x26, 0x94, 0x31,
+	0x63, 0xe1, 0x25, 0xea, 0x9d, 0x2b, 0xa6, 0x32, 0x07, 0x44, 0x2c, 0xe2, 0x7f, 0xf0, 0xc0, 0xe5,
+	0x42, 0xb3, 0x60, 0x6d, 0x7e, 0x04, 0xb5, 0x84, 0x84, 0x1a, 0xb0, 0x38, 0x20, 0x61, 0xad, 0xd5,
+	0x2c, 0xb1, 0x44, 0x17, 0xa1, 0x32, 0xc1, 0xc3, 0x71, 0x5c, 0x25, 0xe1, 0xe6, 0x6e, 0xe9, 0x8e,
+	0x66, 0xfc, 0x52, 0x81, 0xff, 0x0b, 0x3f, 0x0f, 0x64, 0x71, 0x74, 0x19, 0xbb, 0x4f, 0x38, 0xa6,
+	0xc3, 0xe0, 0xb3, 0x31, 0xf1, 0x8f, 0x4f, 0x39, 0x1c, 0x0e, 0x2c, 0x85, 0xb5, 0x25, 0xdd, 0x3a,
+	0x85, 0x7e, 0x18, 0xa9, 0x4f, 0x9b, 0xe0, 0xe2, 0xe9, 0x34, 0xc1, 0xa2, 0xa6, 0x54, 0x3e, 0xa3,
+	0xa6, 0x34, 0x7b, 0x2e, 0x51, 0xa6, 0x9d, 0xa5, 0xec, 0xb4, 0x53, 0x80, 0xf5, 0xcb, 0xaf, 0x8b,
+	0xf5, 0xd5, 0xd7, 0xc1, 0x7a, 0x38, 0x55, 0xac, 0xff, 0xa1, 0x04, 0x97, 0x45, 0x12, 0xd2, 0x6a,
+	0x4d, 0x00, 0x53, 0xbc, 0x73, 0x01, 0x5d, 0x61, 0xed, 0xcb, 0x35, 0xba, 0x0d, 0xcb, 0x83, 0xc0,
+	0x73, 0x5d, 0xc2, 0xa3, 0x3a, 0x6b, 0xaa, 0x2f, 0x6a, 0x27, 0x3c, 0xea, 0x32, 0x76, 0xc0, 0x88,
+	0x6d, 0xc5, 0xac, 0xe8, 0x3a, 0x94, 0x85, 0x4d, 0x09, 0x9e, 0xf5, 0xce, 0xff, 0x54, 0x11, 0xe1,
+	0x58, 0xcc, 0x2f, 0x99, 0xd0, 0x5d, 0xa8, 0x25, 0x89, 0x89, 0x32, 0xbf, 0x9e, 0x31, 0x12, 0x1f,
+	0xc6, 0x62, 0x29, 0xbb, 0x90, 0xed, 0x51, 0x9f, 0xd8, 0xb2, 0x3f, 0x54, 0xa6, 0x65, 0xef, 0xc7,
+	0x87, 0x89, 0x6c, 0xc2, 0x6e, 0xfc, 0xa6, 0xc1, 0xd5, 0xf4, 0xf5, 0xc6, 0xa9, 0xdb, 0x25, 0x1c,
+	0xf7, 0x30, 0xc7, 0x6f, 0x7f, 0xe0, 0xbe, 0x06, 0x2b, 0x76, 0x9f, 0xd8, 0x83, 0x74, 0xd8, 0x09,
+	0xe7, 0xee, 0x1c, 0xd5, 0xf8, 0xa3, 0x04, 0x2b, 0xd9, 0x44, 0x88, 0x4c, 0x8a, 0x5e, 0x16, 0x67,
+	0x52, 0xac, 0xd1, 0x3e, 0x9c, 0x23, 0xee, 0x84, 0xfa, 0x9e, 0x2b, 0x46, 0xc3, 0xf8, 0x39, 0x7f,
+	0x30, 0x3b, 0x9d, 0xe6, 0x03, 0x85, 0x3d, 0xc4, 0xcb, 0x8c, 0x06, 0xe4, 0x02, 0x30, 0xec, 0xe3,
+	0x11, 0xe1, 0xc4, 0x17, 0x6f, 0x76, 0xf1, 0x0d, 0xbc, 0xd9, 0xd0, 0x83, 0xfd, 0x58, 0xad, 0xa5,
+	0x58, 0x68, 0x3e, 0x87, 0xb5, 0x29, 0x97, 0x0a, 0xf0, 0xfa, 0xb6, 0x8a, 0xd7, 0xf5, 0x4e, 0xab,
+	0xe0, 0x86, 0x8a, 0x1a, 0x15, 0xcf, 0x7f, 0x2d, 0x41, 0x5d, 0xa9, 0xcf, 0xc2, 0x30, 0xb6, 0x00,
+	0xa4, 0xc0, 0x43, 0x3a, 0x24, 0x61, 0x10, 0x6b, 0x96, 0x42, 0x41, 0x83, 0x82, 0xa0, 0xec, 0xcc,
+	0xff, 0x96, 0x0b, 0x23, 0x22, 0xc6, 0x14, 0x69, 0x3a, 0x88, 0xe0, 0x2b, 0xda, 0xa1, 0x6f, 0x61,
+	0xe5, 0x88, 0x0e, 0xc9, 0x7e, 0xea, 0xc8, 0x92, 0x74, 0x64, 0x6f, 0x7e, 0x47, 0x1e, 0xaa, 0x7a,
+	0xad, 0x9c, 0x19, 0xe3, 0x7d, 0x68, 0xe4, 0x9f, 0xab, 0x70, 0x92, 0x8e, 0xb0, 0x93, 0x44, 0x2b,
+	0xda, 0x19, 0x3f, 0x69, 0x80, 0xa6, 0xf3, 0x31, 0x2b, 0xe8, 0x83, 0x3b, 0x41, 0xfc, 0xdb, 0x21,
+	0x7c, 0x28, 0x0a, 0x05, 0xed, 0x40, 0xbd, 0x47, 0x02, 0x4e, 0x5d, 0xe9, 0x70, 0x04, 0x22, 0xef,
+	0x9d, 0x9c, 0xf8, 0xfb, 0xa9, 0x80, 0xa5, 0x4a, 0x1b, 0x9f, 0xc3, 0x95, 0x13, 0xb9, 0x95, 0xe1,
+	0x50, 0xcb, 0x0c, 0x87, 0x27, 0x8e, 0x94, 0x06, 0x82, 0x46, 0x1e, 0x8d, 0x8c, 0x17, 0xb0, 0x26,
+	0x62, 0xba, 0xd5, 0xc7, 0x3e, 0x3f, 0xa3, 0x81, 0xef, 0x1e, 0xd4, 0x12, 0x93, 0x85, 0xb1, 0x6e,
+	0x42, 0x75, 0x12, 0xff, 0x06, 0x0b, 0x27, 0xbe, 0x64, 0x6f, 0x74, 0x01, 0xa9, 0xfe, 0x46, 0x7d,
+	0xe3, 0x3a, 0x54, 0x28, 0x27, 0xa3, 0x78, 0xe6, 0xba, 0x94, 0x87, 0x7b, 0xc9, 0x6e, 0x85, 0x3c,
+	0x9d, 0xef, 0x2b, 0xb0, 0x96, 0xa2, 0xae, 0xf8, 0x4b, 0x6d, 0x82, 0xf6, 0xa0, 0xb1, 0x1d, 0x7d,
+	0xfd, 0x88, 0xe7, 0x78, 0xf4, 0x8e, 0xaa, 0x27, 0xf7, 0x1d, 0xa4, 0xb9, 0x5e, 0x7c, 0x18, 0x7a,
+	0x64, 0x2c, 0xa0, 0x2f, 0x61, 0x25, 0xfb, 0xdb, 0x02, 0x5d, 0x55, 0x25, 0x0a, 0x7f, 0xee, 0x34,
+	0x8d, 0x93, 0x58, 0x12, 0xd5, 0xf7, 0xa0, 0x1a, 0xcf, 0xe8, 0x59, 0x1f, 0x73, 0x93, 0x7b, 0xb3,
+	0xa1, 0x1e, 0x8a, 0x03, 0x63, 0x01, 0x7d, 0x1c, 0x0a, 0x8b, 0x79, 0x73, 0x5a, 0x58, 0x19, 0xa6,
+	0x9b, 0x17, 0x0a, 0x26, 0x57, 0x63, 0x01, 0x3d, 0x83, 0xf3, 0xdb, 0x12, 0xa1, 0xa3, 0xe6, 0x8d,
+	0xde, 0xcd, 0x1a, 0x99, 0x31, 0x8c, 0x66, 0xaf, 0x56, 0xdc, 0xff, 0x8d, 0x05, 0xf4, 0xb3, 0x06,
+	0x17, 0xb6, 0x09, 0xcf, 0xf7, 0x42, 0x74, 0xa3, 0xd8, 0xc8, 0x8c, 0x9e, 0xd9, 0x7c, 0x32, 0x6f,
+	0xcd, 0x66, 0xd5, 0x1a, 0x0b, 0x68, 0x5f, 0x5e, 0x3b, 0xad, 0x3d, 0x74, 0xa5, 0xb0, 0xc8, 0x92,
+	0xe8, 0xb5, 0x66, 0x1d, 0xc7, 0x57, 0xfd, 0xa4, 0xfb, 0xe7, 0xab, 0x96, 0xf6, 0xd7, 0xab, 0x96,
+	0xf6, 0xf7, 0xab, 0x96, 0xf6, 0xd5, 0xad, 0xff, 0xf8, 0x70, 0xa7, 0x7c, 0x63, 0xc4, 0x8c, 0xda,
+	0x43, 0x4a, 0x5c, 0x7e, 0xb8, 0x24, 0x3f, 0xd3, 0xdd, 0xfa, 0x37, 0x00, 0x00, 0xff, 0xff, 0x98,
+	0x26, 0x41, 0x78, 0x82, 0x14, 0x00, 0x00,
 }
 
 // Reference imports to suppress errors if they are not otherwise used.
@@ -2350,6 +2358,18 @@ func (m *RepoServerAppDetailsQuery) MarshalToSizedBuffer(dAtA []byte) (int, erro
 		i -= len(m.XXX_unrecognized)
 		copy(dAtA[i:], m.XXX_unrecognized)
 	}
+	if m.HelmOptions != nil {
+		{
+			size, err := m.HelmOptions.MarshalToSizedBuffer(dAtA[:i])
+			if err != nil {
+				return 0, err
+			}
+			i -= size
+			i = encodeVarintRepository(dAtA, i, uint64(size))
+		}
+		i--
+		dAtA[i] = 0x52
+	}
 	if len(m.TrackingMethod) > 0 {
 		i -= len(m.TrackingMethod)
 		copy(dAtA[i:], m.TrackingMethod)
@@ -3290,6 +3310,10 @@ func (m *RepoServerAppDetailsQuery) Size() (n int) {
 	if l > 0 {
 		n += 1 + l + sovRepository(uint64(l))
 	}
+	if m.HelmOptions != nil {
+		l = m.HelmOptions.Size()
+		n += 1 + l + sovRepository(uint64(l))
+	}
 	if m.XXX_unrecognized != nil {
 		n += len(m.XXX_unrecognized)
 	}
@@ -5316,6 +5340,42 @@ func (m *RepoServerAppDetailsQuery) Unmarshal(dAtA []byte) error {
 			}
 			m.TrackingMethod = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
+		case 10:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field HelmOptions", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowRepository
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= int(b&0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthRepository
+			}
+			postIndex := iNdEx + msglen
+			if postIndex < 0 {
+				return ErrInvalidLengthRepository
+			}
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.HelmOptions == nil {
+				m.HelmOptions = &v1alpha1.HelmOptions{}
+			}
+			if err := m.HelmOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipRepository(dAtA[iNdEx:])
diff --git a/reposerver/repository/repository.go b/reposerver/repository/repository.go
index 5945449dfeb8f..423edd0e5242d 100644
--- a/reposerver/repository/repository.go
+++ b/reposerver/repository/repository.go
@@ -26,6 +26,7 @@ import (
 	jsonpatch "github.com/evanphx/json-patch"
 	"github.com/ghodss/yaml"
 	"github.com/google/go-jsonnet"
+	"github.com/google/uuid"
 	log "github.com/sirupsen/logrus"
 	"golang.org/x/sync/semaphore"
 	"google.golang.org/grpc/codes"
@@ -49,6 +50,7 @@ import (
 	"github.com/argoproj/argo-cd/v2/util/gpg"
 	"github.com/argoproj/argo-cd/v2/util/helm"
 	"github.com/argoproj/argo-cd/v2/util/io"
+	pathutil "github.com/argoproj/argo-cd/v2/util/io/path"
 	"github.com/argoproj/argo-cd/v2/util/ksonnet"
 	"github.com/argoproj/argo-cd/v2/util/kustomize"
 	"github.com/argoproj/argo-cd/v2/util/text"
@@ -552,153 +554,6 @@ func runHelmBuild(appPath string, h helm.Helm) error {
 	return ioutil.WriteFile(markerFile, []byte("marker"), 0644)
 }
 
-// resolveSymbolicLinkRecursive resolves the symlink path recursively to its
-// canonical path on the file system, with a maximum nesting level of maxDepth.
-// If path is not a symlink, returns the verbatim copy of path and err of nil.
-func resolveSymbolicLinkRecursive(path string, maxDepth int) (string, error) {
-	resolved, err := os.Readlink(path)
-	if err != nil {
-		// path is not a symbolic link
-		_, ok := err.(*os.PathError)
-		if ok {
-			return path, nil
-		}
-		// Other error has occured
-		return "", err
-	}
-
-	if maxDepth == 0 {
-		return "", fmt.Errorf("maximum nesting level reached")
-	}
-
-	// If we resolved to a relative symlink, make sure we use the absolute
-	// path for further resolving
-	if !strings.HasPrefix(resolved, "/") {
-		basePath := filepath.Dir(path)
-		resolved = filepath.Join(basePath, resolved)
-	}
-
-	return resolveSymbolicLinkRecursive(resolved, maxDepth-1)
-}
-
-// isURLSchemeAllowed returns true if the protocol scheme is in the list of
-// allowed URL schemes.
-func isURLSchemeAllowed(scheme string, allowed []string) bool {
-	isAllowed := false
-	if len(allowed) > 0 {
-		for _, s := range allowed {
-			if strings.EqualFold(scheme, s) {
-				isAllowed = true
-				break
-			}
-		}
-	}
-
-	// Empty scheme means local file
-	return isAllowed && scheme != ""
-}
-
-// resolveHelmValueFilePath will inspect and resolve a path to a Helm value
-// file, and make sure that its final path is within the boundaries of the
-// path specified in repoRoot.
-//
-// appPath is the path we're operating in, e.g. where a Helm chart was unpacked
-// to. repoRoot is the path to the root of the repository.
-//
-// If either appPath or repoRoot is relative, it will be treated as relative
-// to the current working directory.
-//
-// valueFile is the path to a value file, relative to appPath. If valueFile is
-// specified as an absolute path (i.e. leading slash), it will be treated as
-// relative to the repoRoot. In case valueFile is a symlink in the extracted
-// chart, it will be resolved recursively and the decision of whether it is in
-// the boundary of repoRoot will be made using the final resolved path.
-// valueFile can also be a remote URL with a protocol scheme as prefix,
-// in which case the scheme must be included in the list of allowed schemes
-// specified by allowedURLSchemes.
-//
-// Will return an error if either valueFile is outside the boundaries of the
-// repoRoot, valueFile is an URL with a forbidden protocol scheme or if
-// valueFile is a recursive symlink nested too deep. May return errors for
-// other reasons as well.
-//
-// resolvedPath will hold the absolute, resolved path for valueFile on success
-// or set to the empty string on failure.
-//
-// isRemote will be set to true if valueFile is an URL using an allowed
-// protocol scheme, or to false if it resolved to a local file.
-func resolveHelmValueFilePath(appPath, repoRoot, valueFile string, allowedURLSchemes []string) (resolvedPath string, isRemote bool, err error) {
-
-	// We do not provide the path in the error message, because it will be
-	// returned to the user and could be used for information gathering.
-	// Instead, we log the concrete error details.
-	resolveFailure := func(path string, err error) error {
-		log.Errorf("failed to resolve path '%s': %v", path, err)
-		return fmt.Errorf("internal error: failed to resolve path. Check logs for more details")
-	}
-
-	// A value file can be specified as an URL to a remote resource.
-	// We only allow certain URL schemes for remote value files.
-	url, err := url.Parse(valueFile)
-	if err == nil {
-		// If scheme is empty, it means we parsed a path only
-		if url.Scheme != "" {
-			if isURLSchemeAllowed(url.Scheme, allowedURLSchemes) {
-				return valueFile, true, nil
-			} else {
-				return "", false, fmt.Errorf("the URL scheme '%s' is not allowed", url.Scheme)
-			}
-		}
-	}
-
-	// Ensure that our repository root is absolute
-	absRepoPath, err := filepath.Abs(repoRoot)
-	if err != nil {
-		return "", false, resolveFailure(repoRoot, err)
-	}
-
-	// If the path to the file is relative, join it with the current working directory (appPath)
-	// Otherwise, join it with the repository's root
-	path := valueFile
-	if !filepath.IsAbs(path) {
-		absWorkDir, err := filepath.Abs(appPath)
-		if err != nil {
-			return "", false, resolveFailure(repoRoot, err)
-		}
-		path = filepath.Join(absWorkDir, path)
-	} else {
-		path = filepath.Join(absRepoPath, path)
-	}
-
-	// Ensure any symbolic link is resolved before we
-	delinkedPath, err := resolveSymbolicLinkRecursive(path, 10)
-	if err != nil {
-		return "", false, resolveFailure(path, err)
-	}
-	path = delinkedPath
-
-	// Resolve the joined path to an absolute path
-	path, err = filepath.Abs(path)
-	if err != nil {
-		return "", false, resolveFailure(path, err)
-	}
-
-	// Ensure our root path has a trailing slash, otherwise the following check
-	// would return true if root is /foo and path would be /foo2
-	requiredRootPath := absRepoPath
-	if !strings.HasSuffix(requiredRootPath, "/") {
-		requiredRootPath += "/"
-	}
-
-	// Make sure that the resolved path to values file is within the repository's root path
-	if !strings.HasPrefix(path, requiredRootPath) {
-		return "", false, fmt.Errorf("value file '%s' resolved to outside repository root", valueFile)
-	}
-
-	return path, false, nil
-
-}
-
 func helmTemplate(appPath string, repoRoot string, env *v1alpha1.Env, q *apiclient.ManifestRequest, isLocal bool) ([]*unstructured.Unstructured, error) {
 	concurrencyAllowed := isConcurrencyAllowed(appPath)
 	if !concurrencyAllowed {
@@ -713,7 +568,7 @@ func helmTemplate(appPath string, repoRoot string, env *v1alpha1.Env, q *apiclie
 		APIVersions: q.ApiVersions,
 		Set:         map[string]string{},
 		SetString:   map[string]string{},
-		SetFile:     map[string]string{},
+		SetFile:     map[string]pathutil.ResolvedFilePath{},
 	}
 
 	appHelm := q.ApplicationSource.Helm
@@ -730,12 +585,7 @@ func helmTemplate(appPath string, repoRoot string, env *v1alpha1.Env, q *apiclie
 		for _, val := range appHelm.ValueFiles {
 
 			// This will resolve val to an absolute path (or an URL)
-			var protocols []string
-			if q.HelmOptions != nil {
-				protocols = q.HelmOptions.ValuesFileSchemes
-			}
-
-			path, _, err := resolveHelmValueFilePath(appPath, repoRoot, val, protocols)
+			path, _, err := pathutil.ResolveFilePath(appPath, repoRoot, val, q.GetValuesFileSchemes())
 			if err != nil {
 				return nil, err
 			}
@@ -744,18 +594,17 @@ func helmTemplate(appPath string, repoRoot string, env *v1alpha1.Env, q *apiclie
 		}
 
 		if appHelm.Values != "" {
-			file, err := ioutil.TempFile("", "values-*.yaml")
+			rand, err := uuid.NewRandom()
 			if err != nil {
 				return nil, err
 			}
-			p := file.Name()
+			p := path.Join(os.TempDir(), rand.String())
 			defer func() { _ = os.RemoveAll(p) }()
 			err = ioutil.WriteFile(p, []byte(appHelm.Values), 0644)
 			if err != nil {
 				return nil, err
 			}
-			defer file.Close()
-			templateOpts.Values = append(templateOpts.Values, p)
+			templateOpts.Values = append(templateOpts.Values, pathutil.ResolvedFilePath(p))
 		}
 
 		for _, p := range appHelm.Parameters {
@@ -766,7 +615,11 @@ func helmTemplate(appPath string, repoRoot string, env *v1alpha1.Env, q *apiclie
 			}
 		}
 		for _, p := range appHelm.FileParameters {
-			templateOpts.SetFile[p.Name] = p.Path
+			resolvedPath, _, err := pathutil.ResolveFilePath(appPath, repoRoot, env.Envsubst(p.Path), q.GetValuesFileSchemes())
+			if err != nil {
+				return nil, err
+			}
+			templateOpts.SetFile[p.Name] = resolvedPath
 		}
 		passCredentials = appHelm.PassCredentials
 	}
@@ -779,9 +632,6 @@ func helmTemplate(appPath string, repoRoot string, env *v1alpha1.Env, q *apiclie
 	for i, j := range templateOpts.SetString {
 		templateOpts.SetString[i] = env.Envsubst(j)
 	}
-	for i, j := range templateOpts.SetFile {
-		templateOpts.SetFile[i] = env.Envsubst(j)
-	}
 
 	repos, err := getHelmDependencyRepos(appPath)
 	if err != nil {
@@ -1221,11 +1071,11 @@ func makeJsonnetVm(appPath string, repoRoot string, sourceJsonnet v1alpha1.Appli
 	// Jsonnet Imports relative to the repository path
 	jpaths := []string{appPath}
 	for _, p := range sourceJsonnet.Libs {
-		jpath := path.Join(repoRoot, p)
-		if !strings.HasPrefix(jpath, repoRoot) {
-			return nil, status.Errorf(codes.FailedPrecondition, "%s: referenced library points outside the repository", p)
+		jpath, _, err := pathutil.ResolveFilePath(appPath, repoRoot, p, nil)
+		if err != nil {
+			return nil, err
 		}
-		jpaths = append(jpaths, jpath)
+		jpaths = append(jpaths, string(jpath))
 	}
 
 	vm.Importer(&jsonnet.FileImporter{
@@ -1393,7 +1243,7 @@ func (s *Service) GetAppDetails(ctx context.Context, q *apiclient.RepoServerAppD
 				return err
 			}
 		case v1alpha1.ApplicationSourceTypeHelm:
-			if err := populateHelmAppDetails(res, ctx.appPath, q); err != nil {
+			if err := populateHelmAppDetails(res, ctx.appPath, repoRoot, q); err != nil {
 				return err
 			}
 		case v1alpha1.ApplicationSourceTypeKustomize:
@@ -1455,7 +1305,7 @@ func populateKsonnetAppDetails(res *apiclient.RepoAppDetailsResponse, appPath st
 	return nil
 }
 
-func populateHelmAppDetails(res *apiclient.RepoAppDetailsResponse, appPath string, q *apiclient.RepoServerAppDetailsQuery) error {
+func populateHelmAppDetails(res *apiclient.RepoAppDetailsResponse, appPath string, repoRoot string, q *apiclient.RepoServerAppDetailsQuery) error {
 	var selectedValueFiles []string
 
 	if q.Source.Helm != nil {
@@ -1489,7 +1339,16 @@ func populateHelmAppDetails(res *apiclient.RepoAppDetailsResponse, appPath strin
 	if err := loadFileIntoIfExists(filepath.Join(appPath, "values.yaml"), &res.Helm.Values); err != nil {
 		return err
 	}
-	params, err := h.GetParameters(selectedValueFiles)
+	var resolvedSelectedValueFiles []pathutil.ResolvedFilePath
+	// drop not allowed values files
+	for _, file := range selectedValueFiles {
+		if resolvedFile, _, err := pathutil.ResolveFilePath(appPath, repoRoot, file, q.GetValuesFileSchemes()); err == nil {
+			resolvedSelectedValueFiles = append(resolvedSelectedValueFiles, resolvedFile)
+		} else {
+			log.Debugf("Values file %s is not allowed: %v", file, err)
+		}
+	}
+	params, err := h.GetParameters(resolvedSelectedValueFiles)
 	if err != nil {
 		return err
 	}
diff --git a/reposerver/repository/repository.proto b/reposerver/repository/repository.proto
index 0f33f957f024c..da8b5f0888a8f 100644
--- a/reposerver/repository/repository.proto
+++ b/reposerver/repository/repository.proto
@@ -85,6 +85,7 @@ message RepoServerAppDetailsQuery {
     bool noCache = 6;
     bool noRevisionCache = 7;
     string trackingMethod = 8;
+    github.com.argoproj.argo_cd.v2.pkg.apis.application.v1alpha1.HelmOptions helmOptions = 10;
 }
 
 // RepoAppDetailsResponse application details
diff --git a/reposerver/repository/repository_test.go b/reposerver/repository/repository_test.go
index 2d7591305430b..091264525d418 100644
--- a/reposerver/repository/repository_test.go
+++ b/reposerver/repository/repository_test.go
@@ -250,7 +250,7 @@ func TestGenerateJsonnetManifestInDir(t *testing.T) {
 				Jsonnet: argoappv1.ApplicationSourceJsonnet{
 					ExtVars: []argoappv1.JsonnetVar{{Name: "extVarString", Value: "extVarString"}, {Name: "extVarCode", Value: "\"extVarCode\"", Code: true}},
 					TLAs:    []argoappv1.JsonnetVar{{Name: "tlaString", Value: "tlaString"}, {Name: "tlaCode", Value: "\"tlaCode\"", Code: true}},
-					Libs:    []string{"testdata/jsonnet/vendor"},
+					Libs:    []string{"./vendor"},
 				},
 			},
 		},
@@ -260,6 +260,25 @@ func TestGenerateJsonnetManifestInDir(t *testing.T) {
 	assert.Equal(t, 2, len(res1.Manifests))
 }
 
+func TestGenerateJsonnetLibOutside(t *testing.T) {
+	service := newService(".")
+
+	q := apiclient.ManifestRequest{
+		Repo: &argoappv1.Repository{},
+		ApplicationSource: &argoappv1.ApplicationSource{
+			Path: "./testdata/jsonnet",
+			Directory: &argoappv1.ApplicationSourceDirectory{
+				Jsonnet: argoappv1.ApplicationSourceJsonnet{
+					Libs: []string{"../../../testdata/jsonnet/vendor"},
+				},
+			},
+		},
+	}
+	_, err := service.GenerateManifest(context.Background(), &q)
+	require.Error(t, err)
+	require.Contains(t, err.Error(), "value file '../../../testdata/jsonnet/vendor' resolved to outside repository root")
+}
+
 func TestGenerateKsonnetManifest(t *testing.T) {
 	service := newService("../..")
 
@@ -883,9 +902,7 @@ func TestGenerateHelmWithValuesDirectoryTraversalOutsideRepo(t *testing.T) {
 	})
 }
 
-// The requested file parameter (`/tmp/external-secret.txt`) is outside the app path
-// (`./util/helm/testdata/redis`), and outside the repo directory. It is used as a means
-// of providing direct content to a helm chart via a specific key.
+// File parameter should not allow traversal outside of the repository root
 func TestGenerateHelmWithAbsoluteFileParameter(t *testing.T) {
 	service := newService("../..")
 
@@ -907,16 +924,14 @@ func TestGenerateHelmWithAbsoluteFileParameter(t *testing.T) {
 			Helm: &argoappv1.ApplicationSourceHelm{
 				ValueFiles: []string{"values-production.yaml"},
 				Values:     `cluster: {slaveCount: 2}`,
-				FileParameters: []argoappv1.HelmFileParameter{
-					argoappv1.HelmFileParameter{
-						Name: "passwordContent",
-						Path: externalSecretPath,
-					},
-				},
+				FileParameters: []argoappv1.HelmFileParameter{{
+					Name: "passwordContent",
+					Path: externalSecretPath,
+				}},
 			},
 		},
 	})
-	assert.NoError(t, err)
+	assert.Error(t, err)
 }
 
 // The requested file parameter (`../external/external-secret.txt`) is outside the app path
@@ -1664,174 +1679,3 @@ func Test_getHelmDependencyRepos(t *testing.T) {
 	assert.Equal(t, repos[0].Repo, repo1)
 	assert.Equal(t, repos[1].Repo, repo2)
 }
-
-func Test_resolveSymlinkRecursive(t *testing.T) {
-	testsDir, err := filepath.Abs("./testdata/symlinks")
-	if err != nil {
-		panic(err)
-	}
-	t.Run("Resolve non-symlink", func(t *testing.T) {
-		r, err := resolveSymbolicLinkRecursive(testsDir+"/foo", 2)
-		assert.NoError(t, err)
-		assert.Equal(t, testsDir+"/foo", r)
-	})
-	t.Run("Successfully resolve symlink", func(t *testing.T) {
-		r, err := resolveSymbolicLinkRecursive(testsDir+"/bar", 2)
-		assert.NoError(t, err)
-		assert.Equal(t, testsDir+"/foo", r)
-	})
-	t.Run("Do not allow symlink at all", func(t *testing.T) {
-		r, err := resolveSymbolicLinkRecursive(testsDir+"/bar", 0)
-		assert.Error(t, err)
-		assert.Equal(t, "", r)
-	})
-	t.Run("Error because too nested symlink", func(t *testing.T) {
-		r, err := resolveSymbolicLinkRecursive(testsDir+"/bam", 2)
-		assert.Error(t, err)
-		assert.Equal(t, "", r)
-	})
-	t.Run("No such file or directory", func(t *testing.T) {
-		r, err := resolveSymbolicLinkRecursive(testsDir+"/foobar", 2)
-		assert.NoError(t, err)
-		assert.Equal(t, testsDir+"/foobar", r)
-	})
-}
-
-func Test_isURLSchemeAllowed(t *testing.T) {
-	type testdata struct {
-		name     string
-		scheme   string
-		allowed  []string
-		expected bool
-	}
-	var tts []testdata = []testdata{
-		{
-			name:     "Allowed scheme matches",
-			scheme:   "http",
-			allowed:  []string{"http", "https"},
-			expected: true,
-		},
-		{
-			name:     "Allowed scheme matches only partially",
-			scheme:   "http",
-			allowed:  []string{"https"},
-			expected: false,
-		},
-		{
-			name:     "Scheme is not allowed",
-			scheme:   "file",
-			allowed:  []string{"http", "https"},
-			expected: false,
-		},
-		{
-			name:     "Empty scheme with valid allowances is forbidden",
-			scheme:   "",
-			allowed:  []string{"http", "https"},
-			expected: false,
-		},
-		{
-			name:     "Empty scheme with empty allowances is forbidden",
-			scheme:   "",
-			allowed:  []string{},
-			expected: false,
-		},
-		{
-			name:     "Some scheme with empty allowances is forbidden",
-			scheme:   "file",
-			allowed:  []string{},
-			expected: false,
-		},
-	}
-	for _, tt := range tts {
-		t.Run(tt.name, func(t *testing.T) {
-			r := isURLSchemeAllowed(tt.scheme, tt.allowed)
-			assert.Equal(t, tt.expected, r)
-		})
-	}
-}
-
-var allowedHelmRemoteProtocols = []string{"http", "https"}
-
-func Test_resolveHelmValueFilePath(t *testing.T) {
-	t.Run("Resolve normal relative path into absolute path", func(t *testing.T) {
-		p, remote, err := resolveHelmValueFilePath("/foo/bar", "/foo", "baz/bim.yaml", allowedHelmRemoteProtocols)
-		assert.NoError(t, err)
-		assert.False(t, remote)
-		assert.Equal(t, "/foo/bar/baz/bim.yaml", p)
-	})
-	t.Run("Resolve normal relative path into absolute path", func(t *testing.T) {
-		p, remote, err := resolveHelmValueFilePath("/foo/bar", "/foo", "baz/../../bim.yaml", allowedHelmRemoteProtocols)
-		assert.NoError(t, err)
-		assert.False(t, remote)
-		assert.Equal(t, "/foo/bim.yaml", p)
-	})
-	t.Run("Error on path resolving outside repository root", func(t *testing.T) {
-		p, remote, err := resolveHelmValueFilePath("/foo/bar", "/foo", "baz/../../../bim.yaml", allowedHelmRemoteProtocols)
-		assert.Error(t, err)
-		assert.Contains(t, err.Error(), "outside repository root")
-		assert.False(t, remote)
-		assert.Equal(t, "", p)
-	})
-	t.Run("Return verbatim URL", func(t *testing.T) {
-		url := "https://some.where/foo,yaml"
-		p, remote, err := resolveHelmValueFilePath("/foo/bar", "/foo", url, allowedHelmRemoteProtocols)
-		assert.NoError(t, err)
-		assert.True(t, remote)
-		assert.Equal(t, url, p)
-	})
-	t.Run("URL scheme not allowed", func(t *testing.T) {
-		url := "file:///some.where/foo,yaml"
-		p, remote, err := resolveHelmValueFilePath("/foo/bar", "/foo", url, allowedHelmRemoteProtocols)
-		assert.Error(t, err)
-		assert.False(t, remote)
-		assert.Equal(t, "", p)
-	})
-	t.Run("Implicit URL by absolute path", func(t *testing.T) {
-		p, remote, err := resolveHelmValueFilePath("/foo/bar", "/foo", "/baz.yaml", allowedHelmRemoteProtocols)
-		assert.NoError(t, err)
-		assert.False(t, remote)
-		assert.Equal(t, "/foo/baz.yaml", p)
-	})
-	t.Run("Relative app path", func(t *testing.T) {
-		p, remote, err := resolveHelmValueFilePath(".", "/foo", "/baz.yaml", allowedHelmRemoteProtocols)
-		assert.NoError(t, err)
-		assert.False(t, remote)
-		assert.Equal(t, "/foo/baz.yaml", p)
-	})
-	t.Run("Relative repo path", func(t *testing.T) {
-		c, err := os.Getwd()
-		require.NoError(t, err)
-		p, remote, err := resolveHelmValueFilePath(".", ".", "baz.yaml", allowedHelmRemoteProtocols)
-		assert.NoError(t, err)
-		assert.False(t, remote)
-		assert.Equal(t, c+"/baz.yaml", p)
-	})
-	t.Run("Overlapping root prefix without trailing slash", func(t *testing.T) {
-		p, remote, err := resolveHelmValueFilePath(".", "/foo", "../foo2/baz.yaml", allowedHelmRemoteProtocols)
-		assert.Error(t, err)
-		assert.Contains(t, err.Error(), "outside repository root")
-		assert.False(t, remote)
-		assert.Equal(t, "", p)
-	})
-	t.Run("Overlapping root prefix with trailing slash", func(t *testing.T) {
-		p, remote, err := resolveHelmValueFilePath(".", "/foo/", "../foo2/baz.yaml", allowedHelmRemoteProtocols)
-		assert.Error(t, err)
-		assert.Contains(t, err.Error(), "outside repository root")
-		assert.False(t, remote)
-		assert.Equal(t, "", p)
-	})
-	t.Run("Garbage input as values file", func(t *testing.T) {
-		p, remote, err := resolveHelmValueFilePath(".", "/foo/", "kfdj\\ks&&&321209.,---e32908923%$ยง!\"", allowedHelmRemoteProtocols)
-		assert.Error(t, err)
-		assert.Contains(t, err.Error(), "outside repository root")
-		assert.False(t, remote)
-		assert.Equal(t, "", p)
-	})
-	t.Run("NUL-byte path input as values file", func(t *testing.T) {
-		p, remote, err := resolveHelmValueFilePath(".", "/foo/", "\000", allowedHelmRemoteProtocols)
-		assert.Error(t, err)
-		assert.Contains(t, err.Error(), "outside repository root")
-		assert.False(t, remote)
-		assert.Equal(t, "", p)
-	})
-}
diff --git a/server/application/application.go b/server/application/application.go
index d197de045dcd0..d2c1f6a265a99 100644
--- a/server/application/application.go
+++ b/server/application/application.go
@@ -425,6 +425,7 @@ func (s *Server) Get(ctx context.Context, q *application.ApplicationQuery) (*app
 				Repos:            helmRepos,
 				NoCache:          true,
 				TrackingMethod:   string(argoutil.GetTrackingMethod(s.settingsMgr)),
+				HelmOptions:      helmOptions,
 			})
 			return err
 		}); err != nil {
diff --git a/server/repository/repository.go b/server/repository/repository.go
index 8340f81c3aecd..15a6af7484c41 100644
--- a/server/repository/repository.go
+++ b/server/repository/repository.go
@@ -332,11 +332,16 @@ func (s *Server) GetAppDetails(ctx context.Context, q *repositorypkg.RepoAppDeta
 	if err != nil {
 		return nil, err
 	}
+	helmOptions, err := s.settings.GetHelmSettings()
+	if err != nil {
+		return nil, err
+	}
 	return repoClient.GetAppDetails(ctx, &apiclient.RepoServerAppDetailsQuery{
 		Repo:             repo,
 		Source:           q.Source,
 		Repos:            helmRepos,
 		KustomizeOptions: kustomizeOptions,
+		HelmOptions:      helmOptions,
 		AppName:          q.AppName,
 	})
 }
diff --git a/util/argo/argo.go b/util/argo/argo.go
index d6ff83c438d18..40d33a07855b3 100644
--- a/util/argo/argo.go
+++ b/util/argo/argo.go
@@ -252,6 +252,7 @@ func ValidateRepo(
 		// don't use case during application change to make sure to fetch latest git/helm revisions
 		NoRevisionCache: true,
 		TrackingMethod:  string(GetTrackingMethod(settingsMgr)),
+		HelmOptions:     helmOptions,
 	})
 	if err != nil {
 		conditions = append(conditions, argoappv1.ApplicationCondition{
diff --git a/util/argo/argo_test.go b/util/argo/argo_test.go
index ef6869554f99f..d5222f53248aa 100644
--- a/util/argo/argo_test.go
+++ b/util/argo/argo_test.go
@@ -268,6 +268,7 @@ func TestValidateRepo(t *testing.T) {
 		Source:           &app.Spec.Source,
 		Repos:            helmRepos,
 		KustomizeOptions: kustomizeOptions,
+		HelmOptions:      &argoappv1.HelmOptions{ValuesFileSchemes: []string{"https", "http"}},
 		NoRevisionCache:  true,
 	}).Return(&apiclient.RepoAppDetailsResponse{}, nil)
 
diff --git a/util/helm/cmd.go b/util/helm/cmd.go
index 2b0f0e2fe02b4..1ba8aa6f2f839 100644
--- a/util/helm/cmd.go
+++ b/util/helm/cmd.go
@@ -11,6 +11,7 @@ import (
 
 	executil "github.com/argoproj/argo-cd/v2/util/exec"
 	"github.com/argoproj/argo-cd/v2/util/io"
+	pathutil "github.com/argoproj/argo-cd/v2/util/io/path"
 	"github.com/argoproj/argo-cd/v2/util/proxy"
 )
 
@@ -286,8 +287,8 @@ type TemplateOpts struct {
 	APIVersions []string
 	Set         map[string]string
 	SetString   map[string]string
-	SetFile     map[string]string
-	Values      []string
+	SetFile     map[string]pathutil.ResolvedFilePath
+	Values      []pathutil.ResolvedFilePath
 }
 
 var (
@@ -322,10 +323,10 @@ func (c *Cmd) template(chartPath string, opts *TemplateOpts) (string, error) {
 		args = append(args, "--set-string", key+"="+cleanSetParameters(val))
 	}
 	for key, val := range opts.SetFile {
-		args = append(args, "--set-file", key+"="+cleanSetParameters(val))
+		args = append(args, "--set-file", key+"="+cleanSetParameters(string(val)))
 	}
 	for _, val := range opts.Values {
-		args = append(args, "--values", val)
+		args = append(args, "--values", string(val))
 	}
 	for _, v := range opts.APIVersions {
 		args = append(args, "--api-versions", v)
diff --git a/util/helm/helm.go b/util/helm/helm.go
index 1b35f3383124d..0c3a3a184e8de 100644
--- a/util/helm/helm.go
+++ b/util/helm/helm.go
@@ -13,6 +13,7 @@ import (
 
 	"github.com/argoproj/argo-cd/v2/util/config"
 	executil "github.com/argoproj/argo-cd/v2/util/exec"
+	pathutil "github.com/argoproj/argo-cd/v2/util/io/path"
 )
 
 type HelmRepository struct {
@@ -27,7 +28,7 @@ type Helm interface {
 	// Template returns a list of unstructured objects from a `helm template` command
 	Template(opts *TemplateOpts) (string, error)
 	// GetParameters returns a list of chart parameters taking into account values in provided YAML files.
-	GetParameters(valuesFiles []string) (map[string]string, error)
+	GetParameters(valuesFiles []pathutil.ResolvedFilePath) (map[string]string, error)
 	// DependencyBuild runs `helm dependency build` to download a chart's dependencies
 	DependencyBuild() error
 	// Init runs `helm init --client-only`
@@ -129,13 +130,14 @@ func Version(shortForm bool) (string, error) {
 	return strings.TrimSpace(version), nil
 }
 
-func (h *helm) GetParameters(valuesFiles []string) (map[string]string, error) {
+func (h *helm) GetParameters(valuesFiles []pathutil.ResolvedFilePath) (map[string]string, error) {
 	out, err := h.cmd.inspectValues(".")
 	if err != nil {
 		return nil, err
 	}
 	values := []string{out}
-	for _, file := range valuesFiles {
+	for i := range valuesFiles {
+		file := string(valuesFiles[i])
 		var fileValues []byte
 		parsedURL, err := url.ParseRequestURI(file)
 		if err == nil && (parsedURL.Scheme == "http" || parsedURL.Scheme == "https") {
diff --git a/util/helm/helm_test.go b/util/helm/helm_test.go
index c2dfc12519707..6daf6dc21e59d 100644
--- a/util/helm/helm_test.go
+++ b/util/helm/helm_test.go
@@ -5,8 +5,9 @@ import (
 	"os"
 	"testing"
 
-	"github.com/argoproj/gitops-engine/pkg/utils/kube"
+	"github.com/argoproj/argo-cd/v2/util/io/path"
 
+	"github.com/argoproj/gitops-engine/pkg/utils/kube"
 	"github.com/stretchr/testify/assert"
 	appsv1 "k8s.io/api/apps/v1"
 	apiv1 "k8s.io/api/core/v1"
@@ -56,7 +57,7 @@ func TestHelmTemplateValues(t *testing.T) {
 	assert.NoError(t, err)
 	opts := TemplateOpts{
 		Name:   "test",
-		Values: []string{"values-production.yaml"},
+		Values: []path.ResolvedFilePath{"values-production.yaml"},
 	}
 	objs, err := template(h, &opts)
 	assert.Nil(t, err)
@@ -75,7 +76,7 @@ func TestHelmTemplateValues(t *testing.T) {
 func TestHelmGetParams(t *testing.T) {
 	h, err := NewHelmApp("./testdata/redis", nil, false, "", "", false)
 	assert.NoError(t, err)
-	params, err := h.GetParameters([]string{})
+	params, err := h.GetParameters(nil)
 	assert.Nil(t, err)
 
 	slaveCountParam := params["cluster.slaveCount"]
@@ -85,7 +86,7 @@ func TestHelmGetParams(t *testing.T) {
 func TestHelmGetParamsValueFiles(t *testing.T) {
 	h, err := NewHelmApp("./testdata/redis", nil, false, "", "", false)
 	assert.NoError(t, err)
-	params, err := h.GetParameters([]string{"values-production.yaml"})
+	params, err := h.GetParameters([]path.ResolvedFilePath{"values-production.yaml"})
 	assert.Nil(t, err)
 
 	slaveCountParam := params["cluster.slaveCount"]
@@ -95,7 +96,7 @@ func TestHelmGetParamsValueFiles(t *testing.T) {
 func TestHelmGetParamsValueFilesThatExist(t *testing.T) {
 	h, err := NewHelmApp("./testdata/redis", nil, false, "", "", false)
 	assert.NoError(t, err)
-	params, err := h.GetParameters([]string{"values-missing.yaml", "values-production.yaml"})
+	params, err := h.GetParameters([]path.ResolvedFilePath{"values-missing.yaml", "values-production.yaml"})
 	assert.Nil(t, err)
 
 	slaveCountParam := params["cluster.slaveCount"]
diff --git a/util/io/path/resolved.go b/util/io/path/resolved.go
new file mode 100644
index 0000000000000..0343a379f0494
--- /dev/null
+++ b/util/io/path/resolved.go
@@ -0,0 +1,158 @@
+package path
+
+import (
+	"fmt"
+	"net/url"
+	"os"
+	"path/filepath"
+	"strings"
+
+	log "github.com/sirupsen/logrus"
+)
+
+// ResolvedFilePath represents a resolved file path and intended to prevent unintentional use of not verified file path.
+type ResolvedFilePath string
+
+// resolveSymbolicLinkRecursive resolves the symlink path recursively to its
+// canonical path on the file system, with a maximum nesting level of maxDepth.
+// If path is not a symlink, returns the verbatim copy of path and err of nil.
+func resolveSymbolicLinkRecursive(path string, maxDepth int) (string, error) {
+	resolved, err := os.Readlink(path)
+	if err != nil {
+		// path is not a symbolic link
+		_, ok := err.(*os.PathError)
+		if ok {
+			return path, nil
+		}
+		// Other error has occured
+		return "", err
+	}
+
+	if maxDepth == 0 {
+		return "", fmt.Errorf("maximum nesting level reached")
+	}
+
+	// If we resolved to a relative symlink, make sure we use the absolute
+	// path for further resolving
+	if !strings.HasPrefix(resolved, "/") {
+		basePath := filepath.Dir(path)
+		resolved = filepath.Join(basePath, resolved)
+	}
+
+	return resolveSymbolicLinkRecursive(resolved, maxDepth-1)
+}
+
+// isURLSchemeAllowed returns true if the protocol scheme is in the list of
+// allowed URL schemes.
+func isURLSchemeAllowed(scheme string, allowed []string) bool {
+	isAllowed := false
+	if len(allowed) > 0 {
+		for _, s := range allowed {
+			if strings.EqualFold(scheme, s) {
+				isAllowed = true
+				break
+			}
+		}
+	}
+
+	// Empty scheme means local file
+	return isAllowed && scheme != ""
+}
+
+// ResolveFilePath will inspect and resolve given file, and make sure that its final path is within the boundaries of
+// the path specified in repoRoot.
+//
+// appPath is the path we're operating in, e.g. where a Helm chart was unpacked
+// to. repoRoot is the path to the root of the repository.
+//
+// If either appPath or repoRoot is relative, it will be treated as relative
+// to the current working directory.
+//
+// valueFile is the path to a value file, relative to appPath. If valueFile is
+// specified as an absolute path (i.e. leading slash), it will be treated as
+// relative to the repoRoot. In case valueFile is a symlink in the extracted
+// chart, it will be resolved recursively and the decision of whether it is in
+// the boundary of repoRoot will be made using the final resolved path.
+// valueFile can also be a remote URL with a protocol scheme as prefix,
+// in which case the scheme must be included in the list of allowed schemes
+// specified by allowedURLSchemes.
+//
+// Will return an error if either valueFile is outside the boundaries of the
+// repoRoot, valueFile is an URL with a forbidden protocol scheme or if
+// valueFile is a recursive symlink nested too deep. May return errors for
+// other reasons as well.
+//
+// resolvedPath will hold the absolute, resolved path for valueFile on success
+// or set to the empty string on failure.
+//
+// isRemote will be set to true if valueFile is an URL using an allowed
+// protocol scheme, or to false if it resolved to a local file.
+func ResolveFilePath(appPath, repoRoot, valueFile string, allowedURLSchemes []string) (resolvedPath ResolvedFilePath, isRemote bool, err error) {
+	// We do not provide the path in the error message, because it will be
+	// returned to the user and could be used for information gathering.
+	// Instead, we log the concrete error details.
+	resolveFailure := func(path string, err error) error {
+		log.Errorf("failed to resolve path '%s': %v", path, err)
+		return fmt.Errorf("internal error: failed to resolve path. Check logs for more details")
+	}
+
+	// A value file can be specified as an URL to a remote resource.
+	// We only allow certain URL schemes for remote value files.
+	url, err := url.Parse(valueFile)
+	if err == nil {
+		// If scheme is empty, it means we parsed a path only
+		if url.Scheme != "" {
+			if isURLSchemeAllowed(url.Scheme, allowedURLSchemes) {
+				return ResolvedFilePath(valueFile), true, nil
+			} else {
+				return "", false, fmt.Errorf("the URL scheme '%s' is not allowed", url.Scheme)
+			}
+		}
+	}
+
+	// Ensure that our repository root is absolute
+	absRepoPath, err := filepath.Abs(repoRoot)
+	if err != nil {
+		return "", false, resolveFailure(repoRoot, err)
+	}
+
+	// If the path to the file is relative, join it with the current working directory (appPath)
+	// Otherwise, join it with the repository's root
+	path := valueFile
+	if !filepath.IsAbs(path) {
+		absWorkDir, err := filepath.Abs(appPath)
+		if err != nil {
+			return "", false, resolveFailure(repoRoot, err)
+		}
+		path = filepath.Join(absWorkDir, path)
+	} else {
+		path = filepath.Join(absRepoPath, path)
+	}
+
+	// Ensure any symbolic link is resolved before we
+	delinkedPath, err := resolveSymbolicLinkRecursive(path, 10)
+	if err != nil {
+		return "", false, resolveFailure(path, err)
+	}
+	path = delinkedPath
+
+	// Resolve the joined path to an absolute path
+	path, err = filepath.Abs(path)
+	if err != nil {
+		return "", false, resolveFailure(path, err)
+	}
+
+	// Ensure our root path has a trailing slash, otherwise the following check
+	// would return true if root is /foo and path would be /foo2
+	requiredRootPath := absRepoPath
+	if !strings.HasSuffix(requiredRootPath, "/") {
+		requiredRootPath += "/"
+	}
+
+	// Make sure that the resolved path to values file is within the repository's root path
+	if !strings.HasPrefix(path, requiredRootPath) {
+		return "", false, fmt.Errorf("value file '%s' resolved to outside repository root", valueFile)
+	}
+
+	return ResolvedFilePath(path), false, nil
+}
diff --git a/util/io/path/resolved_test.go b/util/io/path/resolved_test.go
new file mode 100644
index 0000000000000..fc95833778e5b
--- /dev/null
+++ b/util/io/path/resolved_test.go
@@ -0,0 +1,181 @@
+package path
+
+import (
+	"os"
+	"path/filepath"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
+)
+
+func Test_resolveSymlinkRecursive(t *testing.T) {
+	testsDir, err := filepath.Abs("./testdata")
+	if err != nil {
+		panic(err)
+	}
+	t.Run("Resolve non-symlink", func(t *testing.T) {
+		r, err := resolveSymbolicLinkRecursive(testsDir+"/foo", 2)
+		assert.NoError(t, err)
+		assert.Equal(t, testsDir+"/foo", r)
+	})
+	t.Run("Successfully resolve symlink", func(t *testing.T) {
+		r, err := resolveSymbolicLinkRecursive(testsDir+"/bar", 2)
+		assert.NoError(t, err)
+		assert.Equal(t, testsDir+"/foo", r)
+	})
+	t.Run("Do not allow symlink at all", func(t *testing.T) {
+		r, err := resolveSymbolicLinkRecursive(testsDir+"/bar", 0)
+		assert.Error(t, err)
+		assert.Equal(t, "", r)
+	})
+	t.Run("Error because too nested symlink", func(t *testing.T) {
+		r, err := resolveSymbolicLinkRecursive(testsDir+"/bam", 2)
+		assert.Error(t, err)
+		assert.Equal(t, "", r)
+	})
+	t.Run("No such file or directory", func(t *testing.T) {
+		r, err := resolveSymbolicLinkRecursive(testsDir+"/foobar", 2)
+		assert.NoError(t, err)
+		assert.Equal(t, testsDir+"/foobar", r)
+	})
+}
+
+func Test_isURLSchemeAllowed(t *testing.T) {
+	type testdata struct {
+		name     string
+		scheme   string
+		allowed  []string
+		expected bool
+	}
+	var tts []testdata = []testdata{
+		{
+			name:     "Allowed scheme matches",
+			scheme:   "http",
+			allowed:  []string{"http", "https"},
+			expected: true,
+		},
+		{
+			name:     "Allowed scheme matches only partially",
+			scheme:   "http",
+			allowed:  []string{"https"},
+			expected: false,
+		},
+		{
+			name:     "Scheme is not allowed",
+			scheme:   "file",
+			allowed:  []string{"http", "https"},
+			expected: false,
+		},
+		{
+			name:     "Empty scheme with valid allowances is forbidden",
+			scheme:   "",
+			allowed:  []string{"http", "https"},
+			expected: false,
+		},
+		{
+			name:     "Empty scheme with empty allowances is forbidden",
+			scheme:   "",
+			allowed:  []string{},
+			expected: false,
+		},
+		{
+			name:     "Some scheme with empty allowances is forbidden",
+			scheme:   "file",
+			allowed:  []string{},
+			expected: false,
+		},
+	}
+	for _, tt := range tts {
+		t.Run(tt.name, func(t *testing.T) {
+			r := isURLSchemeAllowed(tt.scheme, tt.allowed)
+			assert.Equal(t, tt.expected, r)
+		})
+	}
+}
+
+var allowedRemoteProtocols = []string{"http", "https"}
+
+func Test_resolveFilePath(t *testing.T) {
+	t.Run("Resolve normal relative path into absolute path", func(t *testing.T) {
+		p, remote, err := ResolveFilePath("/foo/bar", "/foo", "baz/bim.yaml", allowedRemoteProtocols)
+		assert.NoError(t, err)
+		assert.False(t, remote)
+		assert.Equal(t, "/foo/bar/baz/bim.yaml", string(p))
+	})
+	t.Run("Resolve normal relative path into absolute path", func(t *testing.T) {
+		p, remote, err := ResolveFilePath("/foo/bar", "/foo", "baz/../../bim.yaml", allowedRemoteProtocols)
+		assert.NoError(t, err)
+		assert.False(t, remote)
+		assert.Equal(t, "/foo/bim.yaml", string(p))
+	})
+	t.Run("Error on path resolving outside repository root", func(t *testing.T) {
+		p, remote, err := ResolveFilePath("/foo/bar", "/foo", "baz/../../../bim.yaml", allowedRemoteProtocols)
+		assert.Error(t, err)
+		assert.Contains(t, err.Error(), "outside repository root")
+		assert.False(t, remote)
+		assert.Equal(t, "", string(p))
+	})
+	t.Run("Return verbatim URL", func(t *testing.T) {
+		url := "https://some.where/foo,yaml"
+		p, remote, err := ResolveFilePath("/foo/bar", "/foo", url, allowedRemoteProtocols)
+		assert.NoError(t, err)
+		assert.True(t, remote)
+		assert.Equal(t, url, string(p))
+	})
+	t.Run("URL scheme not allowed", func(t *testing.T) {
+		url := "file:///some.where/foo,yaml"
+		p, remote, err := ResolveFilePath("/foo/bar", "/foo", url, allowedRemoteProtocols)
+		assert.Error(t, err)
+		assert.False(t, remote)
+		assert.Equal(t, "", string(p))
+	})
+	t.Run("Implicit URL by absolute path", func(t *testing.T) {
+		p, remote, err := ResolveFilePath("/foo/bar", "/foo", "/baz.yaml", allowedRemoteProtocols)
+		assert.NoError(t, err)
+		assert.False(t, remote)
+		assert.Equal(t, "/foo/baz.yaml", string(p))
+	})
+	t.Run("Relative app path", func(t *testing.T) {
+		p, remote, err := ResolveFilePath(".", "/foo", "/baz.yaml", allowedRemoteProtocols)
+		assert.NoError(t, err)
+		assert.False(t, remote)
+		assert.Equal(t, "/foo/baz.yaml", string(p))
+	})
+	t.Run("Relative repo path", func(t *testing.T) {
+		c, err := os.Getwd()
+		require.NoError(t, err)
+		p, remote, err := ResolveFilePath(".", ".", "baz.yaml", allowedRemoteProtocols)
+		assert.NoError(t, err)
+		assert.False(t, remote)
+		assert.Equal(t, c+"/baz.yaml", string(p))
+	})
+	t.Run("Overlapping root prefix without trailing slash", func(t *testing.T) {
+		p, remote, err := ResolveFilePath(".", "/foo", "../foo2/baz.yaml", allowedRemoteProtocols)
+		assert.Error(t, err)
+		assert.Contains(t, err.Error(), "outside repository root")
+		assert.False(t, remote)
+		assert.Equal(t, "", string(p))
+	})
+	t.Run("Overlapping root prefix with trailing slash", func(t *testing.T) {
+		p, remote, err := ResolveFilePath(".", "/foo/", "../foo2/baz.yaml", allowedRemoteProtocols)
+		assert.Error(t, err)
+		assert.Contains(t, err.Error(), "outside repository root")
+		assert.False(t, remote)
+		assert.Equal(t, "", string(p))
+	})
+	t.Run("Garbage input as values file", func(t *testing.T) {
+		p, remote, err := ResolveFilePath(".", "/foo/", "kfdj\\ks&&&321209.,---e32908923%$ยง!\"", allowedRemoteProtocols)
+		assert.Error(t, err)
+		assert.Contains(t, err.Error(), "outside repository root")
+		assert.False(t, remote)
+		assert.Equal(t, "", string(p))
+	})
+	t.Run("NUL-byte path input as values file", func(t *testing.T) {
+		p, remote, err := ResolveFilePath(".", "/foo/", "\000", allowedRemoteProtocols)
+		assert.Error(t, err)
+		assert.Contains(t, err.Error(), "outside repository root")
+		assert.False(t, remote)
+		assert.Equal(t, "", string(p))
+	})
+}
diff --git a/reposerver/repository/testdata/symlinks/bam b/util/io/path/testdata/bam
similarity index 100%
rename from reposerver/repository/testdata/symlinks/bam
rename to util/io/path/testdata/bam
diff --git a/reposerver/repository/testdata/symlinks/bar b/util/io/path/testdata/bar
similarity index 100%
rename from reposerver/repository/testdata/symlinks/bar
rename to util/io/path/testdata/bar
diff --git a/reposerver/repository/testdata/symlinks/baz b/util/io/path/testdata/baz
similarity index 100%
rename from reposerver/repository/testdata/symlinks/baz
rename to util/io/path/testdata/baz
diff --git a/reposerver/repository/testdata/symlinks/foo b/util/io/path/testdata/foo
similarity index 100%
rename from reposerver/repository/testdata/symlinks/foo
rename to util/io/path/testdata/foo
