From a197d8f2f18001898b46e038ba3eb0ad8cf1420f Mon Sep 17 00:00:00 2001
From: Ashley Davis <ashley.davis@venafi.com>
Date: Tue, 5 Nov 2024 15:35:33 +0000
Subject: [PATCH] [release-1.12] security: remove calls to pem.Decode in
 non-test code

The changes are much smaller scoped in release-1.12 due to bigger diffs with master

Signed-off-by: Ashley Davis <ashley.davis@venafi.com>
---
 internal/controller/certificates/secrets.go | 10 +++++--
 pkg/controller/acmeorders/sync.go           | 20 +++++++++-----
 pkg/util/pki/csr.go                         | 13 ++++-----
 pkg/util/pki/parse.go                       | 29 ++++++++++++---------
 4 files changed, 45 insertions(+), 27 deletions(-)

diff --git a/internal/controller/certificates/secrets.go b/internal/controller/certificates/secrets.go
index cbec678e309..a1b007f34cb 100644
--- a/internal/controller/certificates/secrets.go
+++ b/internal/controller/certificates/secrets.go
@@ -19,9 +19,9 @@ package certificates
 import (
 	"bytes"
 	"crypto/x509"
-	"encoding/pem"
 	"strings"
 
+	"github.com/cert-manager/cert-manager/internal/pem"
 	apiutil "github.com/cert-manager/cert-manager/pkg/api/util"
 	cmapi "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
 	cmutil "github.com/cert-manager/cert-manager/pkg/util"
@@ -96,7 +96,13 @@ func AnnotationsForCertificateSecret(crt *cmapi.Certificate, certificate *x509.C
 // OutputFormatDER returns the byte slice of the private key in DER format. To
 // be used for Certificate's Additional Output Format DER.
 func OutputFormatDER(privateKey []byte) []byte {
-	block, _ := pem.Decode(privateKey)
+	// NOTE: This call to pem.SafeDecodePrivateKey ignores errors.
+	// This is acceptable here since we're calling this function only on PEM data which we created
+	// by encoding the private key. As such, we can be fairly confident that:
+	// 1) The PEM is valid
+	// 2) The PEM isn't attacker-controlled (and as such unsafe to decode)
+
+	block, _, _ := pem.SafeDecodePrivateKey(privateKey)
 	return block.Bytes
 }
 
diff --git a/pkg/controller/acmeorders/sync.go b/pkg/controller/acmeorders/sync.go
index 9ab74020d3d..dcabc623b5e 100644
--- a/pkg/controller/acmeorders/sync.go
+++ b/pkg/controller/acmeorders/sync.go
@@ -20,7 +20,7 @@ import (
 	"bytes"
 	"context"
 	"crypto/x509"
-	"encoding/pem"
+	stdpem "encoding/pem"
 	"fmt"
 	"time"
 
@@ -36,6 +36,7 @@ import (
 
 	"github.com/cert-manager/cert-manager/internal/controller/feature"
 	internalorders "github.com/cert-manager/cert-manager/internal/controller/orders"
+	"github.com/cert-manager/cert-manager/internal/pem"
 	"github.com/cert-manager/cert-manager/pkg/acme"
 	acmecl "github.com/cert-manager/cert-manager/pkg/acme/client"
 	cmacme "github.com/cert-manager/cert-manager/pkg/apis/acme/v1"
@@ -515,13 +516,18 @@ func (c *controller) finalizeOrder(ctx context.Context, cl acmecl.Interface, o *
 	// only supported DER encoded CSRs and not PEM encoded as they are intended
 	// to be as part of our API.
 	// To work around this, we first attempt to decode the Request into DER bytes
-	// by running pem.Decode. If the PEM block is empty, we assume that the Request
+	// by running pem.SafeDecodeCSR. If the PEM block is empty, we assume that the Request
 	// is DER encoded and continue to call FinalizeOrder.
 	var derBytes []byte
-	block, _ := pem.Decode(o.Spec.Request)
-	if block == nil {
-		log.V(logf.WarnLevel).Info("failed to parse Request as PEM data, attempting to treat Request as DER encoded for compatibility reasons")
-		derBytes = o.Spec.Request
+	block, _, err := pem.SafeDecodeCSR(o.Spec.Request)
+
+	if err != nil {
+		if err == pem.ErrNoPEMData {
+			log.V(logf.WarnLevel).Info("failed to parse Request as PEM data, attempting to treat Request as DER encoded for compatibility reasons")
+			derBytes = o.Spec.Request
+		} else {
+			return err
+		}
 	} else {
 		derBytes = block.Bytes
 	}
@@ -606,7 +612,7 @@ func (c *controller) storeCertificateOnStatus(ctx context.Context, o *cmacme.Ord
 	// encode the retrieved certificates (including the chain)
 	certBuffer := bytes.NewBuffer([]byte{})
 	for _, cert := range certs {
-		err := pem.Encode(certBuffer, &pem.Block{Type: "CERTIFICATE", Bytes: cert})
+		err := stdpem.Encode(certBuffer, &stdpem.Block{Type: "CERTIFICATE", Bytes: cert})
 		if err != nil {
 			log.Error(err, "invalid certificate data returned by ACME server")
 			c.setOrderState(&o.Status, string(cmacme.Errored))
diff --git a/pkg/util/pki/csr.go b/pkg/util/pki/csr.go
index ad8a0de2097..ad56016ee8b 100644
--- a/pkg/util/pki/csr.go
+++ b/pkg/util/pki/csr.go
@@ -22,7 +22,7 @@ import (
 	"crypto/rand"
 	"crypto/x509"
 	"crypto/x509/pkix"
-	"encoding/pem"
+	stdpem "encoding/pem"
 	"errors"
 	"fmt"
 	"math/big"
@@ -32,6 +32,7 @@ import (
 	"time"
 
 	"github.com/cert-manager/cert-manager/internal/controller/feature"
+	"github.com/cert-manager/cert-manager/internal/pem"
 	apiutil "github.com/cert-manager/cert-manager/pkg/api/util"
 	v1 "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
 	utilfeature "github.com/cert-manager/cert-manager/pkg/util/feature"
@@ -380,8 +381,8 @@ func GenerateTemplateFromCSRPEM(csrPEM []byte, duration time.Duration, isCA bool
 }
 
 func GenerateTemplateFromCSRPEMWithUsages(csrPEM []byte, duration time.Duration, isCA bool, keyUsage x509.KeyUsage, extKeyUsage []x509.ExtKeyUsage) (*x509.Certificate, error) {
-	block, _ := pem.Decode(csrPEM)
-	if block == nil {
+	block, _, err := pem.SafeDecodeCSR(csrPEM)
+	if err != nil {
 		return nil, errors.New("failed to decode csr")
 	}
 
@@ -443,7 +444,7 @@ func SignCertificate(template *x509.Certificate, issuerCert *x509.Certificate, p
 	}
 
 	pemBytes := bytes.NewBuffer([]byte{})
-	err = pem.Encode(pemBytes, &pem.Block{Type: "CERTIFICATE", Bytes: derBytes})
+	err = stdpem.Encode(pemBytes, &stdpem.Block{Type: "CERTIFICATE", Bytes: derBytes})
 	if err != nil {
 		return nil, nil, fmt.Errorf("error encoding certificate PEM: %s", err.Error())
 	}
@@ -489,7 +490,7 @@ func EncodeCSR(template *x509.CertificateRequest, key crypto.Signer) ([]byte, er
 // EncodeX509 will encode a single *x509.Certificate into PEM format.
 func EncodeX509(cert *x509.Certificate) ([]byte, error) {
 	caPem := bytes.NewBuffer([]byte{})
-	err := pem.Encode(caPem, &pem.Block{Type: "CERTIFICATE", Bytes: cert.Raw})
+	err := stdpem.Encode(caPem, &stdpem.Block{Type: "CERTIFICATE", Bytes: cert.Raw})
 	if err != nil {
 		return nil, err
 	}
@@ -515,7 +516,7 @@ func EncodeX509Chain(certs []*x509.Certificate) ([]byte, error) {
 			continue
 		}
 
-		err := pem.Encode(caPem, &pem.Block{Type: "CERTIFICATE", Bytes: cert.Raw})
+		err := stdpem.Encode(caPem, &stdpem.Block{Type: "CERTIFICATE", Bytes: cert.Raw})
 		if err != nil {
 			return nil, err
 		}
diff --git a/pkg/util/pki/parse.go b/pkg/util/pki/parse.go
index af2c524833b..af1559483f9 100644
--- a/pkg/util/pki/parse.go
+++ b/pkg/util/pki/parse.go
@@ -20,8 +20,9 @@ import (
 	"crypto"
 	"crypto/rsa"
 	"crypto/x509"
-	"encoding/pem"
+	stdpem "encoding/pem"
 
+	"github.com/cert-manager/cert-manager/internal/pem"
 	"github.com/cert-manager/cert-manager/pkg/util/errors"
 )
 
@@ -29,8 +30,8 @@ import (
 // It supports ECDSA, RSA and EdDSA private keys only. All other types will return err.
 func DecodePrivateKeyBytes(keyBytes []byte) (crypto.Signer, error) {
 	// decode the private key pem
-	block, _ := pem.Decode(keyBytes)
-	if block == nil {
+	block, _, err := pem.SafeDecodePrivateKey(keyBytes)
+	if err != nil {
 		return nil, errors.NewInvalidData("error decoding private key PEM block")
 	}
 
@@ -72,8 +73,8 @@ func DecodePrivateKeyBytes(keyBytes []byte) (crypto.Signer, error) {
 // DecodePKCS1PrivateKeyBytes will decode a PEM encoded RSA private key.
 func DecodePKCS1PrivateKeyBytes(keyBytes []byte) (*rsa.PrivateKey, error) {
 	// decode the private key pem
-	block, _ := pem.Decode(keyBytes)
-	if block == nil {
+	block, _, err := pem.SafeDecodePrivateKey(keyBytes)
+	if err != nil {
 		return nil, errors.NewInvalidData("error decoding private key PEM block")
 	}
 	// parse the private key
@@ -97,13 +98,17 @@ func DecodeX509CertificateChainBytes(certBytes []byte) ([]*x509.Certificate, err
 func DecodeX509CertificateSetBytes(certBytes []byte) ([]*x509.Certificate, error) {
 	certs := []*x509.Certificate{}
 
-	var block *pem.Block
+	var block *stdpem.Block
+	var err error
 
 	for {
-		// decode the tls certificate pem
-		block, certBytes = pem.Decode(certBytes)
-		if block == nil {
-			break
+		block, certBytes, err = pem.SafeDecodeMultipleCertificates(certBytes)
+		if err != nil {
+			if err == pem.ErrNoPEMData {
+				break
+			}
+
+			return nil, err
 		}
 
 		// parse the tls certificate
@@ -133,8 +138,8 @@ func DecodeX509CertificateBytes(certBytes []byte) (*x509.Certificate, error) {
 
 // DecodeX509CertificateRequestBytes will decode a PEM encoded x509 Certificate Request.
 func DecodeX509CertificateRequestBytes(csrBytes []byte) (*x509.CertificateRequest, error) {
-	block, _ := pem.Decode(csrBytes)
-	if block == nil {
+	block, _, err := pem.SafeDecodeCSR(csrBytes)
+	if err != nil {
 		return nil, errors.NewInvalidData("error decoding certificate request PEM block")
 	}
 
