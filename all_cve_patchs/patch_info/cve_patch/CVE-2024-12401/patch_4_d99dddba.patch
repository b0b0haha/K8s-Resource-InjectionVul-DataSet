From d99dddbadf9fc058bb1d22a03f692d4ea759196a Mon Sep 17 00:00:00 2001
From: Ashley Davis <ashley.davis@venafi.com>
Date: Fri, 1 Nov 2024 17:42:28 +0000
Subject: [PATCH] security: remove calls to pem.Decode in non-test code

Signed-off-by: Ashley Davis <ashley.davis@venafi.com>
---
 .../certificates/policies/checks_test.go      |  8 ++-
 internal/controller/certificates/secrets.go   | 10 ++-
 pkg/controller/acmeorders/sync.go             | 15 +++--
 pkg/controller/acmeorders/sync_test.go        |  5 +-
 .../issuing/internal/secret_test.go           |  4 +-
 .../issuing/secret_manager_test.go            |  6 +-
 pkg/util/pki/generate_test.go                 | 14 ++++-
 pkg/util/pki/nameconstraints_test.go          |  9 ++-
 pkg/util/pki/parse.go                         | 25 +++++---
 pkg/util/pki/parse_certificate_chain.go       |  3 +-
 pkg/util/pki/parse_certificate_chain_test.go  | 61 ++++++++++---------
 pkg/util/pki/sans_test.go                     | 15 ++++-
 12 files changed, 113 insertions(+), 62 deletions(-)

diff --git a/internal/controller/certificates/policies/checks_test.go b/internal/controller/certificates/policies/checks_test.go
index d083e30ba0e..1294bbb57bd 100644
--- a/internal/controller/certificates/policies/checks_test.go
+++ b/internal/controller/certificates/policies/checks_test.go
@@ -17,7 +17,6 @@ limitations under the License.
 package policies
 
 import (
-	"encoding/pem"
 	"testing"
 	"time"
 
@@ -28,6 +27,7 @@ import (
 	fakeclock "k8s.io/utils/clock/testing"
 	"k8s.io/utils/ptr"
 
+	"github.com/cert-manager/cert-manager/internal/pem"
 	cmapi "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
 	cmmeta "github.com/cert-manager/cert-manager/pkg/apis/meta/v1"
 	"github.com/cert-manager/cert-manager/pkg/util/pki"
@@ -1125,7 +1125,11 @@ func Test_SecretSecretTemplateManagedFieldsMismatch(t *testing.T) {
 func Test_SecretAdditionalOutputFormatsMismatch(t *testing.T) {
 	cert := []byte("a")
 	pk := testcrypto.MustCreatePEMPrivateKey(t)
-	block, _ := pem.Decode(pk)
+	block, _, err := pem.SafeDecodePrivateKey(pk)
+	if err != nil {
+		t.Fatalf("got unexpected error decoding PEM: %s", err)
+	}
+
 	pkDER := block.Bytes
 	combinedPEM := append(append(pk, '\n'), cert...)
 
diff --git a/internal/controller/certificates/secrets.go b/internal/controller/certificates/secrets.go
index 64007144157..18bb769482c 100644
--- a/internal/controller/certificates/secrets.go
+++ b/internal/controller/certificates/secrets.go
@@ -19,8 +19,8 @@ package certificates
 import (
 	"bytes"
 	"crypto/x509"
-	"encoding/pem"
 
+	"github.com/cert-manager/cert-manager/internal/pem"
 	cmapi "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
 	cmutil "github.com/cert-manager/cert-manager/pkg/util"
 	utilpki "github.com/cert-manager/cert-manager/pkg/util/pki"
@@ -86,7 +86,13 @@ func AnnotationsForCertificate(certificate *x509.Certificate) (map[string]string
 // OutputFormatDER returns the byte slice of the private key in DER format. To
 // be used for Certificate's Additional Output Format DER.
 func OutputFormatDER(privateKey []byte) []byte {
-	block, _ := pem.Decode(privateKey)
+	// NOTE: This call to pem.SafeDecodePrivateKey ignores errors.
+	// This is acceptable here since we're calling this function only on PEM data which we created
+	// by encoding the private key. As such, we can be fairly confident that:
+	// 1) The PEM is valid
+	// 2) The PEM isn't attacker-controlled (and as such unsafe to decode)
+
+	block, _, _ := pem.SafeDecodePrivateKey(privateKey)
 	return block.Bytes
 }
 
diff --git a/pkg/controller/acmeorders/sync.go b/pkg/controller/acmeorders/sync.go
index 4aa8c8613fd..2af09daa948 100644
--- a/pkg/controller/acmeorders/sync.go
+++ b/pkg/controller/acmeorders/sync.go
@@ -37,6 +37,7 @@ import (
 
 	"github.com/cert-manager/cert-manager/internal/controller/feature"
 	internalorders "github.com/cert-manager/cert-manager/internal/controller/orders"
+	safepem "github.com/cert-manager/cert-manager/internal/pem"
 	"github.com/cert-manager/cert-manager/pkg/acme"
 	acmecl "github.com/cert-manager/cert-manager/pkg/acme/client"
 	cmacme "github.com/cert-manager/cert-manager/pkg/apis/acme/v1"
@@ -511,13 +512,17 @@ func (c *controller) finalizeOrder(ctx context.Context, cl acmecl.Interface, o *
 	// only supported DER encoded CSRs and not PEM encoded as they are intended
 	// to be as part of our API.
 	// To work around this, we first attempt to decode the Request into DER bytes
-	// by running pem.Decode. If the PEM block is empty, we assume that the Request
+	// by running pem.SafeDecodeCSR. If the PEM block is empty, we assume that the Request
 	// is DER encoded and continue to call FinalizeOrder.
 	var derBytes []byte
-	block, _ := pem.Decode(o.Spec.Request)
-	if block == nil {
-		log.V(logf.WarnLevel).Info("failed to parse Request as PEM data, attempting to treat Request as DER encoded for compatibility reasons")
-		derBytes = o.Spec.Request
+	block, _, err := safepem.SafeDecodeCSR(o.Spec.Request)
+	if err != nil {
+		if err == safepem.ErrNoPEMData {
+			log.V(logf.WarnLevel).Info("failed to parse Request as PEM data, attempting to treat Request as DER encoded for compatibility reasons")
+			derBytes = o.Spec.Request
+		} else {
+			return err
+		}
 	} else {
 		derBytes = block.Bytes
 	}
diff --git a/pkg/controller/acmeorders/sync_test.go b/pkg/controller/acmeorders/sync_test.go
index 7387f4224e2..88e930b2696 100644
--- a/pkg/controller/acmeorders/sync_test.go
+++ b/pkg/controller/acmeorders/sync_test.go
@@ -18,7 +18,6 @@ package acmeorders
 
 import (
 	"context"
-	"encoding/pem"
 	"errors"
 	"fmt"
 	"testing"
@@ -31,6 +30,7 @@ import (
 	coretesting "k8s.io/client-go/testing"
 	fakeclock "k8s.io/utils/clock/testing"
 
+	"github.com/cert-manager/cert-manager/internal/pem"
 	accountstest "github.com/cert-manager/cert-manager/pkg/acme/accounts/test"
 	acmecl "github.com/cert-manager/cert-manager/pkg/acme/client"
 	cmacme "github.com/cert-manager/cert-manager/pkg/apis/acme/v1"
@@ -244,10 +244,11 @@ Dfvp7OOGAN6dEOM4+qR9sdjoSYKEBpsr6GtPAQw4dy753ec5
 	decodeAll := func(pemBytes []byte) [][]byte {
 		var blocks [][]byte
 		for {
-			block, rest := pem.Decode(pemBytes)
+			block, rest, _ := pem.SafeDecodeMultipleCertificates(pemBytes)
 			if block == nil {
 				break
 			}
+
 			blocks = append(blocks, block.Bytes)
 			pemBytes = rest
 		}
diff --git a/pkg/controller/certificates/issuing/internal/secret_test.go b/pkg/controller/certificates/issuing/internal/secret_test.go
index 8165247e3a6..de266772fc5 100644
--- a/pkg/controller/certificates/issuing/internal/secret_test.go
+++ b/pkg/controller/certificates/issuing/internal/secret_test.go
@@ -18,7 +18,6 @@ package internal
 
 import (
 	"context"
-	"encoding/pem"
 	"errors"
 	"strings"
 	"testing"
@@ -34,6 +33,7 @@ import (
 	fakeclock "k8s.io/utils/clock/testing"
 	"k8s.io/utils/ptr"
 
+	"github.com/cert-manager/cert-manager/internal/pem"
 	cmapi "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
 	cmmeta "github.com/cert-manager/cert-manager/pkg/apis/meta/v1"
 	controllerpkg "github.com/cert-manager/cert-manager/pkg/controller"
@@ -87,7 +87,7 @@ func Test_SecretsManager(t *testing.T) {
 			cmapi.CertificateAdditionalOutputFormat{Type: "CombinedPEM"},
 		),
 	)
-	block, _ := pem.Decode(baseCertBundle.PrivateKeyBytes)
+	block, _, _ := pem.SafeDecodePrivateKey(baseCertBundle.PrivateKeyBytes)
 	tlsDerContent := block.Bytes
 
 	tests := map[string]struct {
diff --git a/pkg/controller/certificates/issuing/secret_manager_test.go b/pkg/controller/certificates/issuing/secret_manager_test.go
index 7251c9db735..5f9f5422bdf 100644
--- a/pkg/controller/certificates/issuing/secret_manager_test.go
+++ b/pkg/controller/certificates/issuing/secret_manager_test.go
@@ -18,7 +18,6 @@ package issuing
 
 import (
 	"context"
-	"encoding/pem"
 	"testing"
 
 	"github.com/stretchr/testify/assert"
@@ -28,6 +27,7 @@ import (
 	"k8s.io/utils/ptr"
 
 	"github.com/cert-manager/cert-manager/internal/controller/certificates/policies"
+	"github.com/cert-manager/cert-manager/internal/pem"
 	cmapi "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
 	cmmeta "github.com/cert-manager/cert-manager/pkg/apis/meta/v1"
 	"github.com/cert-manager/cert-manager/pkg/controller/certificates/issuing/internal"
@@ -40,7 +40,9 @@ func Test_ensureSecretData(t *testing.T) {
 
 	pk := testcrypto.MustCreatePEMPrivateKey(t)
 	cert := testcrypto.MustCreateCert(t, pk, &cmapi.Certificate{Spec: cmapi.CertificateSpec{CommonName: "test"}})
-	block, _ := pem.Decode(pk)
+
+	block, _, _ := pem.SafeDecodePrivateKey(pk)
+
 	pkDER := block.Bytes
 	combinedPEM := append(append(pk, '\n'), cert...)
 
diff --git a/pkg/util/pki/generate_test.go b/pkg/util/pki/generate_test.go
index 83d1736808a..697151b491f 100644
--- a/pkg/util/pki/generate_test.go
+++ b/pkg/util/pki/generate_test.go
@@ -25,12 +25,12 @@ import (
 	"crypto/rsa"
 	"crypto/x509"
 	"crypto/x509/pkix"
-	"encoding/pem"
 	"fmt"
 	"strings"
 	"testing"
 	"time"
 
+	"github.com/cert-manager/cert-manager/internal/pem"
 	v1 "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
 )
 
@@ -423,11 +423,16 @@ O7WnDn8nuLFdW+NzzbIrTw==
 
 	testFn := func(test testT) func(*testing.T) {
 		return func(t *testing.T) {
-			block, _ := pem.Decode(privateKeyBytes)
+			block, _, err := pem.SafeDecodePrivateKey(privateKeyBytes)
+			if err != nil {
+				t.Fatalf("expected no PEM decode err but got %s", err)
+			}
+
 			decodedKey, err := x509.ParsePKCS8PrivateKey(block.Bytes)
 			if err != nil {
 				t.Fatal(err)
 			}
+
 			encodedKey, err := EncodePrivateKey(decodedKey, test.keyEncoding)
 			if test.expectErr {
 				if err == nil {
@@ -449,7 +454,10 @@ O7WnDn8nuLFdW+NzzbIrTw==
 
 				expectedEncoding := test.keyEncoding
 				actualEncoding := v1.PrivateKeyEncoding("")
-				block, _ := pem.Decode(encodedKey)
+				block, _, err := pem.SafeDecodePrivateKey(encodedKey)
+				if err != nil {
+					t.Fatalf("expected no PEM decode err but got %s", err)
+				}
 
 				switch block.Type {
 				case "PRIVATE KEY":
diff --git a/pkg/util/pki/nameconstraints_test.go b/pkg/util/pki/nameconstraints_test.go
index c0bf8667426..e7e15679937 100644
--- a/pkg/util/pki/nameconstraints_test.go
+++ b/pkg/util/pki/nameconstraints_test.go
@@ -20,13 +20,14 @@ import (
 	"bytes"
 	"crypto/x509"
 	"crypto/x509/pkix"
-	"encoding/pem"
 	"fmt"
 	"net"
 	"strings"
 	"testing"
 
 	"github.com/stretchr/testify/assert"
+
+	"github.com/cert-manager/cert-manager/internal/pem"
 )
 
 // TestMarshalNameConstraints tests the MarshalNameConstraints function
@@ -202,7 +203,11 @@ func getExtensionFromPem(pemData string) (pkix.Extension, error) {
 	pemData = strings.TrimSpace(pemData)
 	csrPEM := []byte(pemData)
 
-	block, _ := pem.Decode(csrPEM)
+	block, _, err := pem.SafeDecodeCSR(csrPEM)
+	if err != nil {
+		return pkix.Extension{}, fmt.Errorf("expected no PEM decode err but got %s", err)
+	}
+
 	if block == nil || block.Type != "CERTIFICATE REQUEST" {
 		return pkix.Extension{}, fmt.Errorf("Failed to decode PEM block or the type is not 'CERTIFICATE REQUEST'")
 	}
diff --git a/pkg/util/pki/parse.go b/pkg/util/pki/parse.go
index fd84563276f..62daf9857df 100644
--- a/pkg/util/pki/parse.go
+++ b/pkg/util/pki/parse.go
@@ -19,8 +19,9 @@ package pki
 import (
 	"crypto"
 	"crypto/x509"
-	"encoding/pem"
+	stdpem "encoding/pem"
 
+	"github.com/cert-manager/cert-manager/internal/pem"
 	"github.com/cert-manager/cert-manager/pkg/util/errors"
 )
 
@@ -28,8 +29,8 @@ import (
 // It supports ECDSA, RSA and EdDSA private keys only. All other types will return err.
 func DecodePrivateKeyBytes(keyBytes []byte) (crypto.Signer, error) {
 	// decode the private key pem
-	block, _ := pem.Decode(keyBytes)
-	if block == nil {
+	block, _, err := pem.SafeDecodePrivateKey(keyBytes)
+	if err != nil {
 		return nil, errors.NewInvalidData("error decoding private key PEM block")
 	}
 
@@ -77,13 +78,19 @@ func DecodeX509CertificateChainBytes(certBytes []byte) ([]*x509.Certificate, err
 func DecodeX509CertificateSetBytes(certBytes []byte) ([]*x509.Certificate, error) {
 	certs := []*x509.Certificate{}
 
-	var block *pem.Block
+	var block *stdpem.Block
 
 	for {
+		var err error
+
 		// decode the tls certificate pem
-		block, certBytes = pem.Decode(certBytes)
-		if block == nil {
-			break
+		block, certBytes, err = pem.SafeDecodeMultipleCertificates(certBytes)
+		if err != nil {
+			if err == pem.ErrNoPEMData {
+				break
+			}
+
+			return nil, err
 		}
 
 		// parse the tls certificate
@@ -113,8 +120,8 @@ func DecodeX509CertificateBytes(certBytes []byte) (*x509.Certificate, error) {
 
 // DecodeX509CertificateRequestBytes will decode a PEM encoded x509 Certificate Request.
 func DecodeX509CertificateRequestBytes(csrBytes []byte) (*x509.CertificateRequest, error) {
-	block, _ := pem.Decode(csrBytes)
-	if block == nil {
+	block, _, err := pem.SafeDecodeCSR(csrBytes)
+	if err != nil {
 		return nil, errors.NewInvalidData("error decoding certificate request PEM block")
 	}
 
diff --git a/pkg/util/pki/parse_certificate_chain.go b/pkg/util/pki/parse_certificate_chain.go
index bb656706efe..aab8aec0940 100644
--- a/pkg/util/pki/parse_certificate_chain.go
+++ b/pkg/util/pki/parse_certificate_chain.go
@@ -93,8 +93,7 @@ func ParseSingleCertificateChain(certs []*x509.Certificate) (PEMBundle, error) {
 	}
 
 	// To prevent a malicious input from causing a DoS, we limit the number of unique
-	// certificates to 1000. This helps us avoid issues with O(n^2) time complexity
-	// in the algorithm below.
+	// certificates. This helps us avoid issues with O(n^2) time complexity in the algorithm below.
 	if len(certs) > 1000 {
 		return PEMBundle{}, errors.NewInvalidData("certificate chain is too long, must be less than 1000 certificates")
 	}
diff --git a/pkg/util/pki/parse_certificate_chain_test.go b/pkg/util/pki/parse_certificate_chain_test.go
index 1807331c6d3..15549d33c26 100644
--- a/pkg/util/pki/parse_certificate_chain_test.go
+++ b/pkg/util/pki/parse_certificate_chain_test.go
@@ -89,7 +89,7 @@ func joinPEM(first []byte, rest ...[]byte) []byte {
 	return first
 }
 
-func TestParseSingleCertificateChain(t *testing.T) {
+func TestParseSingleCertificateChainPEM(t *testing.T) {
 	root := mustCreateBundle(t, nil, "root")
 	intA1 := mustCreateBundle(t, root, "intA-1")
 	intA2 := mustCreateBundle(t, intA1, "intA-2")
@@ -99,20 +99,20 @@ func TestParseSingleCertificateChain(t *testing.T) {
 	leafInterCN := mustCreateBundle(t, intA2, intA2.cert.Subject.CommonName)
 	random := mustCreateBundle(t, nil, "random")
 
-	var thousandCertBundle PEMBundle
+	var bigCertBundle PEMBundle
 	{
 		root := mustCreateBundle(t, nil, "root")
-		thousandCertBundle.CAPEM = root.pem
+		bigCertBundle.CAPEM = root.pem
 
 		cert := root
 		var pems [][]byte
-		for i := 0; i < 999; i++ {
+		for i := 0; i < 100; i++ {
 			cert = mustCreateBundle(t, cert, fmt.Sprintf("int-%d", i))
 			pems = append(pems, cert.pem)
 		}
 
 		for i := len(pems) - 1; i >= 0; i-- {
-			thousandCertBundle.ChainPEM = joinPEM(thousandCertBundle.ChainPEM, pems[i])
+			bigCertBundle.ChainPEM = joinPEM(bigCertBundle.ChainPEM, pems[i])
 		}
 	}
 
@@ -211,18 +211,18 @@ func TestParseSingleCertificateChain(t *testing.T) {
 			expPEMBundle: PEMBundle{ChainPEM: joinPEM(root.pem), CAPEM: root.pem},
 			expErr:       false,
 		},
-		"if long chain is passed (<= 1000 certs), a result should be returned quickly": {
-			inputBundle:  joinPEM(thousandCertBundle.ChainPEM, thousandCertBundle.CAPEM),
-			expPEMBundle: thousandCertBundle,
+		"if acceptable long chain is passed, a result should be returned quickly": {
+			inputBundle:  joinPEM(bigCertBundle.ChainPEM, bigCertBundle.CAPEM),
+			expPEMBundle: bigCertBundle,
 			expErr:       false,
 		},
-		"if very long chain is passed (> 1000 certs), should error without DoS (1)": {
+		"if unacceptably long chain is passed, should error without DoS": {
 			inputBundle: func() []byte {
 				root := mustCreateBundle(t, nil, "root")
 
 				cert := root
 				var chain []byte
-				for i := 0; i < 1001; i++ {
+				for i := 0; i < 501; i++ {
 					cert = mustCreateBundle(t, cert, fmt.Sprintf("int-%d", i))
 					chain = joinPEM(chain, cert.pem)
 				}
@@ -231,24 +231,7 @@ func TestParseSingleCertificateChain(t *testing.T) {
 			}(),
 			expPEMBundle: PEMBundle{},
 			expErr:       true,
-			expErrString: "certificate chain is too long, must be less than 1000 certificates",
-		},
-		"if very long chain is passed (> 1000 certs), should error without DoS (2)": {
-			inputBundle: func() []byte {
-				root := mustCreateBundle(t, nil, "root")
-
-				cert := root
-				var chain []byte
-				for i := 0; i < 10000; i++ {
-					cert = mustCreateBundle(t, cert, fmt.Sprintf("int-%d", i))
-					chain = joinPEM(chain, cert.pem)
-				}
-
-				return chain
-			}(),
-			expPEMBundle: PEMBundle{},
-			expErr:       true,
-			expErrString: "certificate chain is too long, must be less than 1000 certificates",
+			expErrString: "provided PEM data was larger than the maximum 65000B",
 		},
 	}
 
@@ -277,3 +260,25 @@ func TestParseSingleCertificateChain(t *testing.T) {
 		})
 	}
 }
+
+func TestParseSingleCertificateChain(t *testing.T) {
+	// ParseSingleCertificateChain is mostly tested in TestParseSingleCertificateChainPEM;
+	// this test checks that passing in too many small certs is correctly rejected
+	var inputBundle []*x509.Certificate
+
+	for i := 0; i < 1001; i++ {
+		cert := mustCreateBundle(t, nil, fmt.Sprintf("cert-%d", i))
+		inputBundle = append(inputBundle, cert.cert)
+	}
+
+	_, err := ParseSingleCertificateChain(inputBundle)
+	if err == nil {
+		t.Fatalf("expected error but got none from ParseSingleCertificateChain")
+	}
+
+	expErr := "certificate chain is too long, must be less than 1000 certificates"
+
+	if err.Error() != expErr {
+		t.Fatalf("expected err to be %s but it was %s", expErr, err.Error())
+	}
+}
diff --git a/pkg/util/pki/sans_test.go b/pkg/util/pki/sans_test.go
index 9aa743d823d..5567685f858 100644
--- a/pkg/util/pki/sans_test.go
+++ b/pkg/util/pki/sans_test.go
@@ -20,13 +20,18 @@ import (
 	"crypto/x509"
 	"crypto/x509/pkix"
 	"encoding/asn1"
-	"encoding/pem"
 	"reflect"
 	"testing"
+
+	"github.com/cert-manager/cert-manager/internal/pem"
 )
 
 func extractSANsFromCertificate(t *testing.T, certDER string) pkix.Extension {
-	block, rest := pem.Decode([]byte(certDER))
+	block, rest, err := pem.SafeDecodeSingleCertificate([]byte(certDER))
+	if err != nil {
+		t.Fatalf("expected no PEM decode err but got %s", err)
+	}
+
 	if len(rest) > 0 {
 		t.Fatal("Expected no rest")
 	}
@@ -47,7 +52,11 @@ func extractSANsFromCertificate(t *testing.T, certDER string) pkix.Extension {
 }
 
 func extractSANsFromCertificateRequest(t *testing.T, csrDER string) pkix.Extension {
-	block, rest := pem.Decode([]byte(csrDER))
+	block, rest, err := pem.SafeDecodeCSR([]byte(csrDER))
+	if err != nil {
+		t.Fatalf("expected no PEM decode err but got %s", err)
+	}
+
 	if len(rest) > 0 {
 		t.Fatal("Expected no rest")
 	}
